# 文件描述符详解

- 用户使用文件是通过文件名检索inode

- 程序是通过文件描述符检索inode





## 文件描述符是什么

文件描述符可以看作是**文件的一种抽象表示**，这种抽象使得程序能够以统一的方式访问各种类型的文件，包括：

- 普通文件
- 管道
- 套接字
- 设备文件（字符设备或块设备）



操作系统通过文件描述符屏蔽了这些文件的底层差异，为应用程序提供了一种统一的接口。

**在程序看来，文件描述符就是通向各种输入输出资源的“句柄”**





### 示例：文件描述符的统一操作

- **普通文件**

``````C
int fd = open("example.txt", O_RDONLY);
char buffer[128];
read(fd, buffer, sizeof(buffer)); // 从文件读取
close(fd);
``````



- **管道**

``````C
int fd[2];
pipe(fd); // fd[0] 读端，fd[1] 写端
write(fd[1], "Hello", 5); // 向管道写入数据
char buffer[128];
read(fd[0], buffer, sizeof(buffer)); // 从管道读取数据
``````



- **套接字：**

``````C
int sockfd = socket(AF_INET, SOCK_STREAM, 0);
connect(sockfd, (struct sockaddr *)&server, sizeof(server));
write(sockfd, "GET / HTTP/1.1\r\n", 16); // 向套接字写入数据
char buffer[128];
read(sockfd, buffer, sizeof(buffer)); // 从套接字读取数据
``````



## 文件描述符的作用

- **文件描述符本质上是一个索引值**，它存在于进程的文件描述符表（File Descriptor Table）中。

  - 文件描述符本质是一个索引，那么问题来了，是谁的索引

    - 文件描述符表的索引，每个文件描述符指向这个进程的文件描述符表的一个索引值

    - 文件描述符表包含的关键数据

      - **索引（文件描述符）**：

        - 文件描述符是表的索引，用于标识进程打开的文件资源。

        **指向全局打开文件表的指针**：

        - 这是文件描述符表条目最核心的数据。
        - 它是一个指针，指向全局打开文件表中的**具体条目**，而不是整个表。

        **附加标志**：

        - 例如文件描述符是否设置了 **非阻塞模式（O_NONBLOCK）**，或是否继承到子进程（`O_CLOEXEC`）。

- 通过文件描述符，程序可以访问与之关联的文件资源（如普通文件、套接字、管道等），而这些资源在内核中有对应的数据结构来管理。





## 文件描述表是什么

- 每个进程有一个文件描述符表，记录当前进程打开的所有文件。

- 文件描述符表的每个条目指向内核的文件表。





## 全局打开文件表是什么

全局打开文件表（Global Open File Table）是 Linux 文件系统的核心数据结构之一，它位于内核中，主要用于管理系统中所有进程当前打开的文件状态。



#### **全局打开文件表的主要作用**

1. **文件状态的统一管理**：
   - 全局打开文件表记录系统中所有打开文件的状态，如文件的访问模式、当前偏移量等。
   - 它是所有进程共享的资源，避免重复管理同一文件。
2. **实现文件共享**：
   - 如果多个进程打开同一个文件，它们的文件描述符表条目会指向全局打开文件表中的同一个条目，从而共享文件状态（如文件偏移量）。
3. **连接内存中的 `inode` 对象**：
   - 全局打开文件表通过指针与内存中的 `inode` 对象关联，从而实现对文件元数据的快速访问。
4. **支持多层次的抽象和优化**：
   - 提供对文件、管道、套接字等资源的统一抽象。
   - 通过缓存和引用计数等机制优化文件操作性能。



### **2. 全局打开文件表的结构**

全局打开文件表是一个内核中的数据结构数组或链表，每个条目记录一个已打开文件的状态。

#### **2.1 全局打开文件表的条目内容**

一个全局打开文件表条目通常包含以下数据：

| 字段                    | 含义                                                         |
| ----------------------- | ------------------------------------------------------------ |
| **文件偏移量**          | 当前文件读写的位置（例如调用 `read()` 或 `write()` 时使用）。 |
| **访问模式**            | 文件的打开模式，如只读（`O_RDONLY`）、只写（`O_WRONLY`）、读写（`O_RDWR`）。 |
| **引用计数**            | 记录该文件被引用的次数，用于管理共享文件的资源释放。         |
| **指向 `inode` 的指针** | 指向内存中的 `inode` 对象，用于访问文件元数据和存储位置。    |
| **锁信息**              | 与该文件关联的文件锁（如记录锁或共享锁）。                   |
| **文件类型**            | 描述文件类型（如普通文件、管道、套接字）。                   |
| **文件操作方法**        | 指向操作方法表，用于实现读、写等操作（通常指向 `struct file_operations`）。 |

------





### **全局打开文件表的作用流程**

#### **1 打开文件**

1. 用户调用 `open()` 系统调用，传入文件名和打开模式。
2. 内核解析文件路径，通过目录项找到文件的 `inode` 号。
3. 如果文件尚未被打开：
   - 从磁盘加载 `inode` 到内存，生成 `inode` 对象。
   - 在全局打开文件表中分配一个条目，记录文件的状态并指向 `inode` 对象。
4. 如果文件已被打开：
   - 复用现有的全局打开文件表条目，增加引用计数。

#### **2 读写文件**

1. 用户调用 `read()` 或 `write()` 系统调用，传入文件描述符。
2. 内核通过文件描述符表定位全局打开文件表条目。
3. 使用条目中的偏移量和访问模式完成读写操作。
4. 更新文件偏移量，确保下次读写操作的连续性。

#### **3 关闭文件**

1. 用户调用 `close()` 系统调用。
2. 内核减少全局打开文件表条目的引用计数。
3. 如果引用计数为 0，释放全局打开文件表条目，并同步 `inode` 数据到磁盘。



``````
+--------------------+
| 文件描述符表 (进程) |
+--------------------+
| fd: 3             | -----> 指向全局打开文件表的具体条目
| fd: 4             | -----> 指向全局打开文件表的具体条目
+--------------------+
       ↓
+--------------------------+
| 全局打开文件表 (系统范围) |
+--------------------------+
| 文件偏移量、访问模式      |
| 引用计数：2              |
| 指向 inode 的指针         | -----> +-----------------------+
| 文件操作方法             |        | 内存中的 inode 对象    |
+--------------------------+        +-----------------------+
``````



### **文件描述符表的位置**

- **文件描述符表是每个进程的私有资源**，它属于进程的用户态上下文。
- 在 Linux 内核中，每个进程由一个 `task_struct` 数据结构表示，该结构包含进程的所有状态信息。
- **`task_struct` 数据结构中的字段 `files` 指向文件描述符表**。

#### ** 文件描述符表的指针**

- 在内核中，`task_struct` 的 `files` 字段是一个指针，指向与该进程关联的 `files_struct` 结构。
- **`files_struct` 结构** 记录了该进程的文件描述符表及相关信息。

``````
+--------------------+
| task_struct (进程) |
+--------------------+
| files             | -----> 指向 files_struct
+--------------------+
       ↓
+--------------------------+
| files_struct            |
+--------------------------+
| fdtable 指针           | -----> 指向 fdtable
+--------------------------+
       ↓
+----------------------------+
| fdtable                   |
+----------------------------+
| 文件描述符数组 fd         | -----> 每个条目指向全局打开文件表的条目
+----------------------------+
       ↓
+-----------------------------+
| 全局打开文件表             |
+-----------------------------+
| 文件偏移量、访问模式        |
| 指向 inode 的指针           | -----> 指向内存中的 inode 对象
+-----------------------------+
``````



### **3. 全局打开文件表的作用场景**

### 文件描述符的内核关联

文件描述符间接关联文件的内存空间，其关系如下：

1. **文件描述符表**：
   - 每个进程有一个文件描述符表，文件描述符是该表的索引。
   - 表中的每个条目包含一个指针，指向内核的全局打开文件表。
2. **全局打开文件表**：
   - 文件描述符表的指针指向内核的全局打开文件表（Open File Table）。
   - 全局打开文件表记录了文件的具体信息，如当前偏移量、访问模式（只读、只写等）。
3. **inode对象**：
   - 全局打开文件表中的条目指向文件的 inode 对象，inode 存储文件的元数据（如大小、权限）和文件在磁盘上的存储地址。
4. **缓存或缓冲区**：
   - 文件的数据（内容）被加载到内存的缓存中，例如：
     - **页缓存**（Page Cache）：普通文件的内容缓存在内存中，避免频繁访问磁盘。
     - **套接字缓冲区**：网络数据存储在内核的 socket 缓冲区中。
     - **管道缓冲区**：管道中的数据被存储在内核的管道缓冲区。







### **全局打开文件表指向的是内存中的 `inode` 对象**

1. **全局打开文件表的作用**
   - 全局打开文件表记录文件的状态信息（如偏移量、打开模式）。
   - 它通过一个指针，指向内存中的 `inode` 对象，而不是磁盘上的 `inode 表`。
2. **`inode 对象` 的位置**
   - 当文件被打开时，操作系统从磁盘上的 `inode 表` 加载对应的 `inode` 数据到内存中，生成一个 `inode` 对象。
   - 这个 `inode` 对象是文件在内存中的元数据表示，用于快速访问文件的属性和存储位置。
3. **为什么指向 `inode 对象` 而非磁盘上的 `inode 表`**
   - **性能**：直接访问磁盘上的 `inode 表` 会导致频繁的磁盘 I/O，效率低下。
   - **动态性**：`inode` 对象存储在内存中，可以动态修改，比如记录打开状态、缓存信息。
   - **统一接口**：文件系统通过内存中的 `inode` 对象管理文件，不依赖具体的底层存储实现。







## **从文件描述符到文件内容的访问流程**

假设打开文件 `/path/to/file`：

1. **解析路径，找到 `inode`**：

   - 操作系统逐级解析 `/path/to/file`，在目录项中找到文件的 `inode 号`。

2. **加载 `inode` 到内存**：

   - 根据 `inode 号`，从磁盘上的 `inode 表` 加载数据，创建内存中的 `inode` 对象。

3. **创建全局打开文件表条目**：

   - 在全局打开文件表中分配一个条目，记录文件的状态（偏移量、访问模式）并指向内存中的 `inode`。

4. **更新文件描述符表**：

   - 在进程的文件描述符表中分配一个条目，指向全局打开文件表。

   - **操作文件**：

   - 通过文件描述符调用 

     ```
     read()
     ```

      或 

     ```
     write()
     ```

     ：

     - 文件描述符表定位全局打开文件表。
     - 全局打开文件表找到 `inode`。
     - 通过 `inode` 指针访问文件内容（缓存或磁盘）。

     

**总结：文件描述符 → 文件描述符表 → 全局打开文件表 → 内存中的 `inode` → 文件内容（缓存或磁盘）。**





## 关于数据和元数据分开存储

文件的元数据和数据会分别缓存在内存中的不同位置



### **1. 元数据与数据的内存缓冲位置**

#### **1.1 元数据缓存在内存中的位置**

- **元数据**：

  - 包括文件的大小、权限、时间戳、指向数据块的指针等信息。
  - 这些信息来自磁盘上的 `inode`，在文件被访问时会被加载到内存中。

- **存储位置**：

  - `inode` 缓存

    ：

    - 内核会将文件的 `inode` 数据加载到内存中并存储在 `inode 缓存` 中。
    - `inode 缓存` 用于加速对文件元数据的访问，避免频繁从磁盘读取 `inode`。

  - 数据结构

    ：

    - 每个 `inode` 缓存条目对应一个内存中的 `inode 对象`。

#### **1.2 数据缓存在内存中的位置**

- **文件数据**：

  - 指文件内容本身（如文本文件中的文本、图片文件中的图像数据）。
  - 这些数据通常以块为单位存储在磁盘中。

- **存储位置**：

  - 页缓存（Page Cache）

    ：

    - 文件数据会缓存在页缓存中，页缓存是内核用于管理文件数据的内存区域。
    - 页缓存加速了文件的读写操作，避免每次访问都从磁盘加载数据。

------

### **2. 为什么元数据和数据分开缓存**

#### **2.1 访问频率的差异**

- 元数据

  ：

  - 文件系统操作（如 `stat`、`ls`）更多地涉及元数据而非数据本身。
  - 将元数据单独缓存可以加速文件系统操作。

- 数据

  ：

  - 文件内容的读取和写入涉及实际数据块，需要页缓存进行优化。

#### **2.2 数据结构的不同**

- 元数据

  ：

  - 以 `inode 对象` 的形式存储，通常较小，结构紧凑。

- 数据

  ：

  - 按数据块（如 4KB）的形式存储，占用的空间大，需要高效的页管理。

------

### **3. 两者协作的过程**

以下是一个文件操作（如读取文件）的数据流，展示了元数据和数据缓存的协作关系：

#### **3.1 打开文件**

1. 文件路径解析找到目录项，并通过目录项找到文件的 `inode`。
2. 从磁盘加载 `inode` 到 `inode 缓存`，生成一个 `inode 对象`。

#### **3.2 读取数据**

1. 通过 `inode` 找到文件数据块的位置。
2. 检查对应的数据块是否已存在于页缓存中：
   - 如果存在，直接从页缓存读取数据。
   - 如果不存在，从磁盘加载数据块到页缓存，再返回给应用程序。

------

### **4. 具体数据流图**

```
plaintextCopy code1. 文件路径解析
   ↓
2. 在目录项中找到 inode 号
   ↓
3. 从磁盘加载 inode 到 inode 缓存（内存中的 inode 对象）
   ↓
4. 检查页缓存是否包含目标数据块
   ↓
   (是) → 直接读取数据块
   (否) → 从磁盘加载数据块到页缓存
```

------

### **5. 示例**

假设我们使用 `cat file.txt` 来读取文件内容：

#### **5.1 元数据操作**

1. `cat` 通过文件名找到 `inode`。
2. 系统从磁盘加载文件的 `inode` 到内存中的 `inode 缓存`。
3. `inode` 缓存记录了文件的大小、权限以及数据块位置等元数据。

#### **5.2 数据操作**

1. 根据 `inode` 中的指针，找到文件的第一个数据块。
2. 检查页缓存是否已经包含该数据块：
   - 如果在页缓存中，则直接读取。
   - 如果不在页缓存中，从磁盘加载数据块到页缓存，再返回给 `cat`。

------

### **6. 两种缓存的优势**

#### **6.1 `inode` 缓存的优势**

- 加速文件元数据操作（如路径解析、权限检查）。
- 节省磁盘 I/O，避免频繁访问磁盘上的 `inode 表`。

#### **6.2 页缓存的优势**

- 提升文件数据的读写性能。
- 支持内存中数据的合并和重用，优化随机访问性能