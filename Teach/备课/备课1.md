# 第一天











## 块 与 inode



一块磁盘会被划分为许多扇区，每个扇区是最小的可寻址读写单元；



硬盘分成相同大小的单元，我们称为块。一块的大小通常是扇区（512B）的整数倍，默认是4K（8个扇区），文件系统的块不能小于扇区，否则会造成无法精确映射



## 块大小是在格式化时设定的

文件系统格式化时，可以指定块大小

如ext4:

```bash
mkfs.ext4 -b 4096 /dev/sdX
```

块越大，**顺序读写效率越高**，但会浪费空间（**内存碎片**）；

- 适合大文件 → 块大；
- 适合小文件 → 块小；



## **扇区大小是硬盘硬件固定的，不可更改**

- 扇区大小由硬盘固件写死，用户无法更改；
- 使用命令如 `fdisk -l` 或 `lsblk -t` 可以查看当前硬盘扇区大小；
- 有些 SSD 和高级硬盘支持 **真实 4K 扇区（4096B）**，性能更好。





## 查看硬盘扇区/块大小的命令（Linux）

```bash
# 查看扇区大小
cat /sys/block/sdX/queue/hw_sector_size
cat /sys/block/sdX/queue/logical_block_size

# 查看文件系统块大小
sudo blockdev --getbsz /dev/sdX
sudo tune2fs -l /dev/sdX1 | grep "Block size"
```

> **通常情况下，操作系统会要求内存页大小与文件系统块大小保持对齐关系**，即：
>
> > **内存页大小 ≥ 块大小，且通常是块大小的整数倍**
> >  以确保**页与块之间可以高效映射**，避免浪费或拆分。







# 第二天







## 什么是Shell

Shell 是一个命令行解释器，它是用户与操作系统（特别是内核）之间的接口，负责解释用户命令、调度程序执行、控制输入输出等。

Shell 是操作系统（尤其是内核）和用户之间的一个命令解释器/翻译工具，主要负责把人类可读的命令翻译成系统调用或程序执行。





## 举个例子来说明：

当你在终端中输入：

```bash
ls -l /home/user
```

Shell 会做什么？

1. **解析命令**：将命令解析为程序名 `ls` 和参数 `-l /home/user`
2. **查找可执行文件**：在 `$PATH` 中找到 `/bin/ls`
3. **调用系统调用**：
   - 使用 `fork()` 创建一个子进程
   - 在子进程中 `exec()` 执行 `/bin/ls`
4. **ls 程序运行时访问内核提供的文件系统信息**
5. **将输出打印回终端**







## Shell 与用户 & 内核的交互图：

```css
┌───────────────────────────┐
│        用户（User）        │
│  ⌨ 键盘输入、👀 查看输出     │
└────────────┬──────────────┘
             │
             ▼
┌───────────────────────────┐
│      终端（Terminal）       │
│  图形终端/TTY/SSH/PTTY     │
│  提供输入输出界面（/dev/tty）│
└────────────┬──────────────┘
             │
             ▼
┌───────────────────────────┐
│     Shell（如 bash）       │
│ 🧠 解析命令、脚本           │
│ 📦 调用内核系统服务         │
└────────────┬──────────────┘
             │
             ▼
┌───────────────────────────┐
│      内核（Kernel）        │
│ 🧩 进程调度、文件系统、网络 │
│ 🛠️ 提供系统调用接口         │
└────────────┬──────────────┘
             │
             ▼
┌───────────────────────────┐
│  硬件资源（磁盘/CPU/网卡等）│
└───────────────────────────┘

```



## Shell 和终端的区别

很多人会混淆 **Shell** 和 **终端**，它们是**两个不同层次的组件**：

| 项目 | Shell                            | 终端（Terminal）                  |
| ---- | -------------------------------- | --------------------------------- |
| 本质 | 命令解释器程序                   | 提供用户与计算机交互的界面（TTY） |
| 举例 | bash, zsh, fish                  | xterm, gnome-terminal, tty        |
| 作用 | 解释执行用户输入的命令           | 接收键盘输入 & 显示程序输出       |
| 属于 | 应用层程序                       | 更接近设备驱动/界面层             |
| 地位 | **用户和内核之间的命令解释桥梁** | **用户和 Shell 之间的接口桥梁**   |





## 终端的两种类型

### ▶️ 物理终端（tty）

- 键盘 + 屏幕 + tty 驱动
- 在 Linux 下叫 `/dev/tty1`, `/dev/tty2` ...

### ▶️ 虚拟终端（pseudo terminal，PTY）

- 图形终端或远程终端模拟出来的 TTY，如：
  - `xterm`, `gnome-terminal`, `ssh`
  - 实际设备：`/dev/pts/0`, `/dev/pts/1`...





## 什么是终端

**Terminal（终端）本质上是一个运行在用户态的应用程序**，
 作用是**提供一个字符输入/输出界面**，并把用户输入传递给 Shell（也是一个用户态程序）。





## 什么是PTY？

**实现 PTY 的代码，本质上就是 Linux 内核中定义的一组“驱动函数”**，这些函数运行在内核态，用于响应系统调用，是内核驱动框架中的核心组成部分

PTY 是内核提供的一种**字符设备机制**，不是单独的“内核态程序”，也**不是某个系统调用函数本身**，但它确实由内核负责维护、调度和提供接口。

也就是说PTY是内核字符设备

在类 Unix 系统中：

- PTY（伪终端）模拟一个物理终端设备（比如你插的串口终端），用于实现图形终端、远程终端等
- PTY 由内核维护，分为两端：

| 端口               | 作用                                           | 表现为                          |
| ------------------ | ---------------------------------------------- | ------------------------------- |
| **Master（主端）** | 由终端程序持有，用于发送用户输入、读取程序输出 | `/dev/ptmx`（伪终端分配器）     |
| **Slave（从端）**  | 提供给 Shell 或运行程序，模拟标准终端接口      | `/dev/pts/N`（如 `/dev/pts/0`） |





## 执行终端程序后发生了什么？

每执行一次终端程序（如 `xterm`、`ssh`、`script`、`tmux` 等）时，系统都会为其分配一个独立的 pty master/slave 对。

内核将：

1. 分配一个新的 **pty master 设备（匿名）**
2. 自动创建并注册对应的 **slave 设备 `/dev/pts/N`**
3. 绑定这两个设备，维护一个对应的共享缓冲区
4. 返回你拿到的 **`master_fd` 是唯一的**



## 你输入一行命令发生了什么？

以用户在终端（比如 script、xterm、ssh）输入命令 `ls -l` 为例：

0. 用户在物理键盘上输入字符；操作系统的输入设备驱动捕获按键事件；图形终端程序（如 `xterm` / `gnome-terminal` / `script`）运行在**用户态**，监听按键事件；它持有 master 端的文件描述符 `master_fd`（打开 `/dev/ptmx` 得到）；它将字符写入 `master_fd` → 数据通过内核缓冲区流向 slave

   ```bash
   用户在物理键盘上输入字符
   ⬇
   操作系统的输入设备驱动捕获按键事件
   ⬇
   图形终端程序（如 xterm / gnome-terminal / script）运行在用户态，监听按键事件
   ⬇
   它持有 master 端的文件描述符 master_fd（打开 /dev/ptmx 得到）
   ⬇
   它将字符写入 master_fd → 数据通过内核缓冲区流向 slave
   ⬇
   slave 是一个伪终端（/dev/pts/N），shell 绑定在 slave 上，从中读取数据
   ⬇
   shell 执行命令、输出结果写入 slave
   ⬇
   master 读取这些结果 → 回到终端程序 → 显示在屏幕上
   ```

1. 用户的 **按键数据**（例如字符 `'l'`, `'s'`, `'\n'`）是通过 **输入设备驱动**送入用户态程序（如 `xterm`、`script`）

   > **`pty master/slave` 对共享一个内核缓冲区** —— 它们之间通信的本质是：**master 端和 slave 端之间通过一个环形缓冲区进行数据交互**，这个缓冲区由内核管理。
   >
   > `pty master`（主端）模拟一个终端设备的控制端（通常由 ssh、tmux、xterm 等控制程序使用）
   >
   > `pty slave`（从端）模拟一个实际的终端设备（被 shell 或用户程序感知）
   >
   > 
   >
   > **缓冲区细节**
   >
   > - 内核中为每个 `pty` 对分配一个缓冲区（通常是**双向缓冲环**）
   > - 数据流方向：
   >   - **写入 master，数据出现在 slave 的读取端**（就像键盘输入）
   >   - **写入 slave，数据出现在 master 的读取端**（比如 shell 输出）
   >
   > 这个缓冲区在 Linux 内核里由 `tty` 子系统统一调度和维护。
   >
   > 情境：你运行 `script`，shell 使用伪终端 slave
   >
   > ```bash
   > script -q /dev/null
   > ```
   >
   > ```text
   > 用户键盘 ─▶ master ─▶ [内核缓冲] ─▶ slave ─▶ bash
   >                                    ▲         │
   >                                    │         ▼
   >                                script ◀──── slave 输出（bash执行结果）
   > ```
   >
   > ```ABAP
   > 用户输入命令给master，master将命令存储在内核缓冲区，bash从slave读取这个字符串，解析出命令，找到命令后，为这么命令fork子进程并执行，程序执行后将输出结果发送给slave，数据从master中读出，输出在屏幕上
   > ```

2. fork 出一个子进程，执行 `/bin/bash`
3. 子进程的标准输入、输出、错误 都指向 `/dev/pts/0`（也就是 pty slave）
4. 用户在终端中键入 `ls -l`
   - 终端程序将字符写入 **pty master**
   - 内核将这些字符缓冲在 **pty slave 的读缓冲区**
5. Shell 从 pty slave 中读取这行命令，解释执行
6. 输出通过 stdout 写入 pty slave → 内核转发给 pty master → 终端程序读取后显示





## 驱动函数是什么

所谓驱动函数，实际是内核中的一组回调函数，它们通过结构体 `file_operations` 注册给 VFS（虚拟文件系统）

```C
static const struct file_operations ptmx_fops = {
    .open = ptmx_open,
    .read = tty_read,
    .write = tty_write,
    .ioctl = tty_ioctl,
    ...
};
```

当用户态程序调用 `open("/dev/ptmx")`：

- 系统调用进入内核
- 内核根据设备节点查找到对应的 `file_operations`
- 然后调用 `.open = ptmx_open` 这个内核函数（驱动函数）



**驱动函数的“生命周期”：**

| 事件            | 用户态调用                   | 进入内核后实际调用的驱动函数 |
| --------------- | ---------------------------- | ---------------------------- |
| 打开 PTY master | `open("/dev/ptmx")`          | `ptmx_open()`                |
| 读数据          | `read(fd, ...)`              | `tty_read()`                 |
| 写数据          | `write(fd, ...)`             | `tty_write()`                |
| 设置终端属性    | `ioctl(fd, TIOCSWINSZ, ...)` | `tty_ioctl()`                |



`ptmx_open()` 驱动函数原型

```C
static int ptmx_open(struct inode *inode, struct file *filp) {
    return tty_open(inode, filp);
}
```

这个函数是 `/dev/ptmx` 设备的 open handler

是系统调用 `open()` 最终调用到的函数



**驱动函数是面向“设备操作”的最底层内核函数接口之一，它是系统调用通往硬件（或虚拟设备）的关键桥梁。**



## 分层理解 Linux 设备驱动结构：

```css
   用户态应用程序
        │
    系统调用 (open, read, write, ioctl, ...)
        │
┌───────┴────────┐
│ 虚拟文件系统（VFS） │   ← 统一管理所有设备的访问
└───────┬────────┘
        │
   file_operations
        │
┌───────┴──────────────┐
│ 驱动函数（驱动程序） │ ← 你提到的“驱动函数”就处于这一层
│  如 .open, .read      │
└───────┬──────────────┘
        │
  设备控制层（例如：串口控制、I2C控制、TTY核心层）
        │
  硬件抽象接口（I/O 映射、MMIO、端口IO）
        │
  硬件寄存器、中断线、DMA 控制器等
```







从**纯粹的代码实现角度来看 Linux 操作系统的整体结构**

| 你提到的层 | 是否准确 | 补充说明                                                     | 语言实现 |
| ---------- | -------- | ------------------------------------------------------------ | -------- |
| 用户态程序 | ✅        | 发起系统调用，触发上下文切换                                 | 高级语言 |
| 系统调用   | ✅        | 是用户态访问内核态的唯一入口                                 | C        |
| 抽象层     | ✅        | VFS、网络协议栈、进程调度器、内存管理、IPC子系统（管道，信号，共享内存）等 | C        |
| 驱动层     | ✅        | 实现硬件控制逻辑、注册接口，如字符设备驱动（`/dev/ttyS0`, `/dev/input/mouse0`）块设别驱动（NVMe、SATA、MMC），网络设备驱动（e1000e, r8169），显卡驱动（i915, amdgpu） | C        |
| 底层控制层 | ✅        | 驱动内部直接操作硬件的代码：对寄存器读写、DMA、中断响应等。  | C/汇编   |
| 物理层     | ✅        | 真正的硬件设备，不属于代码范畴，但是操作目标                 | N/A      |





**从Linux官方模块组织视角**









## Linux登录

Linux登录流程：`/etc/login.defs`、`PAM`模块、`getty` 和 `login`







# 第三天





![image-20250611113334930](D:\git_repository\cyber_security_learning\markdown_img\image-20250611113334930.png)



## 网络

什么是互联网，它的组成是什么

网络中支撑网络工作的非常重要的东西叫协议 protocol，什么是协议

网络分为3个部分，边上（edge），中间（core核心）和把边上和中间接在一起的接入网（access），

3个部门的组成，作用和基本原理

网络的边缘，将边缘接入核心的接入网以及支撑接入网的media媒介，核心，核心的工作方式有两种，一个是线路交换，一个是分组交换

什么是线路交换

什么是分组交换


实际上互联网是一堆网络构成的，他不是一个平面，一个网络，它是由一堆网络通过网络互联设备（路由器）连在一起的网络的网络，我们叫互联网

不同的网，处在整个互联网的层次也不一样，有的是level1，有的Level2，Level3...,



### 网络

网络的层次结构


之后我们介绍，网络那么复杂，不是一个平面就能够解决的，它是一层一层解决的，每一层实现一组特定的功能，上一层又借助下一次提供的服务，通过和对等层的协议实体相互交换协议的报文来实现的，实现的目的是什么呢？为了向上层提供更好的服务，然后一层落一层，一层落一层，最后落到了传输层

应用层是借助传输层提供的服务，交换应用报文，实现各种各样的网络应用，整个工作的过程大致就是这样的过程

层次性的原理是非常重要的理解计算机网络工作的核心思想，希望大家能够把握




1. 什么是网络 -> 计算机网络 -> 互联网

举几个网络的例子：电话网，蜘蛛网，蜘蛛网也是网络，所以网络有什么特点？，节点和边是吧，

 ![image-20250611095517824](D:\git_repository\cyber_security_learning\markdown_img\image-20250611095517824.png) 这两个网络是不是一种网络，所以网络是网络就是和大小无关的，节点和边的关系，和形状无关，如这个图里的节点，可以是个人，那这个边可能就是他们的朋友关系，这也可以是一个蜘蛛网的几点到另外一个节点，中间是蜘蛛线，这也是网络，又或者神经元即它的树突等，也是网络

 再拉回到蜘蛛网，蜘蛛网就是与大小，形状无关的网络的拓扑，这叫网络。那什么是计算机网络



### 计算机网络

计算机网络：计算机网络是联网的计算机，所构成的系统。我们都知道网络有节点和线构成，那么计算机网络中，节点都是什么？

包括

- **主机节点**，比如：笔记本，手机，ipad，联网的冰箱，机顶盒等等，它是数据的源，也是数据的目标

比如它是一个web服务器，算不算一个主机节点，也算一个节点。



- 另外一种是**数据交换节点**，比如交换机，路由器，它即不是数据的源，也不是数据的目标，来一个分组从一个端口进来，按照一定的工作方式，如果是**交换机**的话就是按照目标mac地址，决定从某个方向转，如果是一个**路由器**的话，来一个分组，从一个端口通过网卡收进来，收进来之后，通过查路由表，决定从另一个方向放出去，它是转发数据的，它既不是源，也不是目标。
  - 刚才我们介绍了路由器和交换机，有两个术语了，他只是层次不同，作用不同，路由器是工作在网络层，交换机工作在链路层，当然还有更高层的网络交换设别，比如还有第4层，第5层的负载均衡设备等等，这些设备有什么特点？它也是节点，但是它既不是数据的源，也不是数据的目标，它是数据的中转节点。收到数据后将它转走，到下一节点后，收到之后转走，通过这些中转节点的相互配合，最终实现从源节点到目标节点。



所以它有两种类型的节点，画方的是主机节点，画园的是数据交换节点。数据交换节点根据它工作的层次不同，可以分为，中继器，交换机（二层），路由器（三层），还有一些负载均衡设备，更高层。它的作用就是从一个地方进，从两一个地方出，通过这些中转节点的相互配合，从而实现数据从源主机到目标主机。



把节点连在一起的是什么？叫链路。把主机跟交换节点连在一起，把交换节点和交换节点连在一起，最后构成一个网，然后之间才能够相互通信，这个叫链路，就是边



所以说，连网的计算机系统，由节点和边构成的这样一个系统，我们把它叫做计算机网络



边呢也分为两类

- 第一类：我的主机通过以太网的网线，接到最近的一个交换机，所以叫接入网，接入的链路(link)
- 第二类：路由器和路由器，路由器和交换机，交换机和交换机，也就是交换节点之间的骨干链路



总结起来就是方的和园的连在一起的，主要和主机相关，它就是接入链路，如果两个圆的接在一起，就是骨干链路，因此总的分为接入链路（access）和骨干链路(backbone)



计算机网络，从构成的角度：节点和边

节点包括主机和交换节点，数据交换节点工作的层次不同有分为交换机，路由器，一些高层的负载均衡设备等等

 

链路的按照它连接的主机和路由器，还是交换节点之间链路可以分为access和backbone，就接入链路和骨干链路









#### 协议

当然除了互联网构成的这样一些零件的组成，节点和边之外的，还有另外一些构成，一些软的，比如协议。协议指的是支撑互联网工作的标准。各个厂商按照标准和协议来制作它的网络设备，这些不同的网络设备之间，就可以形成互操作，叫inter-operative。就是我这个网卡和你这个网卡，虽然来自不同的厂商，但只要按照同样的标准，就可以工作。当然，协议按照它的层次不同又可以分为物理层协议，链路层协议，网络层协议，传输层协议，应用层协议，而每层协议又分为若干种，比如传输层的TCP，UDP.网络层有IP还有一些路由选择协议。这些都是协议，也就是标准



协议的定义：对等层实体在通信过程中，应该遵循的规则的集合，包括语法，语义和时序。当然咱们不太适合这么讲，怕你们惊慌试错，落荒而逃。

听着好像很复杂，但是听后续咱们娓娓道来，其实也没那么复杂



计算机网络讲清楚了，那互联网是什么呢？



### 互联网

互联网是以TCP协议和IP协议为主的一簇协议。就协议族，协议套，有这些协议构成的那个网络，就我们目前在用的，规模最大的网络就叫互联网（internet）。





当然你说我也按这个方式工作，也是以TCP和IP协议族为主的，但是我和别人不连，我厂里自己用，也行，。这个不叫Internet，这个叫intronet，叫企业网，也叫内部网





从构成的角度来看，计算机网络，互联网，互联网当然也是计算机网络中的一种，互联网有哪些端节点，PC，主机，server，手机，ipad等等...以及一些有趣的端系统，赋予十亿计的端系统。



那么端系统包括什么呢？计算机本身—硬件，能够把硬件管理起来的操作系统，这个操作系统要支持通讯吧；然后在操作系统之上驻留的浏览器，web服务器，上面的一些app等网络应用程序。



所以整个端系统分为，硬件本身，支持网络通讯的操作系统，以及基于操作系统，在操作系统上运行的各种网络应用程序；这些构成了端系统,这个端系统我们通常称作`end System` 或者 `host`







边缘：边缘系统上面的应用是网络存在的理由，下面的设备是支撑网络通讯的协议栈

接入：将边缘的主机系统接入到网络核心

核心：把所有的边缘节点接在一起，从而让任意两个端系统之间能够相互通信，所以网络核心的作用就是数据交换



#### 网络边缘

应用进程之间的通信模式

- CS模式
- P2P模式
  

不管是CS模式，还是P2P模式，它们都要借助于基础设施提供的通讯服务才能实现相互通信。

基础设施为网络应用提供的通信服务有两种方式

- **面向连接的通信方式**
  - 例如：TCP协议实体向应用进程提供的服务就是面向连接的服务
  - 特点：分布式应用之间相互通信，首先要建立连接，底层的协议栈要为两个应用进程以后的通信准备好相应的资源，做好标记（比如准备缓冲区，标记位置位，超时定时器设置等）`两个应用进程在通信前，两者要做好准备，底层协议栈也要做好准备`。
  - 面向连接和有连接的区别
    - 面向连接是：通信双方及其底层协议栈知道，网络不知道。通讯状态只在端系统中维护
    - 有连接：不止通信双方要维持通信状态，中间节点也要维护通信状态（典型的有连接：**PSTN电话网络**，一旦建立通话，网络中每个交换节点都为这次通话分配固定资源（电路时隙））



TCP向上层提供的服务的特性：可靠的，保序的，流量控制，拥塞控制

可靠的：不重复，不失序，不乱序，不出错。总结：就是原原本本，发出的是什么，收到的就是什么。

流量控制：比如你是一个性能强大的服务器，至强。而另一端是性能很差的机器。如果你发送太快，对方无法处理，则会出现问题。流量控制就是解决这个问题的。协调发送方发送速度和接收方接收速度，从而让两者能够有效通信。

拥塞控制：网络路径有堵塞，除了要考虑接收方的数据处理能力，还要考虑到网络路径的通行能力。根据路径的阻塞程度，协调发送方的发送速度，防止数据交换节点处理不了导致丢包。





- **采用基础设施的无连接服务**
  - 例如：UDP-用户数据报协议
    - 无连接
    - 不可靠数据传输
    - 无流量控制与无拥塞控制





#### 网络核心

网络核心的组成：由交换节点与交换节点它们的链路构成的。最主要的作用是数据交换的功能，源主机发出去，正确的到达目标主机。



**分组交换**

```bat
	为了从源端系统向目的端系统发送一个报文，源将长报文划分为较小的数据块，称之为分组  （packet） 
在源和目的地之间，每个分组都通过通信链路和分组交换机（packet switch ）传送。（交换机主要有两类：路由器（router）和链路层交换机（link-layer* switch）。）分组以等于该链路最大传输速率的速度传输通过通信链路。  —— 《计算机网络—自顶向下》
```



![image-20250612115408514](D:\git_repository\cyber_security_learning\markdown_img\image-20250612115408514.png)

以分组为单位存储-转发方式

- 网络带宽资源不再分为一个个片，传输时使用全部带宽
- 主机之间传输的数据被分为一个个分组



**什么是分组**

分组交换是一种通信方式，数据在发送前被**分割成较小的单元（分组）**，逐个传输。

这些分组具有以下特征：

- 独立路由（可能走不同路径）
- 独立封装
- 每个分组包含完整的目标地址信息



**存储转发**

![image-20250612143716393](D:\git_repository\cyber_security_learning\markdown_img\image-20250612143716393.png)

存储转发传输是指在交换机能够开始向输岀链路传输该分组的第一个比特之前，必须接收到整个分组。

> 存储转发，为链路共享提供了基础。





**丢包**

路由器中的排队队列所容纳的分组是有限的，所以等到路由器队列堆满后，新到达的分组就无法被容纳，导致路由器 `丢弃(drop)` 该分组，即分组会 `丢失(lost)`。











### Internet结构和ISP

前面我们介绍了互联网可以分为节点和链路，然后我们将主机系统构成了边缘系统，由网络交换节点之间构成的子系统，叫网络核心，将边缘接入网络核心，我们叫接入access，这是一种划分方式



还有一种划分方式：我们把关系比较密集的，一个网络供应商的网络作为一个网络。比如：高校的校园网，这里有交换设备，有链路，有主机。这构成一个子系统，这个子系统叫一个ISP网络。当然还有其他ISP的网络。互联网就是由这些ISP的网络通过网络互联设备，比如路由器来构建成的。



之前的划分是按照网络节点和链路的分类，分为了边缘，接入，核心

现在，我们按照一个范围内，关系密集的一个网络中的设备，称之为一个ISP网络，互联网是有很多ISP的网络构成的，当然ISP里还包括很多小ISP。所以我们可以说互联网是由一堆ISP网络构成的，通过网络互联设备，通过路由器连在一起的，是网络的网络。



我们使用渐进演化的方法，来描述互联网当今的结构。



我们很多的端系统，都是通过接入ISP访问的互联网。比如移动手机，是通过移动ISP接入互联网。任何一个端系统都是通过接入ISP来接入互联网的。比如我们家用的主机，通常是不会移动的，但是移动接入是什么呢？你拿着一个手机，在很多有联通基站的地方都能把你接入。不管怎样你是通过移动，联通基站接入互联网。有很多很多的接入ISP，有多少？几十万，上百万接入ISP，接入ISP之间要不要互联。



我通过接入ISP接入互联网，他通过另一个接入ISP接入互联网。如果接入ISP之间不能互联，是不是我和他之间的访问就会有问题。



因此这些接入ISP都要互联的。但是这些接入ISP是怎样互联的。

我们来看一下，发展和演化是通过一些经济的和政治策略来驱动它演化到当前的情况。我们看下它是如何演化的。



用户是通过接入ISP来访问互联网。这些接入ISP要相互互联，问题是他们怎么互联。

有一种方式，把它们全连接可以吗？当然不可以，想象一下，如果我们有N个ISP，那么全连接就是n(n-1)/2，基本上是n的平方的级别。如果有10w个ISP，全连接就是10w的平方，这个是不可相信的，代价太大了。这种方式是不可扩展的。



那怎么办呢？对于ISP来说，你接入互联网是不是要给ISP付费，所以这里是不是有利可图的。那就意味着有些供应商会把全球的这些接入ISP都连在一起，在全球范围内，部署自己的路由器和线路，把这些路由器和设备都连在一起。然后这个全球的ISP会把接入ISP都连在一起，也就是这些接入ISP，都连在这个GLOBAL ISP上。这样的话，接入ISP之间的通信，就可以借助于GLOBAL ISP连在一起。



有利可图，比如有人会投资，这就是经济驱动的必然。



我们把很多接入ISP连在一起，在他们之间完成数据的收发，那么我在全球部署我的这些节点，也是技术上可行的，在经济上也是有收益的。那一定有GLOBAL ISP去做这个事情，



你的access net是通过一些经济合约和GLOBAL ISP谈好，比如流量上行下行是多少，怎么结算，是包月还是按量付费等等。因此access net和GLOBAL ISP之间通常有合约，来约束它们的行为。



但是如果只有一个GLOBAL ISP，那服务质量必然不会高，但是价格一定很高。这时候必然会有一些其他ISP参与到这个竞争。



因此就有多个GLOBAL ISP，把一些接入ISP接入进来。不同的接入ISP，接入不同的GLOBAL ISP。



另一方面，除了有竞争还有合作，比如我接如刀这些access net，你接入那些access net。我要把你的客户接进来，代价是很高的。这时我有一个选择，我通过你接入你的客户，你通过我接入我的客户，这样的话。我对我的新客户而言，我说我可以接入所有的access net，你也可以和你的用户说，你可以接入所有access net。

那这样就有一个合作的概念。合作可能涉及到结算。也可能不涉及流量的结算。我们是对等的，如果大家接入的各自的access net差不多，发过去的和回来的流量差不多，那就不用付费了，对冲了。对于运营商而言，我不用花钱，和你谈个合约，出一个条路由器，出个链路，就能和你相连，从而扩展我业务的物理范围。



这样，既有竞争也有合作。这种连接叫做对等的连接。



还有一种连接是大家都接入到IXP，也就是互联网连接交换点，在这些交换点之间，完成a到b，b到c，c到a的数据交换。



这个交换点当然非常重要，很多骨干的ISP，它的流量都通过IXP的交换点，完成网间流量的交换。



当然业务还有个细分的问题。ISPA是完成全球范围内的access net接入，当然也有一些小的运营商，可以做精细化的服务，可以在一个国家或者几个大州之间，我有我的势力范围，我可以做精细化的服务，我可以部署很多路由器，链路从而把更多的用户接进来。所以就有业务细分。



global ISP 完成全球方位内的交换，而Reginal，要完成区域范围内，把这些access net接进来，它们之间进行数据交换，如果要访问互联网其他地方的，再通过global ISP完成全球范围的交换。



现在情况更加复杂，互联网有很多角色，端系统有用户，还有服务提供商ISP，还有ICP就互联网内容提供商，比如google，baidu等。提供上层业务的。



像Google这样的ICP，有十几亿用户提供服务的ICP，这些内容提供商当然也需要通过ISP接入互联网。但是我作为内容提供商，接入互联网，是不是也需要向ISP付费，而且付费还很高。对于Google来说，如果付费非常高。而且服务质量也没办法保证。比如我是美洲的ISP，然后南非的用户访问我，这个距离就很远，中间要经过很多数据交换设备。就很麻烦。怎么办呢。


像Google这样的内容提供商就会在全球各地布置数据中心机房。我通过我自己部署的专网，或者租用线缆。把这些数据中心机房连在一起。而且这些数据中心通常布置在离ISP的数据中心机房比较近的地方。这样用户通过ISP接进来，很快就能接入google的数据中心机房。然后返回去，这样体验就很好。而且因为在很多链路上，我用的自己的专网，因此向ISP支付的费用就会很少。



所以一个成本原因，一个用户体验的原因，促使Google部署自己的数据中心机房。



通常来说全球范围内的覆盖点会少一些，因为成本太高，点和点之间，带宽会很宽。因为付了那么大代价，使用海底电缆连接洛杉矶到上海。带宽搞一个1k，那不是有病吗、自己用不了还可以租出去嘛……



像















### 协议层次和服务模型



#### 模块化分层思路

我们首先要承认一点：网络是一个非常复杂的系统。有各种各样的终端设备，各种各样的链路，各种各样的应用。那么作为一个科学家或者工程师实体，如何设计和实现组织复杂的网络功能？



解决这个问题的思路：模块化的思路。



什么是模块化的思路呢？就是把一个复杂的功能，分解成一个个模块，模块之间相互调用，而且平面性的调用，任何一个模块都可以调用任何模块提供的功能和服务，这样就可以一个比较复杂的功能通过模块化的分解来进行实现。

![image-20250613100710715](D:\git_repository\cyber_security_learning\markdown_img\image-20250613100710715.png)



其中一个模块化的分解思路就是分层的方法来解决。

将一个复杂的功能分为一个个模块，模块之间的调用和被调用关系是**从仅相邻**的两层的模块之间能够调用和被调用，他不允许或者说不推荐跨层调用。

而**计算机网络实现**这种复杂的问题，就是采用分层的模块化的方式来解决，设计和实现的。将功能非常复杂的计算机网络的功能分解为一个个功能明确的子模块，每一层实现一个或一组功能。每一层的功能通过层间的接口，向上层提供服务。像这样一层落一层，一次落一层，最后实现比较复杂的计算机网络的功能









#### 异地哲学家交流哲学思想

计算机网络使用分层的方式如何解决比较复杂的计算机网络的功能实现，可以通过生活中的例子（异地哲学家使用不同语言进行哲学思想交流的复杂问题），来方便大家的理解

![image-20250613094506502](D:\git_repository\cyber_security_learning\markdown_img\image-20250613094506502.png)

 

- 最下面是秘书层：解决的是异地通讯的问题。（协议：约定通信的方式）
- 第二层是翻译层：解决的是表示转换的问题。将两位哲学家不同的语言转换为共用的语言进行交流（协议：约定共用的语言）
- 最上面是哲学家层：两个哲学家交换哲学思想，从而完成深层次的学术交流



通过上述过程类比：两个应用进程通过交换应用报文来实现各种各样的网络应用。包括：电子商务，域名解析，文件下载等。



上述分层解决问题的优势：

- 把一个复杂的问题转换成3个子问题，每个问题的解决相对独立，单一。
- 每一层独立进行技术更新，不会影响其他层。



层次化方式实现复杂网络功能：

- 将网络复杂的功能分层功能明确的层次，每一层实现了其中一个或一组功能，功能中有其上层可以使用的功能：**服务**（本层功能的子集，能够为上层提供服务的部分）
- 本层协议（每一层交互应该遵守的规则的集合）实体相互交互执行本层的协议动作，目的是实现本层的功能，通过接口**为上层提供更好的服务**
- 本层的服务：借助下层服务实现的本层协议实体之间交互带来的新功能（上层可以里利用）+更新层提供的服务。





#### 协议和服务的关系

协议的目的：为上层提供更好的服务

协议的实现：通过层间的接口，借助于下层提供的服务，交换对等层相应的PDU，从而实现新的协议动作，目的是为上层提供更好的服务

```bat
每一层向上层提供的服务，包括了所有下层提供服务的总和，加上和对等层实体交互过程中形成的新的服务特性，通过层间接口向上层提供更好的服务
```







#### 互联网中的分层结构 — TCP/IP协议栈

![image-20250613141157388](D:\git_repository\cyber_security_learning\markdown_img\image-20250613141157388.png)



**各层的作用**

- **应用程：**网络应用

  > 为人类用户或者其他应用进程提供网络应用服务
  >
  > FTP，SMTP，HTTP，DNS

- **传输层：**主机之间的数据传输

  > 在网络层提供的端到端通信基础上，1. 细分为进程到进程，2. 将网络层不可靠的通信变成可靠地通信

- **网络层：**为数据报（Package）从源到目的选择路由

  > 主机主机之间的通信，端到端通信，不可靠
  >
  > IP，路由协议

- **数据链路层：**相邻网络节点间的数据传输

  > **数据链路层的主要作用**是：以**帧（Frame）为单位在相邻节点之间可靠传输数据。 它负责将来自物理层的连续比特流（bit stream）划分为有界的帧，识别出每一帧的\**起始和结束位置**，从而实现对数据的组织和管理。
  >
  > 点对对协议PPP，802.11(wifi)，Ethernet

- **物理层：**在线路上传递bit（提供相邻两点，将数字信号和物理信号之间的相互转换）

  > 发送端：上层传下来的帧，变为物理信号，在介质中转播给对端。
  >
  > 接收端：将媒体中承载的电磁波或者光信号还原回数字信号。





#### ISO/OSI 参考模型



- **表示层**：允许应用解释传输的数据。eg：加密，压缩，及其相关的转换
- **会话层：**数据交换的同步，检查点，恢复。



互联网协议栈没有这两层！这些服务，如果需要的话，必须被**应用实现**。





#### 服务和服务访问点

- **服务（Service）：**低层实现向上层实体提供它们之间的通信能力
  - 服务用户（Service User）
  - 服务提供者（Service Provider）



- **原语（Primitive）：**上层使用下层服务的形式，高层使用底层提供的服务，以及低层向高层提供服务都是通过服务访问原语来进行交互的 --- 形式

  > 比如：传输层向应用程提供服务的形式是Socket，上层向下层发送SDU时，进行标注。在对等端，下层向上层根据标注信息选择对应的应用接收数据



- **服务访问点SAP（Service Access Point）：**上层使用下层提供的服务通过层间的接口—地点：
  - 下层的一个实体支撑着上层的多个实体，SAP有标志不同上层实体的作用。
  - 例子：传输层的SAP，端口（Port）

![image-20250613113513040](D:\git_repository\cyber_security_learning\markdown_img\image-20250613113513040.png)



#### 封装和解封装

 

​                                          ![image-20250613145928480](D:\git_repository\cyber_security_learning\markdown_img\image-20250613145928480.png)





从源主机到目标主机发送的报文，逻辑上来看，是应用进程**直接**向对端的应用进程发送报文，但这个直接是要打上引号的。是逻辑上通信的。看似好像是客户端浏览器直接发给web服务端请求报文，web服务端向客户端返回响应报文。好像是客户端和服务端直接通信，但是实际上message是不可以直接传送给目标的应用进程的。

实际上是通过层间的接口，借助于下层提供的服务来实现的。

也就是源主机的应用层将message发送给下层的传输层，传输层在SDU基础上，加上本层的控制信息头，生成本层的PDU。在传输层叫做报文段segment。

报文段也无法直接传输给对端的传输层实体。因此要通过层间的接口借助于下层的网络层的服务实现。所以要将数据发送网络层，网络层收到报文后，加上本层的头部控制信息（源IP，目标IP等数据），生成本层的PDU，也就是分组（Package）。

> 头部信息是上层传下来的ICI，通过解析转换生成本层的头部控制信息

网络层也可能无法直接传输给对端的网络层实体，因此要通过层间的接口借助于下层的数据链路层的服务实现。所以还要将数据发送给链路层，在链路层收到报文后，加上本层的头部信息（源MAC地址，目标MAC地址），生成本层的PDU，也就是分组（帧）。

物理层收到链路层传下的数据后，将数字信号转换为电信号或者光信号，从而通过媒体介质，将数据发送给对端。

 











## 更改网卡名 — 配置启动项

Rocky9以上，默认使用功能BLS（Boot Loader Specification）配置方式，不会使用 `/etc/default/grub` 中的 `GRUB_CMDLINE_LINUX` 参数。



### 什么是BLS

**BLS 是一套标准**，由系统引导程序（如 GRUB）使用，用来 **管理每个内核启动项的配置**，以 **文件形式**存储在 `/boot/loader/entries/` 目录下，每一个启动项都是一个单独的 `.conf` 文件。

> ✅ 本质上：
>  BLS 是 Linux 新的“启动配置方式”，目的是 **更模块化、易于自动管理和升级内核启动项**。



### BLS 与传统 grub.cfg 有什么区别？

| 特性               | 传统 grub.cfg                          | BLS 模式                                      |
| ------------------ | -------------------------------------- | --------------------------------------------- |
| 启动项配置存储位置 | `/boot/grub2/grub.cfg`                 | `/boot/loader/entries/*.conf`                 |
| 管理方式           | 全部内核版本共享一个 grub.cfg          | 每个内核版本都有独立启动项配置文件            |
| 参数设置方式       | `/etc/default/grub` + `grub2-mkconfig` | `.conf` 文件直接写入 `options=...` 行         |
| 优势               | 灵活但容易乱                           | 模块化、适合自动更新（如 dnf install kernel） |
| 是否使用 BLS       | `GRUB_ENABLE_BLSCFG=true` 时启用       | 否时用传统 grub.cfg                           |



### 一个典型的 BLS 启动项文件（示例）

路径：`/boot/loader/entries/rocky-5.14.0-427.el9.x86_64.conf`

```ini
title Rocky Linux (5.14.0-427.el9.x86_64) 9.4
version 5.14.0-427.el9.x86_64
linux /vmlinuz-5.14.0-427.el9.x86_64
initrd /initramfs-5.14.0-427.el9.x86_64.img
options root=/dev/mapper/rl-root ro crashkernel=auto net.ifnames=0 biosdevname=0 quiet
```

- `title`：显示在引导菜单中的名称
- `linux`：内核镜像路径
- `initrd`：内核初始文件系统
- `options`：内核启动参数 ← 就是你要加 `net.ifnames=0 biosdevname=0` 的地方！





### BLS相关操作

#### 检查是否启用 BLS 模式

```bash
cat /etc/default/grub | grep GRUB_ENABLE_BLSCFG
```

为 `true` 表示启用了 BLS



#### 临时修改内核参数（不建议）

编辑当前默认内核的启动项：

```bash
vim /boot/loader/entries/xxx.conf
```

在 `options=` 行尾加上你的参数



#### 永久关闭 BLS

```bash
sed -i 's/GRUB_ENABLE_BLSCFG=true/GRUB_ENABLE_BLSCFG=false/' /etc/default/grub
grub2-mkconfig -o /boot/grub2/grub.cfg
```





#### 确认当前内核参数是否生效

```bash
# 查看/proc/cmdline
[root@localhost ~]# cat /proc/cmdline 
BOOT_IMAGE=/vmlinuz-5.14.0-427.13.1.el9_4.x86_64 root=/dev/mapper/rl-root ro crashkernel=1G-4G:192M,4G-64G:256M,64G-:512M resume=/dev/mapper/rl-swap rd.lvm.lv=rl/root rd.lvm.lv=rl/swap rhgb quiet net.ifnames=0 biosdevname=0
```



## 配置静态IP — 配置网络服务



### Rocky

**兼容性说明：**

| 系统版本      | 默认方式                         | 是否兼容 ifcfg-* | 建议           |
| ------------- | -------------------------------- | ---------------- | -------------- |
| CentOS 7      | NetworkManager + network-scripts | ✅                | 可继续使用脚本 |
| Rocky 8       | NetworkManager + 脚本兼容模式    | ✅                | 逐步过渡       |
| Rocky 9/RHEL9 | NetworkManager + `.nmconnection` | ⚠️（部分兼容）    | 推荐全面迁移   |



**NetworkManager静态IP的`.nmconnection`文件配置**

```bash
[connection]
id=eth0
uuid=xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx   # uuidgen生成，作为网卡唯一标识
type=ethernet
interface-name=eth0
autoconnect=true

[ethernet]
mac-address-blacklist=

[ipv4]
method=manual
address1=192.168.1.100/24,192.168.1.1        # 配置静态IP和网关
dns=8.8.8.8;114.114.114.114;
dns-search=
may-fail=false

[ipv6]
method=ignore             # 禁用ipv6
```

```bash
nmcli conn reload
nmcli conn up eth0   # 启用配置
```



- NetworkManager客户端工具 — nmcli（功能强大，可以通过客户端工具修改网络配置）



### Ubuntu

- **Netplan 是 Ubuntu 的统一网络配置前端**

- 用户只需要编写 **YAML 文件**（位置：`/etc/netplan/*.yaml`）

- 然后运行：

```bash
sudo netplan apply
```

- Netplan 会根据 YAML 中指定的 `renderer` 字段：

  - 如果是 `NetworkManager`：
    - 就把配置“传递”给 NetworkManager（通过 D-Bus，**不会生成 .nmconnection 文件**）

  - 如果是 `systemd-networkd`：
    - 就自动生成 `.network` 文件，放在 `/run/systemd/network/` 下（**不是 /etc/systemd/network/**）



- Netplan 本身 **不负责管理网卡**，它只是 **翻译器**，真正负责管理的是：
  - `systemd-networkd`（轻量）
  - `NetworkManager`（功能多，如 Wi-Fi、VPN）





#### NetworkManager

Netplan会把配置“传递”给 NetworkManager（通过 D-Bus（一种IPC通信机制），**不会生成 .nmconnection 文件**）



#### systemd-networkd

由netplan自动生成

```bash
/run/systemd/network/10-netplan-eth0.network
```



- systemd-network的客户端工具 — networkctl（只读）
  - `systemd-networkd` 的配置是通过编写配置文件完成的：
  - 配置路径：`/etc/systemd/network`
    - `*.netdev`：定义虚拟设备（如 bridge, bond, vlan）
    - `*.network`：定义网络接口配置（IP地址、路由、DNS等）
    - `*.link`：定义接口命名和属性（MAC 地址策略等）









## HTTP协议

### HTTP协议介绍

HTTP：（HyperText Transfer Protocol）超文本传输协议

HTTP 是一个工作在应用层的通信协议，它允许将超文本标记语言（HTML）文档从 WEB 服务器传送到 客户端的浏览器





### HTTP 协议版本和发展历史









### Cookie 与 Session



#### Cookie的格式与约束

Cookie是前端编程中经常使用的概念。 我们可以使用cookie利用浏览器帮助我们存放用户的相关状态信息，保存用户已经做了哪些事情。

- Cookie的工作原理是什么？

- Cookie的限制又是什么？

- Session是服务器端所维护的会话状态，Session又怎样与Cookie关联起来？ 





##### Cookie是什么？

![image-20250618091730167](D:\git_repository\cyber_security_learning\markdown_img\image-20250618091730167.png)



**RFC6265，HTTP State Management Mechanism**



Cookie保持在客户端，由浏览器维护（但是是由服务端生成的），表示应用状态的HTTP头部

- 存放在内存或者磁盘中
- 服务器端生成Cookie在响应中通过Set-Cookie头部告知客户端（允许多个Set-Cookie头部传递多个值）
- 客户端得到Cookie后，后续请求都会自动将Cookie头部携带至请求中





##### Cookie 与 Set-Cookie头部的定义

Cookie 头部中可以存放多个 **name/value** 名值对

```haskell
cookie-header = "Cookie:" OWS cookie-string OWS
  cookie-string = cookie-pai r*( ";" SP cookie-pair )
  cookie-pair = cookie-name "=" cookie-value
```



Set-Cookie头部一次只能传递1个 **name/value** 名值对，响应中可以含多个头部

```haskell
set-cookie-header = "Set-Cookie:" SP set-cookie-string
  set-cookie-string = cookie-pair *( ";" SP cookie-av )
  cookie-pair = cookie-name "=" cookie-value
  cookie-av: 描述 cookie-pair 的可选属性
```



浏览器查看Set-Cookie

![image-20250618093022285](D:\git_repository\cyber_security_learning\markdown_img\image-20250618093022285.png)



##### Set-Cookie 中描述cookie-pair的属性

![image-20250618093427872](D:\git_repository\cyber_security_learning\markdown_img\image-20250618093427872.png)



##### Cookie 使用的限制

RFC规范对浏览器使用Cookie的要求

- 每条Cookie的长度（包括 name, value 以及描述的属性等总长度）至少要支持达到 4KB
- 每个域名下至少支持50 个 Cookie
- 至少要支持 3000 个 Cookie



代理服务器传递Cookie时会有限制（Nginx默认32k）



##### Cookie 在协议设计上的问题

- Cookie会被附加在每个HTTP请求中，所以无形中增加了流量
- 由于在HTTP请求中的 Cookie 是明文传递的，所以安全性成问题（除非用HTTPS）
- Cookie的大小不应超过4KB，因为对于复杂的存储需求来说是不够用的。





#### Session 及第三方Cookie的工作原理

##### 登录场景下 Cookie与Session的常见用法

![image-20250618094437692](D:\git_repository\cyber_security_learning\markdown_img\image-20250618094437692.png)

- 首先登录请求发起一个POST表单的login操作。
- 服务器收到请求后，从表单中读取用户名和密码，和持久化数据中的数据进行比对，比对通过后，把登录状态生成session（这个session是有时效的）。
- 将有时效的session数据写入内存数据库
- 将session中的session_ID在响应中返回给浏览器，SESSIOIN返回的方式是Set-Cookie
- 浏览器在它的Storage中保存收到的Cookie
- 浏览器发起的后续请求会携带这个Cookie信息
- 服务器收到携带Cookie的信息后，会在后端解析Cookie携带的Session_ID，判断该用户是否是登录的，如果判断成功，则执行该用户的相关业务，并将结果返回给用户。

| 步骤                                    | 建议或补充                                                   |
| --------------------------------------- | ------------------------------------------------------------ |
| 1. 用户发送 POST /login 请求            | 可以带表单或 JSON 格式登录信息                               |
| 2. 服务端读取用户名密码，与持久化库比对 | 实际上可使用数据库或认证中心（如 LDAP）                      |
| 3. 验证通过，生成 session（含有效期）   | 通常 `session = { user_id, expires_at, ... }`                |
| 4. 将 session 存入“内存数据库”          | 通常是 Redis，或者内存 hashmap（如 Java `HttpSession`）      |
| 5. 返回 Set-Cookie，设置 `session_id`   | 示例：`Set-Cookie: session=abc123; Path=/; HttpOnly; Secure` |
| 6. 浏览器接收并保存 Cookie              | 浏览器自动保存，并根据 Path/Domain 控制何时发送              |
| 7. 后续请求自动带上 Cookie              | 浏览器自动加上 `Cookie: session=abc123`                      |
| 8. 服务端读取 Cookie 并验证 session     | 查 Redis 判断 session 是否存在、是否过期                     |
| 9. 执行业务并返回结果                   | 此时说明用户已认证，按权限执行对应业务                       |











## Web站点环境部署



### 常见Web服务介绍











# 第四天

## 文件系统

**文件内部的数据应该怎样组织起来**

无结构文件（如文本文件）- 由一些二进制或字符流组成，又称为“流式文件”

有结构文件（如数据库表）- 由一组相似的记录组成，又称为“记录式文件”

- 其中记录是一组相关数据项(field)的集合，数据项是文件系统的基本单位
- 记录间具有相似性
- 数据项是文件系统最基本的数据单位
- 目录其实是一种特殊的有结构文件（由记录组成 ）

### 目录

目录就是一种特殊的文件，其内容是一个个“目录项记录”（directory entries）组成的结构数组，用于表示“文件名 → inode号”的映射关系。



#### 目录项（directory entry）的基本组成

以 **ext2/ext3/ext4 文件系统**为例，每个目录项（`struct ext4_dir_entry`）一般包含以下字段：

| 字段名      | 说明                               |
| ----------- | ---------------------------------- |
| `inode`     | 对应文件的 inode 编号（`inum`）    |
| `rec_len`   | 当前目录项占用的总字节数（含填充） |
| `name_len`  | 文件名的长度                       |
| `file_type` | 文件类型（如普通文件/目录/链接）   |
| `name`      | 文件名字符串（不含结束符 `\\0`）   |



#### 示例结构体（ext4）

```C
struct ext4_dir_entry {
    __le32 inode;        // 4 bytes
    __le16 rec_len;      // 2 bytes：当前目录项总长度
    __u8   name_len;     // 1 byte：文件名长度
    __u8   file_type;    // 1 byte：文件类型（ext4 专有）
    char   name[];       // 不定长：文件名（不含 '\\0' 结尾）
};
```

 **字段解析说明：**

1. **`inode`（inum）**

- 表示该文件/目录对应的 inode 编号
- 操作系统可用它访问该文件的具体元信息

2. **`rec_len`（record length）**

- 当前目录项在目录文件中实际占据的总字节数
- 由于文件名长度可变，为了保持对齐，rec_len 通常会 > 实际所需空间（内含填充）

3. **`name_len`**

- 实际文件名的长度，单位是字节
- 不包括 `\\0` 结尾字符

4. **`file_type`（ext4 专有，ext2/3 不一定有）**

- 表示该目录项是普通文件、目录、符号链接等
- 类型代码例如：
  - `1`：普通文件
  - `2`：目录
  - `7`：socket（Unix 域）

5. **`name[]`**

- 字符串形式的文件名
- 紧跟在结构体后面，**变长字段**



#### 示例：目录结构中的记录内容（假设是 ext4）

一个目录文件内容示例（十六进制）可解析出如下内容：

| inode | rec_len | name_len | file_type | name  |
| ----- | ------- | -------- | --------- | ----- |
| 12    | 12      | 1        | 2         | .     |
| 2     | 12      | 2        | 2         | ..    |
| 1002  | 24      | 5        | 1         | readm |

👉 说明：

- `.` 表示当前目录
- `..` 表示上级目录
- `readm` 是普通文件（实际是 `readme`，因对齐可能被截断显示）



#### 如何手动用 `hexdump` 分析 ext4 的目录结构

**整体流程概览**

1. 找到目标目录对应的 inode（使用 `debugfs`）
2. 获取该 inode 指向的数据块地址
3. 从设备中提取对应数据块内容
4. 用 `hexdump` 查看，并手动解析目录项结构



##### 实验步骤详解

> 假设我们的挂载设备是 `/dev/vda1`，挂载点为 `/`，要分析的目录为 `/home`

**第 1 步：进入 debugfs 查看目标目录 inode 信息**

```bash
debugfs /dev/vda1
```

进入交互后：

```bash
debugfs: stat /home
```

```bash
Inode: 1518   Type: directory    Mode:  0755   Flags: 0x80000
Generation: 2375206807    Version: 0x00000000:00000002
User:     0   Group:     0   Project:     0   Size: 4096
File ACL: 0
Links: 3   Blockcount: 8
Fragment:  Address: 0    Number: 0    Size: 0
 ctime: 0x64be8b93:0a7d8c00 -- Mon Jul 24 14:32:51 2023
 atime: 0x683ca913:e6065518 -- Sun Jun  1 19:25:07 2025
 mtime: 0x64be8b93:0a7d8c00 -- Mon Jul 24 14:32:51 2023
crtime: 0x64ae0bd7:e5c38f74 -- Wed Jul 12 02:11:35 2023
Size of extra inode fields: 32
Inode checksum: 0xeeec52cf
EXTENTS:
(0):16735
```

**详细解释：**

📌 `EXTENTS:` 是 ext4 文件系统的块寻址方式之一

- ext2/ext3 使用「直接块 + 间接块」方式（最多 15 个指针）
- ext4 默认使用 **Extent tree（扩展树）**，更适合大文件、高连续性

📌 `(0):16735` 的含义是：

- `0` 表示这是第 0 个 extent（起始偏移块号为 0）
- `16735` 是该 extent 在物理设备中的第一个实际 **物理块号**



**第 2 步：根据上文的输出，可以得到如下信息**

```ABAP
这是一个 ext4 文件系统
该 inode 使用 Extent（扩展块映射）格式
第一个数据块号是 16735

字节偏移 = 16735 × 4096 = 68575232 字节
```



**第 3 步：从设备中提取这个数据块**

```bash
dd if=/dev/vda1 bs=4096 skip=16735 count=1 of=dirblock.bin
```



**第 4 步：使用 hexdump 分析目录块内容**

```bash
hexdump -C dirblock.bin | less
```

```bash
00000000  ee 05 00 00 0c 00 01 02  2e 00 00 00 02 00 00 00  |................|
00000010  0c 00 02 02 2e 2e 00 00  01 f0 03 00 dc 0f 06 02  |................|
00000020  75 62 75 6e 74 75 00 00  00 00 00 00 00 00 00 00  |ubuntu..........|
00000030  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
*
00000ff0  00 00 00 00 00 00 00 00  0c 00 00 de 14 63 1c 37  |.............c.7|
00001000
```



##### 手动解析规则（基于 `ext4_dir_entry`）

每个目录项格式如下：

| 字节偏移 | 字段名    | 长度   | 含义                             |
| -------- | --------- | ------ | -------------------------------- |
| 0        | inode     | 4B     | 文件/目录的 inode 编号           |
| 4        | rec_len   | 2B     | 当前目录项占用的总长度           |
| 6        | name_len  | 1B     | 文件名长度（不含结尾）           |
| 7        | file_type | 1B     | 文件类型（1: 普通文件, 2: 目录） |
| 8        | name      | N 字节 | 文件名（变长）                   |



**示例解析**

```bash
 01 f0 03 00 dc 0f 06 02  # 
 75 62 75 6e 74 75        # Ubuntu(文件名)
```

逐项解释：

- `01 f0 03 00` → `inode = 0x0003f001 = 258,049`
- `dc 0f` → `rec_len = 0x0fdc = 4060`
- `06` → name_len = 6（Ubuntu，6个字符）
- `02` → file_type = 2 （目录）
- `2e` → 文件名 = "."（ASCII）

```bash
[root@devops-custom ~]# ll -i /home
总计 12
  1518 drwxr-xr-x  3 root   root   4096  7月 24  2023 ./
     2 drwxr-xr-x 19 root   root   4096  5月 26 08:53 ../
258049 drwxr-x--- 17 ubuntu ubuntu 4096  5月  4 12:53 ubuntu/
```



### 什么是 Extents？

#### 使用者：ext4、xfs、btrfs 等现代文件系统

✅ 定义：

> **Extent 是一个结构：表示“某个逻辑块范围 → 对应的物理块范围”映射。**
>  简化存储：**不存储每个块地址，而是存一段连续块的起始地址和长度。**



Extent 结构（简化示意）

```C
struct ext4_extent {
  __le32 ee_block;      // 文件中的起始逻辑块号
  __le16 ee_len;        // 连续块数量
  __le16 ee_start_hi;   // 起始物理块高16位
  __le32 ee_start_lo;   // 起始物理块低32位
};
```

一个 extent 就表示：

> “从文件的第 N 个块开始，有 X 个连续块，在磁盘上的起始物理块号是 Y。”



**举例：**

如果一个文件的前 1 MB 是连续的，它只需要一个 extent：

```C
(逻辑块)0 → 255  → (物理块) 5000 → 5255
```

只需一条记录，而旧式间接块需要写 256 个指针！



#### Extents 与 间接索引块的区别总结

| 对比项           | Extents                      | 间接块索引               |
| ---------------- | ---------------------------- | ------------------------ |
| 使用者           | ext4（默认）、xfs、btrfs     | ext2、ext3               |
| 数据结构         | `逻辑起点 + 长度 + 物理起点` | 一个个指针数组           |
| 访问效率         | ✅ 高，查一次就是一段         | ❌ 查多次，指针跳转多     |
| 对连续文件的效率 | ✅ 非常高                     | ❌ 效率低，浪费空间       |
| 空间使用         | ✅ 紧凑，仅需少量元数据       | ❌ 多级指针占用大量索引块 |
| 文件碎片处理     | ✅ 减少碎片                   | ❌ 容易产生碎片           |
| 支持最大文件大小 | 更大（支持 extent tree）     | 较小，受限于指针层数     |
| 元数据维护复杂度 | 较复杂（树结构）             | 简单（线性结构）         |



#### 四、Extent Tree（扩展树）

当一个文件包含多个 extent（不连续块）时，ext4 会将这些 extents 组织为一棵 B+ 树：

- inode 中存的是 **Extent root**
- 每个中间节点称为 `index node`
- 叶子节点是 extent entry
- 所以读取文件时：先查根 → 中间 → 叶 → 数据块

📌 就像 ext3 的三级间接块，但使用的是 **B+ 树结构，更灵活、效率高**



#### 五、你在 debugfs 看到的 `(0):16735` 是什么意思？

```C
EXTENTS:
(0):16735
```

表示：

- 这是 extent 树中的第 0 个叶节点
- 它起始于文件逻辑块号 0，对应的磁盘物理块号为 16735
- 它还包含多少个连续块？你可以通过 `debugfs` 的 `stat` 看 `Blockcount`

> **间接块索引是“一个块一个指针”，而 Extent 是“一条记录映射一整段块”。**
>  Ext4 使用 Extent 是为了更快、更节省、更适合大文件，是现代文件系统演进的重要标志。









### 操作系统中通过文件访问数据的过程(简单版)

**实际流程如下：**

1. **inode → 块号（磁盘块号）**
2. **文件系统层将块号 → 逻辑扇区号**
3. **I/O调度层转化为物理设备的扇区访问请求**
4. **硬盘控制器（如SATA/NVMe）收到请求 → 访问磁盘**

```css
[ inode ]
   |
   |—> 直接块 → [ 物理块地址(逻辑块号) ]
   |
   |—> 间接块 → [ 块号数组 ] → [ 多个物理块地址 ]
                         ↓
                文件系统计算偏移（物理块号->逻辑扇区）
                         ↓
              设备驱动换算为扇区地址（逻辑扇区-> 物理扇区）
                         ↓
            硬盘控制器读取磁盘扇区的数据
```

```ABAP
文件通过 inode 中的映射结构（如 extents 或块指针），将连续的逻辑块号映射为不连续的磁盘块号。文件系统根据磁盘块号计算出对应的逻辑扇区号，由内核块设备驱动发出 I/O 请求，再由硬盘控制器（如 SATA、NVMe）将逻辑扇区转换为实际物理扇区或 Flash 页面，最后访问磁盘完成数据读取。
```





### 访问一个文件时的完整过程（以 ext4 为例）

#### 1. **路径解析 → 找到目标文件的 inode**

- **从根目录 `/` 开始**，逐层解析路径：

  ```bash
  /home/zhangyifeng/secret.txt
  ```

- 每一层目录项（如 `home`）是一个**目录文件**，其内容是若干个目录项记录（含子文件/目录的 inode 编号 + 名字）。

- 系统会：

  - 打开 `/` 对应的 inode，读取其数据块（含目录项）
  - 找到名为 `home` 的目录项，提取其 inode 编号
  - 打开 `home` 的 inode，重复上述操作，直到 `secret.txt` 的 inode 被找到

> 🔍 这个过程用到了 `dentry` 和 `inode` 缓存（slab 机制提升速度）



#### 2. **访问目标文件 inode → 获取逻辑块映射**

- 找到 `secret.txt` 的 inode 后，读取其中的：
  - 文件大小、类型、权限等元数据
  - 指向内容数据的块指针（直接块 / 间接块 / extents）



#### 3. **文件系统层：逻辑块号 → 磁盘块号 → 逻辑扇区号**

- 从 inode 得到的“块指针”其实是**磁盘块号**
- 将磁盘块号 × 块大小（如 4KB） → 文件内容在磁盘上的偏移地址（逻辑扇区号）



#### 4. **内核块设备层：构造 bio 请求，交给驱动**

- 构造 bio → 变成 I/O 请求（可能合并多个）
- 传递给设备驱动层（如 `sd.c`、`nvme.c`）



####  5. **硬盘控制器：逻辑扇区 → 物理扇区**

- 控制器（SATA/NVMe）接收到请求后：
  - 如果是 HDD：直接跳转到扇区读取
  - 如果是 SSD：FTL 机制映射到 NAND Flash 中的页块



#### 6. **返回数据给用户态程序**

- 数据先进入 **页缓存（Page Cache）**
- 然后通过 `read()` 系统调用将数据拷贝给用户空间







## buff/cache

### buff/cache 的组成：

| 类别               | 描述                            | 是否反映在 meminfo 中？         |
| ------------------ | ------------------------------- | ------------------------------- |
| ✅ **Page Cache**   | 缓存磁盘文件内容（最主要部分）  | ❌ 没有单独列出                  |
| ✅ **Slab Cache**   | 缓存内核结构体（inode、dentry） | ✅ `SReclaimable` + `SUnreclaim` |
| ✅ **Buffer Cache** | 块设备元数据缓存                | ✅ `Buffers` 字段                |





### 查看它们的独立值（来自 /proc/meminfo）：

```bash
grep -E 'Buffers|Cached|Slab' /proc/meminfo
```

你会看到类似：

```bash
Buffers:          20000 kB   # 块设备 buffer cache
Cached:          300000 kB   # page cache
Slab:             97972 kB   # = SReclaimable + SUnreclaim
```

然后：

```bash
buff/cache ≈ Buffers + Cached + Slab
```

> **`Buffers` 表示块设备的元数据缓存**，比如 superblock、inode bitmap、block bitmap、目录项等，这些属于文件系统的结构元信息，不是用户文件数据本身。





### Slab

#### 什么是 Slab？（核心概念）

**定义：**

**slab 是缓存查找文件所需的结构体数据（如 dentry、inode 等）来提升文件查找效率**

> **Slab 是 Linux 内核用于管理内存对象分配的一种高效缓存机制，**
>  专门用于重复分配/释放相同大小和结构的内核对象。

**举例：**

- `dentry`（目录项缓存）
- `inode`（文件 inode 缓存）
- `vm_area_struct`（进程虚拟内存映射）
- `ext4_inode_cache`（文件系统中的 inode 缓存）



#### Slab作用的举例说明

```bash
ls /etc/
```

**这个命令在背后会：**

1. 查 / → 查找 /etc 的 dentry
2. 如果已经缓存（在 slab 的 dentry_cache 中），直接返回
3. 然后读取 /etc 的 inode（从 inode_cache slab）
4. 展示内容，无需再次从磁盘读取元信息

➡️ **如果这些缓存都不在 slab 中，就会：**

- 查磁盘 inode 表
- 查磁盘目录项表
- 增加访问延迟



#### 判断哪些 slab 可清理？

你可以执行：

```bash
grep -A 3 "slab_reclaimable" /proc/meminfo
```

- `SReclaimable`：可以回收的 slab（如 dentry/inode）
- `SUnreclaim`：不可回收（比如 anon_vma、vm_struct）



#### 关于Slab缓存的实验

```bash
# 清空未利用的slab缓存
[root@devops-custom ~]# echo 3 > /proc/sys/vm/drop_caches

# 查看
[root@devops-custom ~]# grep -E 'dentry_cache|inode_cache' /proc/slabinfo | awk '{printf "  %-20s objs=%-10s size=%s\n", $1, $2, $8}'
  mqueue_inode_cache   objs=17         size=tunables
  ecryptfs_inode_cache objs=0          size=tunables
  fat_inode_cache      objs=21         size=tunables
  squashfs_inode_cache objs=622        size=tunables
  ext4_inode_cache     objs=1216       size=tunables       # 观察这个值
  hugetlbfs_inode_cache objs=24         size=tunables
  sock_inode_cache     objs=855        size=tunables
  proc_inode_cache     objs=482        size=tunables
  shmem_inode_cache    objs=2282       size=tunables
  inode_cache          objs=16375      size=tunables
  
  
# 访问/bin
[root@devops-custom ~]# ls -l /bin/ > /dev/null

# 再次查看
[root@devops-custom ~]# grep -E 'dentry_cache|inode_cache' /proc/slabinfo | awk '{printf "  %-20s objs=%-10s size=%s\n", $1, $2, $8}'
  mqueue_inode_cache   objs=17         size=tunables
  ecryptfs_inode_cache objs=0          size=tunables
  fat_inode_cache      objs=21         size=tunables
  squashfs_inode_cache objs=622        size=tunables
  ext4_inode_cache     objs=2883       size=tunables    # 明显变多，多了2883-1216=1667
  hugetlbfs_inode_cache objs=24         size=tunables
  sock_inode_cache     objs=855        size=tunables
  proc_inode_cache     objs=482        size=tunables
  shmem_inode_cache    objs=2282       size=tunables
  inode_cache          objs=16375      size=tunables
  
```









### **读缓存（page cache）** 与 **写缓冲（write-back buffer）**

#### **读操作为何要进入缓存（Page Cache）？**

> 为了 **避免频繁磁盘访问、提高读取效率**，内核会把**读过的数据页**缓存进内存（Page Cache）。下次访问时直接从内存读，速度快数百倍。

- 这部分数据由 `/proc/meminfo` 中的 `Cached:` 字段统计
- 属于 **只读页缓存（clean pages）**，可以随时被回收



#### **写操作为何先进入内存缓冲区？**

> 为了 **避免频繁 I/O 系统调用、减少磁盘写入次数、提高吞吐量**，写操作不是直接落盘，而是进入 Page Cache，并标记为 dirty（脏页）

- 这些写入数据暂存在缓存中
- 后续由内核的 **写回线程**（`pdflush`/`kupdate`/`kswapd`）批量落盘
- 写入时你看到的 “缓存行为”也被记录为 `Cached` 字段（但它们是 **dirty cache**）





读写两种数据缓存在缓存区**都算在 `/proc/meminfo` 中的 `Cached:` 里，但类型不同**：

| 操作类型 | 缓存类型         | 是否算进 Cached | 特点                   |
| -------- | ---------------- | --------------- | ---------------------- |
| 读文件   | Page Cache       | ✅ 是            | 干净页，可直接回收     |
| 写文件   | Dirty Page Cache | ✅ 是            | 脏页，不落盘前不可回收 |



#### 怎么知道 `Cached` 中包含了多少脏页？

查看 `/proc/meminfo` 中的以下字段：

```bash
grep -E 'Cached|Dirty|Writeback' /proc/meminfo
```

| 字段        | 含义                                 |
| ----------- | ------------------------------------ |
| `Cached`    | 所有页缓存总量（包括 clean + dirty） |
| `Dirty`     | 正在等待落盘的脏页                   |
| `Writeback` | 正在被写入磁盘的脏页                 |

你会发现：

```bash
Cached:    400000 kB
Dirty:      20000 kB
Writeback:   5000 kB
```

➡️ 说明 `Cached` 中的 **20000 + 5000 = 25000 kB 是脏页写缓存**，其他的是正常读缓存。



### free -h 中各指标的关系

```ABAP
otal = used + free + buff/cache ✅
available ≈ free + 可回收的 buff/cache 部分 ✅
```







## 实验

### 实验1：Linux 文件系统取证实操：通过 inode 手动恢复已删除文件



#### 实验环境准备

**创建虚拟磁盘并格式化为 ext4**

> **ext4 启用日志后的删除行为**
>
> `rm file` 在 journal ext4 中触发了什么？
>
> | 内容类型       | 是否记录日志    | 说明                                      |
> | -------------- | --------------- | ----------------------------------------- |
> | 文件内容数据块 | ❌（默认不记录） | 数据块直接写入磁盘（非 journal）          |
> | inode 元数据   | ✅               | 删除操作会将 inode、dentry 的变更写入日志 |
> | block bitmap   | ✅               | bitmap 的释放也会同步到 journal           |
>
> 
>
> 这意味着：
>
> - `inode` 在被删除时，会将**原始 inode 清空动作**写入日志区
> - journal commit 后，原始 inode 表中的内容将被清空
> - block bitmap 也会更新，数据块标记为空闲

```bash
fallocate -l 200M /tmp/ext4.img
mkfs.ext4 -O ^has_journal /tmp/ext4.img  # 关闭日志
mkdir /mnt/ext4test
mount -o loop /tmp/ext4.img /mnt/ext4test
```



#### 第一步：创建测试文件

```bash
mkdir test
cd test
echo 'Secret Data in file' > secret.txt
sync  # 确保数据落盘
```



#### 第二步：删除测试文件

```bash
rm secret.txt
sync
```

此时 `secret.txt` 已被删除，无法通过普通手段找到。



#### 第三步：使用 debugfs 查找 inode 和数据块

```bash
debugfs /dev/vda1

lsdel

# 输出类似
 Inode  Owner  Mode    Size   Blocks   Time Deleted
  12     0    100644   22     1        2024-06-01

# 记录该 inode 编号（如：12），然后查看 inode 内容：
stat <12>

# 找到：
EXTENTS:
(0): 42   # 表示数据存储在第 42 个块中（这是逻辑块号）
```



#### 第四步：计算并提取数据块内容（方法一：使用 dd）

### 计算偏移：

块大小通常为 4096 字节，偏移 = 42 × 4096 = 172032

### 提取内容：

```bash
dd if=/tmp/ext4.img of=recovered.txt bs=4096 skip=42 count=1
cat recovered.txt
```

应输出：

```
Secret Data in file
```

✅ 成功恢复已删除文件的内容！





# 第五天

## vim用法



- **正常（normal）模式**

  > （也称为普通模式），缺省的编辑模式；如果不加特殊说明，一般提到的命令都直接在正常模式下输入；在任何其他模式中，都可以通过键盘上的 Esc 键回到正常模式。

- **插入（insert）模式**

  > 输入文本时使用；比如在正常模式下键入 i（insert）或 a（append）即可进入插入模式。

- **可视（visual）模式**

  > 用于选定文本块；教程中已经提到可以用键 v（小写）来按字符选定，Vim 里也提供其他不同的选定方法，包括按行和按列块。

- **命令行（command-line）模式**

  > 用于执行较长、较复杂的命令；在正常模式下键入冒号（:）即可进入该模式；使用斜杠（/）和问号（?）开始搜索也算作命令行模式。命令行模式下的命令要输入回车键（Enter）才算完成。





### vim标准键描述方式



- `<Esc>` 表示 Esc 键；显示为“⎋”
- `<CR>` 表示回车键；显示为“↩”
- `<Space>` 表示空格键；显示为“␣”
- `<Tab>` 表示 Tab 键；显示为“⇥”
- `<BS>` 表示退格键；显示为“⌫”
- `<Del>` 表示删除键；显示为“⌦”
- `<lt>` 表示 < 键；显示为“<”
- `<Up>` 表示光标上移键；显示为“⇡”
- `<Down>` 表示光标下移键；显示为“⇣”
- `<Left>` 表示光标左移键；显示为“⇠”
- `<Right>` 表示光标右移键；显示为“⇢”
- `<PageUp>` 表示 Page Up 键；显示为“⇞”
- `<PageDown>` 表示 Page Down 键；显示为“⇟”
- `<Home>` 表示 Home 键；显示为“↖”
- `<End>` 表示 End 键；显示为“↘”
- `<F1> - <F12>` 表示功能键 1 到 12；显示为“F1”到“F12”
- `<S-…>` Shift 组合键；显示为“⇧”（较少使用，因为我们需要写 ! 而不是 `<S-1>`；和特殊键组合时仍然有用）
- `<C-…>` Control 组合键；显示为“⌃”<M-…> Alt 组合键；显示为“⌥”（对于大部分用户，它的原始键名 Meta 应该只具有历史意义）
- `<D-…>` Command 组合键；显示为“⌘”（Mac 键盘）



### vim配置

作为一个可以越用越顺手的应用程序，Vim 是需要配置的。

根据 Unix 下的惯例，Vim 的配置文件放在用户的主目录下，文件名通常是 `.vimrc`；而它在 Windows 下名字是 `_vimrc`。



基本配置

```bash
set undodir=~/.vim/undodir                # 这样一定要写在创建目录前面
let undodir_path = expand(&undodir)
if !isdirectory(undodir_path)
    call mkdir(undodir_path, 'p', 0700)
endif

syntax on
set background=dark
set enc=utf-8                          # 设置编辑文件的内码是 UTF-8
set nocompatible                       # 设置 Vim 不需要和 vi 兼容(目前大部分情况下这是缺省情况)
source $VIMRUNTIME/vimrc_example.vim   # 导入 Vim 的示例配置（这会打开一些有用的选项，如语法加亮、搜索加亮、命令历史、记住上次的文件位置，等等）
set nobackup                           # 不备份
set scrolloff=1
colorscheme murphy
```



### vim使用

#### 光标移动

Vim 里的基本光标移动是通过 **h、j、k、l** 四个键实现的。之所以使用这四个键，是有历史原因的。你看一下 Bill Joy 开发 vi 时使用的键盘就明白了：这个键盘上没有独立的光标键，而四个光标符号直接标注在 H、J、K、L 四个字母按键上。

<img src="D:\git_repository\cyber_security_learning\markdown_img\image-20250610103229515.png" alt="image-20250610103229515" style="zoom:1150%;" />

当然，除了历史原因外，这四个键一直使用至今，还是有其合理性的。它们都处于打字机的本位排（home row）上，这样打字的时候，手指基本不用移动就可以敲击到。因此，即使到了键盘上全都有了光标移动键的今天，很多 Vim 的用户仍然会使用这四个键来移动光标。



Vim 跳转到行首的命令是 **0**，跳转到行尾的命令是 **$**，我们也有 **^**，用来跳转到行首的第一个非空白字符。



对于一次移动超过一个字符的情况，Vim 支持使用 **b/w** 和 **B/W**，来进行以单词为单位的跳转。小写和大写命令的区别在于，小写的跟编程语言里的标识符的规则相似，认为一个单词是由字母、数字、下划线组成的（不严格的说法），而大写的命令则认为非空格字符都是单词。



使用 **f（find）**和 **t（till）**了。它们的作用都是找到下一个（如果在输入它们之前先输入数字 n 的话，那就是下面第 n 个）紧接着输入的字符。如果需要反方向搜索的话，使用大写的 **F** 和 **T** 就可以。



- `(` 和 `)` 移到上一句和下一句
- `{` 和 `}` 移到上一段和下一段

- `gg`跳转到开头，`G`跳转到结尾



#### 文本修改

- `d` 加动作来进行删除（`dd` 删除整行）；`D` 则相当于 `d$`，删除到行尾。
- `c` 加动作来进行修改（`cc` 修改整行）；`C` 则相当于 `c$`，删除到行尾然后进入插入模式。
- `s` 相当于 `cl`，删除一个字符然后进入插入模式；`S` 相当于 `cc`，替换整行的内容。
- `i` 在当前字符前面进入插入模式；`I` 则相当于 `^i`，把光标移到行首非空白字符上然后进入插入模式。
- `a` 在当前字符后面进入插入模式；`A` 相当于 `$a`，把光标移到行尾然后进入插入模式。
- `o` 在当前行下方插入一个新行，然后在这行进入插入模式；`O` 在当前行上方插入一个新行，然后在这行进入插入模式。
- `r` 替换光标下的字符；`R` 则进入替换模式，每次按键（直到 ）替换一个字符。
- `u` 撤销最近的一个修改动作； `U` 撤销当前行上的所有修改。



#### 文本对象选择

```bash
if (message == "sesame open")
```

我们进一步假设光标停在“sesame”的“a”上，那么（和一般的行文惯例不同，下面在命令外面也加上了引号，避免可能的歧义）

- `dw`（理解为 delete word）会删除“ame␣”，结果是“if (message == "sesopen")”
- `diw`（理解为 delete inside word）会删除“sesame”，结果是“if (message == " open")”
- `daw`（理解为 delete a word）会删除“sesame␣”，结果是“if (message == "open")”
- `diW` 会删除“"sesame”，结果是“if (message == open")”
- `daW` 会删除“"sesame␣”，结果是“if (message == open")”
- `di"` 会删除“sesame open”，结果是“if (message == "")”
- `da"` 会删除“"sesame open"”，结果是“if (message ==)”
- `di(` 或 `di)`会删除“message == "sesame open"”，结果是“if ()”
- `da(` 或  `da)`会删除“(message == "sesame open")”，结果是“if␣”



上面演示了 a、i 和 w、双引号、圆括号搭配使用，这些对于任何语言的代码编辑都是非常有用的。实际上，可以搭配的还有更多：

- 搭配 `s`（sentence）对句子进行操作——适合西文文本编辑
- 搭配 `p`（paragraph) 对段落进行操作——适合西文文本编辑，及带空行的代码编辑
- 搭配 `t`（tag）对 HTML/XML 标签进行操作——适合 HTML、XML 等语言的代码编辑
- 搭配 \` 和 `'` 对这两种引号里的内容进行操作——适合使用这些引号的代码，如 shell 和 Python
- 搭配方括号（`[` 和 `]`）对方括号里的内容进行操作——适合各种语言（大部分都会用到方括号吧）
- 搭配花括号（`{` 和 `}`对花括号里的内容进行操作——适合类 C 的语言
- 搭配角括号（`<` 和 `>`）对角括号里的内容进行操作——适合 C++ 的模板代码



你知道出错位置的行号，那你可以用`数字加 G` 来跳转到指定行。类似地，你可以用数字加 `|` 来跳转到指定列。这在调试代码的时候非常有用，尤其适合进行自动化。





#### 屏幕滚动

vimrc_example 有一个设定，我不太喜欢：它会设 set scrolloff=5，导致只要屏幕能滚动，光标就移不到最上面的 4 行和最下面的 4 行里，因为一移进去屏幕就会自动滚动。这同样也会导致 H 和 L 的功能发生变化：本来是移动光标到屏幕的最上面和最下面，现在则变成了移动到上数第 6 行和下数第 6 行，和没有这个设定时的 6H 与 6L 一样了。所以我一般会在 Vim 配置文件里设置 set scrolloff=1（你也可以考虑设成 0），减少这个设置的干扰。



只要光标还在屏幕上，你也可以滚动屏幕而不移动光标（不像某些其他编辑器，Vim 不允许光标在当前屏幕以外）。需要的按键是 `<C-E>` 和 `<C-Y>` 。

另外一种可能更实用的滚动屏幕方式是，把当前行“滚动”到屏幕的顶部、中部或底部。Vim 里的对应按键是 `zt`、`zz` 和 `zb`。和上面的几个滚动相关的按键一样，它们同样受选项 scrolloff 的影响。





#### 重复

- `;` 重复最近的字符查找（`f`、`t` 等）操作
- `,` 重复最近的字符查找操作，反方向
- `n` 重复最近的字符串查找操作（`/` 和 `?`）
- `N` 重复最近的字符串查找操作（`/` 和 `?`），反方向
- `.` 重复执行最近的修改操作





### 定制 vim 初级

#### vim的目录结构

Vim 的工作环境是由运行支持文件来设定的。如果你想要定制 Vim，就要熟知 Vim 有哪些不同类型的运行支持文件，分别存放在哪里，怎样能快捷地找到它们。Vim 比较有意思的一点的是，虽然运行支持文件是在 Vim 的安装目录下，但用户自己是可以“克隆”这个目录结构的。也就是说，你自己目录下的用户配置，到你深度定制的时候，也有相似的目录结构。所以，我就先从这些文件的目录结构开始讲起。



##### 安装目录下的运行支持文件

Vim 的运行支持文件在不同的平台上有着相似的目录结构。以 Vim 8.2 为例，它们的标准安装位置分别在：

- 大部分 Unix 下面：`/usr/share/vim/vim82`
- macOS Homebrew 下：`/usr/local/opt/macvim/MacVim.app/Contents/Resources/vim/runtime`
- Windows 下：`C:\Program Files (x86)\Vim\vim82`



在这个目录下面，你可以看到很多子目录，如 autoload、colors、doc、pack、plugin、syntax 等等。这些子目录下面就是分类放置的 Vim 支持文件。最常用的子目录应该是下面这几个：

- syntax：Vim 的语法加亮文件
- doc：Vim 的帮助文件
- colors：Vim 的配色方案
- plugin：Vim 的“插件”，即用来增强 Vim 功能的工具



**syntax 目录**

![image-20250610142943631](D:\git_repository\cyber_security_learning\markdown_img\image-20250610142943631.png)

这里面的文件去掉“.vim”后缀后，就是文件类型的名字，你可以用类似 `:setfiletype java` 这样的命令来设置文件的类型，从而进行语法加亮。



**doc目录**

我们用“:help”命令查看的帮助文件就放在 doc 目录下。



**colors 目录**

我们可以用菜单“编辑 > 配色方案”（“Edit > Color Scheme”）浏览配色方案，相应的文件就在 colors 目录下。

> vim配色方案使用
>
> 输入:colorscheme命令，紧接着一个空格后，然后点击Tab键，将可以遍历所有已安装的配色方案，按下Enter键可以应用选中的配色方案。
>
> 如果你希望在Vim启动时启用指定的配色方案，那么可以在[vimrc](https://link.zhihu.com/?target=http%3A//yyq123.blogspot.com/2012/01/vim-vimrc.html)文件中使用以下命令：
>
> ```bash
> :colorscheme name
> ```

![image-20250610160036317](D:\git_repository\cyber_security_learning\markdown_img\image-20250610160036317.png)



**plugin 目录**

<img src="D:\git_repository\cyber_security_learning\markdown_img\image-20250610160537331.png" alt="image-20250610160537331" style="zoom:150%;" />

在 plugin 目录下的系统内置插件不多，我们下面就快速讲解一下

- **getscriptPlugin**：获得最新的 Vim 脚本的插件（在目前广泛使用 Git 的年代，这个插件过时了，我们不讲）
- **gzip**：编辑 .gz 压缩文件（能在编辑后缀为 .gz 的文件时自动解压和压缩，你会感觉不到这个文件是压缩的）
- **logiPat**：模式匹配的逻辑运算符（允许以逻辑运算、而非标准正则表达式的方式来写模式匹配表达式）
- **manpager**：使用 Vim 来查看 man 帮助（强烈建议试一下，记得使用 Vim 的跳转键 C-] 和 C-T）
- **matchparen**：对括号进行高亮匹配（现代编辑器基本都有类似的功能）
- **netrwPlugin**：从网络上编辑文件和浏览（远程）目录（支持多种常见协议如 ftp 和 scp，可直接打开目录来选择文件）
- **rrhelper**：用于支持 --remote-wait 编辑（Vim 的多服务器会用到这一功能）
- **spellfile**：在拼写文件缺失时自动下载（Vim 一般只安装了英文的拼写文件）
- **tarPlugin**：编辑（压缩的）tar 文件（注意，和 gzip 情况不同，这儿不支持写入）
- **tohtml**：把语法加亮的结果转成 HTML（自己打开个文件，输入命令“**:TOhtml**”就知道效果了）
- **vimballPlugin**：创建和解开 .vba 文件（这个目前也略过时了，我们不讲）
- **zipPlugin**：编辑 zip 文件（和 tar 文件不同，zip 文件可支持写入）



除了 rrhelper 和 spellfile 属于功能支持插件，没有自己的帮助页面，其他功能都可以使用“`:help`”命令来查看帮助。查看帮助时，插件名称中的“Plugin”后缀需要去掉：查看 zip 文件编辑的帮助时，应当使用“`:help zip`”而不是“`:help zipPlugin`”。



**netw插件的用法**

```bash
# 注意事项1：用户名和当前用户名一致，或者vim scp://user@www.mysticalrecluse.com//www/wwwroot/www.mysticalrecluse.com/script/
# 注意事项2：如果是访问目录，结尾要加/
# 注意事项3：建议写绝对路径：vim scp://user@url/<绝对路径>
[root@magedu ~]# vim scp://www.mysticalrecluse.com//www/wwwroot/www.mysticalrecluse.com/script/
```

![image-20250610164613309](D:\git_repository\cyber_security_learning\markdown_img\image-20250610164613309.png)



**使用vim查看man手册**

```bash
[root@magedu ~]# export MANPAGER="vim -M +MANPAGER -"
```

![image-20250610170738176](D:\git_repository\cyber_security_learning\markdown_img\image-20250610170738176.png)



#### 用户的vim配置目录

Vim 的安装目录你是不应该去修改的。首先，你可能没有权限去修改这个目录；其次，即使你有修改权限，这个目录会在 Vim 升级时被覆盖，你做的修改也会丢失。用户自己的配置应当放在自己的目录下，这也就是用户自己的主目录下的 Vim 配置目录（Unix 下的 **.vim**，Windows 下的 **vimfiles**）。这个目录应和 Vim 安装目录下的运行支持文件目录有相同的结构，但下面的子目录你在需要修改 Vim 的相关行为时才有必要创建。如果一个同名文件出现用户自己的 Vim 配置目录里和 Vim 的安装目录里，**用户的文件优先**。



关于 Vim 的公用脚本，这儿再多说几句。Vim 的网站过去是用来集中获取各种脚本——如插件和配色方案——的地方，而 getscriptPlugin 可以帮助简化这个过程。今天你仍然可以使用这个方法，但 Git 和 GitHub 的广泛使用已经改变了人们获取和更新脚本的方式。现在，最主流的分发 Vim 脚本的方式是利用 GitHub，而用户则使用包管理器来调用 Git 从 GitHub（或类似的 Git 库）获取和更新脚本。







#### vim8 新功能



##### vim软件包 (重要)

vim的配置目录结构

```bat
.
├── colors
├── doc
├── pack
│   ├── minpac
│   │   ├── opt
│   │   │   ├── minpac
│   │   │   ├── vim-airline
│   │   │   └── vimcdoc
│   │   └── start
│   │       ├── VimExplorer
│   │       ├── asyncrun.vim
│   │       ├── fzf.vim
│   │       ├── gruvbox
│   │       ├── killersheep
│   │       ├── nerdcommenter
│   │       ├── nerdtree
│   │       ├── tagbar
│   │       ├── undotree
│   │       ├── vim-fugitive
│   │       ├── vim-matrix-screensaver
│   │       ├── vim-rainbow
│   │       ├── vim-repeat
│   │       ├── vim-rhubarb
│   │       └── vim-surround
│   └── my
│       ├── opt
│       │   ├── YouCompleteMe
│       │   ├── ale
│       │   ├── clang_complete
│       │   ├── cvsmenu
│       │   └── syntastic
│       └── start
│           ├── vim-gitgutter
│           └── ycmconf
├── plugin
├── syntax
└── undodir
```

Vim 8 在启动时会加载所有 pack/*/start 下面的包，而用户可以用 :packadd 命令来加载某个 opt 目录下的包，如 `:packadd vimcdoc` 命令可加载 vimcdoc 包，来显示中文帮助信息。

有了这样的目录结构，用户要自己安装、管理包就方便多了。推荐一个包管理器 `minpac`。包管理器可以带来下面的好处：

- 根据文本的配置（一般写在 vimrc 配置文件里）决定要安装哪些包
- 自动化安装、升级和卸载，包括帮助文件的索引生成



###### 安装minpac

```ABAP
从这里之后的操作，要求科学上网
```

根据 minpac 网页上的说明，我们在 Windows 下可以使用下面的命令

```bash
cd /d %USERPROFILE%
git clone https://github.com/k-takata/minpac.git ^
    vimfiles\pack\minpac\opt\minpac
```

在 Linux 和 macOS 下则可以使用下面的命令：

```bash
git clone https://github.com/k-takata/minpac.git \
    ~/.vim/pack/minpac/opt/minpac
```

然后，我们在 vimrc 配置文件中加入以下内容（先不用理解其含义）：

```bash
if exists('*minpac#init')
  " Minpac is loaded.
  call minpac#init()
  call minpac#add('k-takata/minpac', {'type': 'opt'})

  " Other plugins
endif

if has('eval')
  " Minpac commands
  command! PackUpdate packadd minpac | source $MYVIMRC | call minpac#update('', {'do': 'call minpac#status()'})
  command! PackClean  packadd minpac | source $MYVIMRC | call minpac#clean()
  command! PackStatus packadd minpac | source $MYVIMRC | call minpac#status()
endif
```

存盘、重启 Vim 之后，我们就有了三个新的命令，可以用来更新（安装）包、清理包和检查当前包的状态



###### 通过 minpac 安装扩展包

试验一下通过 minpac 来安装扩展包。在“Other plugins”那行下面加入以下内容：

```bash
call minpac#add('tpope/vim-eunuch')
```

保存文件，然后我们使用 `:PackUpdate` 命令。略微等待之后，安装成功后，使用`:PackStatus`查看，我们就能看到类似下面的界面

![image-20250610195213333](D:\git_repository\cyber_security_learning\markdown_img\image-20250610195213333.png)



###### 最近使用的文件

安装好 Vim 软件包之后，我们进一步来实现一个小功能。

Vim 的缺省安装缺了一个很多编辑器都有的功能：最近使用的文件。

我们就把这个功能补上吧。你只需要按照上一节的步骤安装 yegappan/mru 包就可以了（MRU 代表 most recently used）。安装完之后，重新打开 vimrc 文件，你就可以在图形界面里看到下面的菜单了：

```bash
[root@magedu ~]# vim .vimrc
......
  " Other plugins
  call minpac#add('tpope/vim-eunuch')
  call minpac#add('yegappan/mru')     # 添加这行，后执行:PackUpdate
......
```

```bat
如果执行PackUpdate显示路径不对，修改下面路径下文件，将其改为github地址即可
[root@magedu ~]# vim /root/.vim/pack/minpac/opt/minpac/.git/config
[core]
        repositoryformatversion = 0
        filemode = true
        bare = false
        logallrefupdates = true
[remote "origin"]
        url = https://github.com/k-takata/minpac.git     # 这里要改为github地址
        fetch = +refs/heads/*:refs/remotes/origin/*
[branch "master"]
        remote = origin
        merge = refs/heads/master
```



安装成功后，在`.vimrc`里添加以下内容（我们暂时先不用去理解其意义）

```bash
if !has('gui_running')
  " 设置文本菜单
  if has('wildmenu')
    set wildmenu
    set cpoptions-=<
    set wildcharm=<C-Z>
    nnoremap <F10>      :emenu <C-Z>
    inoremap <F10> <C-O>:emenu <C-Z>
  endif
endif
```

在增加上面的配置之后，你就可以使用键 `<F10>`（当然你也可以换用其他键）加 `<Tab>`来唤起 Vim 的文本菜单了。如下图所示：

![image-20250610201716910](D:\git_repository\cyber_security_learning\markdown_img\image-20250610201716910.png)



### 多文件打开与缓冲区

#### 多文件的打开方式

```ABAP
假设一个简单的使用场景，我们现在需要在某个目录下的所有 .cpp 和 .h 文件开头贴入一段版权声明，该如何操作？
```



首先，我们需要知道，Vim 支持一次性打开多个文件，你只需要在命令行上写出多个文件即可，或者使用通配符。比如，就我们刚才所说的编辑场景，我们可以使用 vim *.cpp *.h。

```bash
[root@magedu ~/test]# vim *.txt
```



为了确保在配置较差的环境里仍然能够正常工作，Vim 绝对不会不必要地消耗内存，包括打开不必要立即打开的文件。所以在上面的命令后，Vim 建立了一个文件列表，并且暂时只打开其中的第一个文件。接下来，用户可以决定，要编辑哪个文件，或者查看列表，或者提前退出，等等。



为此，Vim 提供了以下命令：

- `:args`：可以显示“参数”，即需要编辑的多个文件的列表
- **`:args 文件名`**：使用新的文件名替换参数列表
- `:next`（可缩写为 **`:n`**）：打开下一个文件；如当前文件修改（未存盘）则会报错中止，但如果命令后面加 ! 则会放弃修改内容，其他命令也类似
- `:Next`（缩写 **`:N`**）或 :previous（缩写 `:prev`）：打开上一个文件
- `:first` 或 `:rewind` ：回到列表中的第一个文件
- `:last`：打开列表中的最后一个文件



使用这些命令，我们的工作流当然就会发生变化了：

1. 在终端里进入到目标目录下
2. 使用 `vim *.cpp *.h` 或 `gvim *.cpp *.h` 来打开需要编辑的文件
3. 对于第一个文件，使用之前的方法贴入所需的文本
4. 使用 V 进入行选择的可视模式，移动光标选中所需的文本，然后使用 y 复制选中的各行
5. 执行命令 `:set autowrite`，告诉 Vim 在切换文件时自动存盘
6. 执行命令 `:n|normal ggP`，切换到下一个文件并执行正常模式命令 ggP，跳转到文件开头并贴入文本
7. 确认修改无误后，键入` :`、上箭头和回车，重复执行上面的命令
8. 待 Vim 报错说已经在最后一个文件里，使用 :w 存盘，或 :wq（抑或更快的 ZZ）存盘退出



第 6 步可以拆成 :n 和 ggP 两步，但文件数量较多时，反复手工敲 ggP 也挺累的。因此，我这儿使用了 normal 命令，在命令行模式下执行正常模式命令，下面就可以直接重复切换命令加粘贴命令，我们的编辑效率也得以大大提升。



Vim 还能解决一个 shell 相关的不一致性问题。如果我们要编辑的文件除了当前目录下的，还有所有子目录下的，在大部分 shell 下，包括 Linux 上缺省的 Bash，我们需要使用“*.cpp *.h **/*.cpp **/*.h”来挑选这些文件，重复、麻烦。Vim 在此处采用了类似于 Zsh 的简化语法，“**”也包含了当前目录。这样，我们只需把上面第 2 步改成下面这样即可：

```bash
vim
args **/*.txt
```



#### 缓冲区的管理和切换

Vim 里会对每一个已打开或要打开的文件创建一个缓冲区，这个缓冲区就是文件在 Vim 中的映射。在多文件编辑的时候你也会有同样数量的缓冲区。不过，缓冲区的数量常常会更高，因为你用 :e 等命令打开的文件不会改变“命令行参数”（只被命令行或 :args 命令修改），但同样会增加缓冲区的数量。



此外，:args 代表参数列表 / 文件列表，真的只是文件的列表而已。缓冲区中有更多信息的，最最基本的就是记忆了光标的位置。在 Vim 里，除了切换到下一个文件这样的批处理操作外，操作缓冲区的命令比简单操作文件的命令更为方便。作为对比，我们来看一下文件列表和缓冲区列表

![image-20250610221743636](D:\git_repository\cyber_security_learning\markdown_img\image-20250610221743636.png)

![image-20250610221930287](D:\git_repository\cyber_security_learning\markdown_img\image-20250610221930287.png)

可以看到，两者都展示了文件，都标示出了当前编辑的文件（分别使用方括号和“%a”）。不过，缓冲区列表中明显有更多的信息：

- 文件名前面有编号；我们也马上就会说到利用编号的命令。
- 除了当前活跃文件的标记“%a”，还有个文件被标成了“#”，这表示最近的缓冲区；缓冲区列表里还可能有其他标记，如“+”表示缓冲区已经被修改。
- 文件名后面有行号，表示光标在文件中的位置。



常用的缓冲区命令跟前面文件列表相关的命令有很大的相似性，因此我在这儿一起讲，可以帮助你记忆：

- `:buffers` 或 `:ls`：可以显示缓冲区的列表
- `:buffer 缓冲区列表里的编号`（`:buffer` 可缩写为 `:b`）：跳转到编号对应的缓冲区；如当前缓冲区已被修改（未存盘）则会报错中止，但如果命令后面加 ! 则会放弃修改内容；其他命令也类似
- `:bdelete` 缓冲区列表里的编号（`:bdelete` 可缩写为`:bd`）：删除编号对应的缓冲区；编号省略的话删除当前缓冲区
- `:bnext`（缩写 `:bn`）：跳转到下一个缓冲区
- `:bNext`（缩写 `:bN`）或 :bprevious（缩写 :bp）：跳转到上一个缓冲区
- `:bfirst` 或 `:brewind`：跳转到缓冲区列表中的第一个文件
- `:blast`：跳转到缓冲区列表中的最后一个文件



还有很常见的一种情况是，我们需要在两个文件之间切换。Vim 对最近编辑的文件（上面提到的列表里标有“#”的文件）有特殊的支持，使用快捷键 `<C-^>`可以在最近的两个缓冲区之间来回切换。这个快捷键还有一个用法是在前面输入缓冲区的编号：比如，用 `1<C-^>` 可以跳转到第一个缓冲区（跟命令行模式的命令 `:bfirst` 或 `:b1` 效果相同）。



### 窗口和标签页

#### 多窗口编辑







### 文件类型判断和关联设定

#### 文件类型判断

Vim 的文件类型判断是在 filetype.vim 中执行的。我们可以用下面的命令来打开这个文件

```bat
:e $VIMRUNTIME/filetype.vim
```







### vim脚本

#### 打印和输出字符串

```bat
echo 'Hello World!'   # echo 是 Vim 用来显示信息的内置命令，而 'Hello world!' 是一个字符串字面量。
```

Vim 里也可以使用 " 来引起一个字符串。' 和 " 的区别和在 shell 里比较相似，前者里面不允许有任何转义字符，而后者则可以使用常见的转义字符序列，如 \n 和 \u.... 等。和 shell 不同的是，我们可以在 ' 括起的字符里把 ' 重复一次来得到这个字符本身，即 `'It''s'` 相当于 `"It's"`。不过，在这个例子里，显然还是后者更清晰了。



因为 `"` 还有开始注释的作用，一般情况下推荐在 Vim 脚本里使用 `'`，除非你需要转义字符序列或者需要把 `'` 本身放到字符串里。



字符串可以用 `.` 运算符来拼接。由于字典访问也可以用 `.` ，为了避免歧义，Bram 推荐开发者在新的 Vim 脚本中使用` .. `来拼接。但要注意，这个写法在 Vim 7 及之前的版本里不支持。我目前仍暂时使用 . 进行字符串拼接，并和其他大部分运算符一样，前后空一格。这样跟不空格的字典用法比起来，差异就相当明显了。

```bat
:echo 'hello' . 'world'
# 输出：helloworld
```





除了 `echo`，Vim 还可以用 `echomsg`（缩写 `echom`）命令，来显示一条消息。跟 echo 不同的是，这条消息不仅会显示在屏幕上，还会保留在消息历史里，可以在之后用 `message` 命令查看



#### 变量

```bat
let answer = 42   # 变量赋值
```

```bash
let a = 'hello'
let b = 'world'
echo a . b
# 输出：helloworld
```

Vim 的变量可以手工取消，需要的命令是 `unlet`。在你写了 `unlet answer` 之后，你就不能再读取 `answer` 这个变量了。



#### 数字

上面的赋值语句用到了整数。Vim 脚本里的数字支持整数和浮点数，在大部分平台上，两者都是 64 位的有符号数字类型，基本对应于大部分 C 语言环境里的 int64_t 和 double。表示方式也和 C 里面差不多：整数可以使用 0（八进制）、0b（二进制）和 0x（十六进制）前缀；浮点数含小数点（不可省略），可选使用科学计数法。



#### 复杂数据结构

##### 列表（list）

```js
let primes = [2, 3, 5, 7, 11, 13, 17, 19]
echo primes[0]  // 输出：2
```



##### 字典（map）

```bat
let int_squares = {
      \0: 0,         # \是续行，下一行的第一个非空白字符如果是 \，则表示这一行跟上一行在逻辑上是同一行
      \1: 1,
      \2: 4,
      \3: 9,
      \4: 16,
      \}
      
# 访问
int_squares['2']
int_squares.2       # 二者等价
```



#### 表达式

在插入模式和命令行模式下都可以使用按键 `<C-R>=`（两个键）后面跟一个表达式来使用表达式的结果

在替换命令中，我们在 `\=` 后面也同样可以跟一个表达式，来表示使用该表达式的结果。

```bat
:%s/^/\=line('.') . ' '/    # 在当前编辑文件的每一行前面插入行号和空格; line 是 Vim 的一个内置函数，line('.') 表示“当前”行的行号
```





#### 控制结构

Vim 支持标准的 `if`、`while` 和 `for` 语句。

Vim 的写法有点老派，每种结构都要用一个对应的 endif、endwhile 和 endfor 来结束，如下面所示：

```bat
" 简单条件语句
if 表达式
  语句
endif

" 有 else 分支的条件语句
if 表达式
  语句
else
  语句
endif

" 更复杂的条件语句
if 表达式
  语句
elseif 表达式
  语句
else
  语句
endif

" 循环语句
while 表达式
  语句
endwhile
```

在 while 和 for 循环语句里，你可以使用 break 来退出循环，也可以使用 continue 来跳过循环体内的其他语句。



Vim 脚本的 for 语句跟 Python 非常相似，形式是：

```bat
for var in object  // 表示遍历 object（通常是个列表）对象里面的所有元素。
  这儿可以使用 var
endfor
```



#### 函数和匿名函数

Vim 脚本里定义函数使用下面的语法：

```bat
function 函数名(参数1, 参数2, ...)
  函数内容
endfunction
```

Vim 里用户自定义函数必须首字母大写（和内置函数相区别）或者使用 `s:` 表示该函数只在当前脚本文件有效。`...` 可以出现在参数列表的结尾，表示可以传递额外的无名参数。使用有名字的参数时，你需要加上 `a:` 前缀。要访问额外参数，则需要使用 `a:1`、`a:2` 这样的形式。特殊名字 `a:0` 表示额外参数的数量，`a:000` 表示把额外参数当成列表来使用，因而 `a:000[0]` 就相当于 `a:1`。



在函数里面，跟大部分语言一样，你可以使用 return 命令返回一个结果，或提前结束函数的执行。



##### 匿名函数

im 脚本里允许匿名函数，形式是 {逗号分隔开的参数 -> 表达式}。

```bat
echo map(range(1, 5), {idx, val -> val * val})

# rang(1,5) = [1,2,3,4,5]
# idx为列表的索引，val是列表的值
```



#### vim特性

##### 变量的前缀

- `a:` 表示这个变量是函数参数，只能在函数内使用。
- `g:` 表示这个变量是全局变量，可以在任何地方访问。
- `l:` 表示这个变量是本地变量，但一般这个前缀不需要使用，除非你跟系统的某个名字发生了冲突。
- `s:`表示这个变量（或函数，它也能用在函数上）只能用于当前脚本，有点像 C 里面的 static 变量和函数，只在当前脚本文件有效，因而不会影响其他脚本文件里定义的有冲突的名字。





##### 重要命令







## 正则表达式



### 正则表达式的三个流派

#### POSIX 流派的正则表达式

- **BRE标准**

  > 下列字符用到主要转移：()，+，*，？，{}



- **ERE标准**



#### POSIX 字符组

![img](https://static001.geekbang.org/resource/image/c3/ya/c32024952cb6af3f78d9c08d9b5b3yya.png?wh=1162*1022)

#### Perl兼容正则表达式

在 1987 年 12 月，Larry Wall 发布了 Perl 语言第一版，因其功能强大一票走红，所引入的正则表达式功能大放异彩。之后 Perl 语言中的正则表达式不断改进，影响越来越大。于是在此基础上，1997 年又诞生了PCRE——Perl 兼容正则表达式（Perl Compatible Regular Expressions）。

PCRE 是一个兼容 Perl 语言正则表达式的解析引擎，是由 Philip Hazel 开发的，为很多现代语言和工具所普遍使用。除了 Unix 上的工具遵循 POSIX 标准，**PCRE 现已成为其他大部分语言和工具隐然遵循的标准。**









### 单字符

.：任意字符（\n除外）

```bash
echo -e "abc\ndef" | grep -E "a.*f"
```

**不会匹配成功**，因为 `.` 无法跨越换行符 `\n`。



\d ：数字

\w ： 数字，字母，下划线

\s：空白字符



底线：用多选一表达\d，\w

[ ]：多选一

[^ ]：取反，只有在中括号里是取反的意思，注意不要和断言混淆



### 量词

`*` ：0到多个

`+` : 1到多个

`?`：0到1个

{N}：N个

{M,N}：M到N个



### 断言

^：开头断言

$：结尾断言

\b：单词断言



环视



### 分组引用

技巧：根据左括号判断\num中的数字

```bash
[root@magedu ~]# echo forwardfor|grep -P "((for)(ward))\2"
forwardfor
[root@magedu ~]# echo forwardward|grep -P "((for)(ward))\3"
forwardward
[root@magedu ~]# echo forwardforward|grep -P "((for)(ward))\1"
forwardforward
```



[root@magedu ~]# echo "abc def" | sed -E 's/(abc) (def)/\1-&/'（& == \0）
abc-abc def





### 模式

g global 全员



i 带大小写不敏感









## 三剑客



grep, sed, awk都是行处理工具



### grep

过滤



-o：只输出匹配到的

-E：ERE

-P：perl兼容正则表达式

-v：取反

-i：大小写不敏感

-n：显示行号

-r：递归



--------------------------------------------------

-Anum   匹配到的行及之后几行



-Bnum   匹配到的行及之前几行



-Cnum   匹配到的行及之前后几行







### sed

语法：**sed   [选项]   '处理动作'   file**

​            处理动作 = 范围 + 动作 （对哪些范围，做哪些动作）

​            **sed [选项] '范围 + 动作'  file**  ，这里的动作指的是对模式空间的动作









基础结构

```bash
sed '' passwd    #默认输出每一行

sed -n '' passwd    # 限制输出，即使用了 -n，每一行还是会被读取进模式空间，只是不输出而已。

sed -n 'p' passwd   # 将模式空间中匹配的输出出来，不写范围，默认全文匹配

# 输出第2行
[root@magedu ~]# sed -n '2p' /etc/passwd
bin:x:1:1:bin:/bin:/sbin/nologin

```





选项

-n

-E/-r

-i：改变源文件

-i.bak：备份



范围的格式：

- N：代表第几行
- N,M：n到m行

- /pattern/：输出匹配的行

- /pattern1/,/pattern2/



动作：

p：打印

s@@@：替换             模式：g,i

a\ -------------- 向下一行追加

i\ ---------- 向前一行追加

c\ --------- 替换整行

d ------ 删除





### awk

语法：awk  [选项]  '处理动作' file

​            动作：判断 + 动作

基本格式

```bash
# 什么都没有，则没条件，也没动作
[root@magedu ~]# seq 5 |awk ''

# 只给一个动作，默认为真
[root@magedu ~]# seq 5 |awk '{print}'
1
2
3
4
5

# awk执行默认动作 {print $0}
[root@magedu ~]# seq 5 | awk '1'
1
2
3
4
5


```



选项：

-v ：变量

-F：分隔符，等价于-v FS=''

> -v FS=":" = -F:



变量：

O: output

F: field 字段（列）

R: record 记录（行）

S： Separator    分隔

N：number 数字，号



FS：Field Separator   字段分隔符



NF：字段号

NR：行号

RS：行分隔

OFS：output Field Separaotr ：输出字段分隔符





判断+动作：

print

```bash
# awk中变量未定义，默认是0
seq 10|awk 'i=!i'   # 注意这里=是赋值，不是比较
```



处理顺序

seq 10|awk 'BEGIN{}{}END{}'





# 第N天（Shell）

```bash
>|        #  强制覆盖（允许在set -C的情况下，强制覆盖）
```

```bash
set -C 禁止将内容覆盖已有文件，但可追加
set +C 允许覆盖，默认

# 该知识点仅作了解
```









# wireshark 基本用法





## 如何捕获报文

- **点击捕获 -> 选项，打开捕获窗口**
  - 网卡设备/流量/捕获过滤器，点击“开始”按钮开始抓包
- **点击捕获 -> 停止，停止抓包**

![image-20250619174044113](D:\git_repository\cyber_security_learning\markdown_img\image-20250619174044113.png)





### 输出

捕获到的数据，要么保存到临时文件，要么保存到永久文件中

- 如果要保存到**永久文件**中，可以指定好要保存的路径及文件名

- 如果是**临时文件**，可以点击自动创建新文件，经过多少秒或者多少字节，自动换一个新文件，并不断新增

  > 抓包数据被先写入一个临时区域（通常是内存或磁盘中的临时文件），当你“停止捕获”时，工具才会提示你是否保存这个临时内容为正式文件。

- 环形缓冲区（ring buffer）机制本身只是限制文件个数，并不会主动触发文件轮转；你需要配合“自动创建新文件”设置（基于时间或大小）来实现环形写入效果。

![image-20250619174915407](D:\git_repository\cyber_security_learning\markdown_img\image-20250619174915407.png)



### 选项

选项主要作用是决定多长时间或者多少文件或者多少数据后，自动停止捕获。以及是否解析名称

![image-20250619175521009](D:\git_repository\cyber_security_learning\markdown_img\image-20250619175521009.png)

各个名称解析选项含义与示例：

**`Resolve MAC addresses`（已启用）**

- **作用**：将 MAC 地址转换为对应厂商的名称（根据 OUI 数据库）

  | 原始字段            | 解析后            |
  | ------------------- | ----------------- |
  | `00:1C:42:00:00:08` | `Parallels, Inc.` |
  | `00:0C:29:5B:A4:21` | `VMware, Inc.`    |



**`Resolve network names`**

- **作用**：将 IP 地址解析成主机名（DNS 或本地解析）

  | 原始 IP       | 解析后                             |
  | ------------- | ---------------------------------- |
  | `8.8.8.8`     | `dns.google`                       |
  | `192.168.1.1` | `router.local`（如果主机名可解析） |

⚠️ 注意：**启用后可能造成抓包时卡顿**，因为它可能触发实际的 DNS 查询！



 **`Resolve transport names`**

- **作用**：将端口号解析成常见协议名（基于 `/etc/services` 或内置映射）

  | 原始端口 | 协议名  |
  | -------- | ------- |
  | `443`    | `HTTPS` |
  | `53`     | `DNS`   |
  | `22`     | `SSH`   |







## wireshark 面板

![image-20250619180200930](D:\git_repository\cyber_security_learning\markdown_img\image-20250619180200930.png)







### 快捷方式工具栏

![image-20250619180505886](D:\git_repository\cyber_security_learning\markdown_img\image-20250619180505886.png)



### 数据包的颜色（视图->着色规则）

![image-20250619181042041](D:\git_repository\cyber_security_learning\markdown_img\image-20250619181042041.png)







### 设定时间显示格式

**绝对时间**

![image-20250619181321755](D:\git_repository\cyber_security_learning\markdown_img\image-20250619181321755.png)

**相对时间**

![image-20250619181358844](D:\git_repository\cyber_security_learning\markdown_img\image-20250619181358844.png)



**基于某个数据包的相对时间**

![image-20250619181459082](D:\git_repository\cyber_security_learning\markdown_img\image-20250619181459082.png)







### 数据包列表面板的标记符号

![image-20250619181645488](D:\git_repository\cyber_security_learning\markdown_img\image-20250619181645488.png)





## 捕获过滤器













## 显示过滤器





























































