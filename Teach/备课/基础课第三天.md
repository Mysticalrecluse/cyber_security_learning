# Linux基础

## 登录方式

### 本地登录

**文本界面登陆**

![image-20250528091742207](D:\git_repository\cyber_security_learning\markdown_img\image-20250528091742207-1751936868685-1.png)

![image-20250528095031290](D:\git_repository\cyber_security_learning\markdown_img\image-20250528095031290-1751936868686-2.png)

**图形界面登录**

![image-20250528094046185](D:\git_repository\cyber_security_learning\markdown_img\image-20250528094046185-1751936868686-3.png)

![image-20250528094158508](D:\git_repository\cyber_security_learning\markdown_img\image-20250528094158508-1751936868686-4.png)

![image-20250528094732300](D:\git_repository\cyber_security_learning\markdown_img\image-20250528094732300-1751936868686-5.png)

### 环境初始化

#### **桌面版安装 VMware Tools**

```bash
# Ubuntu-desktop版
apt install -y open-vm-tools-desktop

# Ubuntu-desktop版
yum install -y open-vm-tools-desktop
```



#### 更改ssh服务端配置

**Rocky sshd配置修改**

![image-20250606093838560](D:\git_repository\cyber_security_learning\markdown_img\image-20250606093838560-1751936868686-6.png)

![image-20250606093519980](D:\git_repository\cyber_security_learning\markdown_img\image-20250606093519980-1751936868686-7.png)

![image-20250606093938592](D:\git_repository\cyber_security_learning\markdown_img\image-20250606093938592-1751936868686-8.png)

```bash
# 修改ssh服务端配置文件
[root@localhost ~]# nano /etc/ssh/sshd_config
```

![image-20250606094550532](D:\git_repository\cyber_security_learning\markdown_img\image-20250606094550532-1751936868686-9.png)

![image-20250606094704661](D:\git_repository\cyber_security_learning\markdown_img\image-20250606094704661-1751936868686-10.png)

```bash
Ctrl + O 写入 -> Enter回车确认 -> Ctrl + x 退出
```

![image-20250606100042994](D:\git_repository\cyber_security_learning\markdown_img\image-20250606100042994-1751936868686-11.png)

```bash
# Rocky重启ssh服务
systemctl restart sshd
```



**Ubuntu sshd配置修改**

![image-20250606095528999](D:\git_repository\cyber_security_learning\markdown_img\image-20250606095528999-1751936868686-12.png)

![image-20250606095803033](D:\git_repository\cyber_security_learning\markdown_img\image-20250606095803033.png)

```bash
# 切换root用户
sudo -i 
# 输入密码
# 编辑ssh服务端配置文件
[root@magedu ~]# nano /etc/ssh/sshd_config

```

![image-20250606095944612](D:\git_repository\cyber_security_learning\markdown_img\image-20250606095944612-1751936868686-13.png)

![image-20250606100239817](D:\git_repository\cyber_security_learning\markdown_img\image-20250606100239817-1751936868686-14.png)

![image-20250606100432907](D:\git_repository\cyber_security_learning\markdown_img\image-20250606100432907-1751936868686-15.png)

```bash
# Ubuntu中重启ssh服务
systemctl restart ssh
```





### 远程登录

远程登录允许用户从其他主机或终端通过网络连接到Linux系统进行登录操作

**登录方式**

**SSH (Secure Shell)**

- 提供加密的远程登录会话，确保数据传输的安全性。SSH是Linux系统中广泛使用的远程登录协议。
- 适用场景：远程服务器管理、远程软件开发、安全的数据传输等。
- 登录方式：使用SSH客户端软件或直接执行 "ssh 用户@地址" 命令进行登录。



**Telnet**

- 一种较旧的远程登录协议，不提供数据加密，因此安全性较低。在现代Linux系统中已较少使用。
- 适用场景：由于安全性问题，不推荐在需要保护数据传输安全性的场景中使用。
- 登录方式：在Linux终端下执行"telnet 地址"命令进行登录。



### SSH客户端介绍

#### XShell

![image-20250606100955186](D:\git_repository\cyber_security_learning\markdown_img\image-20250606100955186-1751936868686-16.png)

![image-20250606101202870](D:\git_repository\cyber_security_learning\markdown_img\image-20250606101202870-1751936868686-17.png)

![image-20250606101416417](D:\git_repository\cyber_security_learning\markdown_img\image-20250606101416417-1751936868686-19.png)

```basic
输入用户名，密码后连接，注意：用户名设置过密码，否则无效
```

![image-20250606101631718](D:\git_repository\cyber_security_learning\markdown_img\image-20250606101631718-1751936868686-18.png)

![image-20250606101701531](D:\git_repository\cyber_security_learning\markdown_img\image-20250606101701531-1751936868686-20.png)



#### MobaXterm

![image-20250606102013731](D:\git_repository\cyber_security_learning\markdown_img\image-20250606102013731-1751936868686-21.png)

![image-20250606102112417](D:\git_repository\cyber_security_learning\markdown_img\image-20250606102112417-1751936868686-22.png)

![image-20250606102205448](D:\git_repository\cyber_security_learning\markdown_img\image-20250606102205448-1751936868686-23.png)

![image-20250606102301640](D:\git_repository\cyber_security_learning\markdown_img\image-20250606102301640-1751936868686-24.png)

![image-20250606102354501](D:\git_repository\cyber_security_learning\markdown_img\image-20250606102354501-1751936868686-25.png)



![image-20250606102920180](D:\git_repository\cyber_security_learning\markdown_img\image-20250606102920180-1751936868686-26.png)



### 关闭防火墙

#### Ubuntu关闭防火墙

```bash
[root@magedu ~]# systemctl disable --now ufw
Synchronizing state of ufw.service with SysV service script with /usr/lib/systemd/systemd-sysv-install.
Executing: /usr/lib/systemd/systemd-sysv-install disable ufw

```



#### Rocky关闭防火墙

```bash
# 关闭Selinux
[root@localhost ~]# nano /etc/selinux/config
SELINUX=disabled    # SELINUX的值改为disabled

[root@localhost ~]# setenforce 0

# 关闭防火墙
[root@localhost ~]# systemctl disable firewalld.service 
Removed "/etc/systemd/system/multi-user.target.wants/firewalld.service".
Removed "/etc/systemd/system/dbus-org.fedoraproject.FirewallD1.service".
```





### 换源更改为国内源

#### Ubuntu换源

```bash
[root@magedu-VMware-Virtual-Platform]# vim /etc/apt/sources.list
# Ubuntu sources have moved to /etc/apt/sources.list.d/ubuntu.sources

deb https://mirrors.aliyun.com/ubuntu/ noble main restricted universe multiverse
deb https://mirrors.aliyun.com/ubuntu/ noble-updates main restricted universe multiverse
deb https://mirrors.aliyun.com/ubuntu/ noble-backports main restricted universe multiverse
deb https://mirrors.aliyun.com/ubuntu/ noble-security main restricted universe multiverse

[root@magedu-VMware-Virtual-Platform]# apt update
```



#### Rocky换源

```bash
[root@localhost /etc/yum.repos.d]# mkdir -p /etc/yum.repos.d/backup
[root@localhost /etc/yum.repos.d]# mv /etc/yum.repos.d/*.reop /etc/yum.repos.d/backup

[root@localhost /etc/yum.repos.d]# vim rocky.repo 
# rocky.repo
#
# The mirrorlist system uses the connecting IP address of the client and the
# update status of each mirror to pick current mirrors that are geographically
# close to the client.  You should use this for Rocky updates unless you are
# manually picking other mirrors.
#
# If the mirrorlist does not work for you, you can try the commented out
# baseurl line instead.

[baseos]
name=Rocky Linux $releasever - BaseOS
#mirrorlist=https://mirrors.rockylinux.org/mirrorlist?arch=$basearch&repo=BaseOS-$releasever$rltype
baseurl=https://mirrors.aliyun.com/rockylinux/10/BaseOS/x86_64/os/
gpgcheck=1
enabled=1
gpgkey=https://mirrors.aliyun.com/rockylinux/RPM-GPG-KEY-Rocky-10

[AppStream]
name=Rocky Linux $releasever - AppStream - Debug
#mirrorlist=https://mirrors.rockylinux.org/mirrorlist?arch=$basearch&repo=BaseOS-$releasever-debug$rltype
baseurl=https://mirrors.aliyun.com/rockylinux/10/AppStream/x86_64/os/
gpgcheck=1
enabled=1
gpgkey=https://mirrors.aliyun.com/rockylinux/RPM-GPG-KEY-Rocky-10

[extras]
name=Rocky Linux $releasever - Extras - Source
#mirrorlist=https://mirrors.rockylinux.org/mirrorlist?arch=source&repo=BaseOS-$releasever-source$rltype
baseurl=https://mirrors.aliyun.com/rockylinux/10/extras/x86_64/os/
gpgcheck=1
enabled=1
gpgkey=https://mirrors.aliyun.com/rockylinux/RPM-GPG-KEY-Rocky-10

[epel]
name=Rocky Linux $releasever - EPEL - Source
#mirrorlist=https://mirrors.rockylinux.org/mirrorlist?arch=source&repo=BaseOS-$releasever-source$rltype
baseurl=https://mirrors.aliyun.com/epel/10/Everything/x86_64/
gpgcheck=1
enabled=1
gpgkey=https://mirrors.aliyun.com/epel/RPM-GPG-KEY-EPEL-10


[root@localhost /etc/yum.repos.d]# yum makecache
```







## Linux用户类型

Linux系统的用户主要分为两大类：root用户和普通用户



### root用户

Root用户是Linux系统中的超级用户，拥有对系统的完全控制权。它可以执行系统中的任何命令，访问 任何文件，以及更改系统配置。在Linux系统中，root用户的用户ID（UID）是0。



**修改密码**

root用户可以修改所有用户的密码

```bash
# 修改root自身密码
[root@localhost ~]# passwd
更改用户 root 的密码 。
新的密码： 
无效的密码： 密码少于 8 个字符     # 这里的提示可以无视
重新输入新的密码： 
passwd：所有的身份验证令牌已经成功更新。

# 修改其他普通用户密码
# 格式：passwd [username]
[root@localhost ~]# passwd magedu
更改用户 magedu 的密码 。
新的密码： 
无效的密码： 密码少于 8 个字符    # 这里的提示可以无视
重新输入新的密码： 
passwd：所有的身份验证令牌已经成功更新。
```



### 普通用户

普通用户是Linux系统中除了root用户之外的所有用户。它们的权限受到限制，只能访问和操作自己被 授权的文件和目录。普通用户的UID通常大于0，且每个用户都有一个唯一的UID和用户名。



**修改密码**

普通用户只能修改自己的密码，且必须满足密码格式要求

```bash
[magedu@localhost ~]$ passwd
更改用户 magedu 的密码 。
当前的密码： 
新的密码： 
无效的密码： 密码少于 8 个字符     # 普通用户必须满足密码要求
passwd: 鉴定令牌操作错误
[magedu@localhost ~]$ passwd
更改用户 magedu 的密码 。
当前的密码： 
新的密码： 
重新输入新的密码： 
passwd：所有的身份验证令牌已经成功更新。
```



**普通用户提升root用户**

```bash
# Ubuntu
mystical@magedu:~$ sudo -i
[sudo] password for mystical: 
[root@magedu ~]# 


# Rocky9 无法直接使用sudo -i提升，但可以直接使用root用户登录
[magedu@localhost ~]$ sudo -i
[sudo] magedu 的密码：
magedu 不在 sudoers 文件中。此事将被报告。    # 意味着用户 magedu 没有被授权使用 sudo，因此无法执行特权命令（即使你知道密码）。

# 解决方案：
# 在root权限下，执行下列命令
[root@localhost ~]# usermod -aG wheel magedu   # 很多发行版默认允许 wheel 组的用户使用 sudo

# 提升成功
[root@localhost ~]# su - magedu
[magedu@localhost ~]$ sudo -i
[sudo] magedu 的密码：
[root@localhost ~]# 
```



### 用户切换

命令解读

```bash
命令 su 可以切换当前用户身份到另外一个用户
命令 exit 可以回退到刚才的那个用户身份
```



示例

```bash
# 查看当前用户身份
[root@localhost ~]# whoami
root

# 切换到magedu用户
[root@localhost ~]# su magedu
[magedu@localhost root]$ whoami
magedu

# exit退回到root用户
[magedu@localhost root]$ exit
exit
[root@localhost ~]# whoami
root
```





## 终端

### 认识控制台与终端

在计算机发展的最初，有两个最主要的特点：个头大和价格昂贵。在 20 世纪 70 年代 Ken Thompson 在 PDP-11（DEC 公司制造的小型计算机） 上开发 UNIX 系统时，为了解决计算机价格昂贵的问题，他们把 UNIX 设计成了多任务、多用户的操作系统。但是在那个年代所有的机器都非常昂贵，还是为了解决钱的问题，他们选择了一个价格便宜并且可用的机器（ Teletype ASR33）来连接到 PDP-11，使计算机可以让多个人使用。

最初开发 Teletype ASR33（"Teletype" 是一个商标名称。ASR 代表自动发送与接收，即 Automatic Send-Receive）的目的是通过电话线发送和接收消息，所以该机器被称为电传打字机（Teletypewriter 缩写为 **TTY**）

![image-20250606175542815](D:\git_repository\cyber_security_learning\markdown_img\image-20250606175542815-1751936868686-27.png)

所有的 Teletype 都有一个键盘用于输入和一卷纸用于打印输出。为了存储和读取数据还自带了一个纸带穿孔机和纸带阅读机。它没有屏幕、没有鼠标，也没有声音，但是它经济实惠并且可用。

在 UNIX 系统中，将 Teletype ASR33 称为终端（terminal），而将 PDP-11 称为主机（host）。其中终端只有两个功能：接受输入和打印输出。

在所有连接到主机的终端中，有一台终端比较特殊。可以把它看成是主机的一部分，它是用来管理系统的，这台特殊的终端就是控制台（console）。一台主机只有一个控制台。在启动计算机的时候，所有的信息都会显示到控制台上。在操作计算机的过程中，与终端不相关的信息，比如内核消息，后台服务消息，也会显示到控制台上。

简单来说，控制台是计算机的基本设备，而终端是附加设备。



来感受一下最初的 UNIX 计算机，PDP-11 主机和多个 Teletype ASR33 终端。

![image-20250606175835390](D:\git_repository\cyber_security_learning\markdown_img\image-20250606175835390-1751936868686-28.png)





## 终端类型

控制台终端：/dev/console

串行终端：/dev/ttyS#，去要在grub中开启，添加`console=ttyS0,115200`

虚拟终端：tty：teletypewriters，/dev/tty#，tty可有n个，**Ctrl + Alt + F#**

伪终端：pty：pseudo-tty，/dev/pts/# 如：SSH远程连接

图形终端：startx，xwindows



### 查看当前的终端设备

tty命令可以查看当前所有终端

```bash
[root@localhost ~]# tty
/dev/pts/1
```







## 交互式接口

交互式接口：启动终端后，在终端设备附加一个交互式应用程序



### 交互式接口类型

- GUI：Graphic User Interface X protocol, window manager, desktop

  GNOME (C, 图形库gtk)

  KDE (C++,图形库qt)

  XFCE (轻量级桌面)



- CLI：Command Line Interface

  Shell程序







### 什么是Shell

Shell 是操作系统（尤其是内核）和用户之间的一个命令解释器/翻译工具，主要负责把人类可读的命令翻译成系统调用或程序执行。

shell也被称为LINUX的命令解释器（command interpreter），Shell 本身是一个程序。将用户输入的命 令行拆解为”命令名“与”参数“。接着，根据命令名找到对应要执行的程序，对被执行的程序进行初始化， 然后将刚才解析出来的参数传给该程序并执行

shell是一种高级程序设计语言，提供了变量，函数，条件判断，循环等开发语言的功能。 

由于Shell本身是个程序，所以它可以被任何用户自己开发的各种Shell所代替。



### 各种Shell

<img src="D:\git_repository\cyber_security_learning\markdown_img\image-20250606181743470-1751936868686-29.png" alt="image-20250606181743470" style="zoom:150%;" />



- sh：Steve Bourne   
- bash：Bourne-Again Shell，GPL，CentOS 和 Ubuntu 默认使用 
- csh：c shell , C 语言风格  
- ksh：Korn Shell, AIX 默认 shell
- zsh： MacOS默认shell



### bash shell

GNU Bourne-Again Shell(bash)是GNU计划中重要的工具软件之一，目前也是 Linux 标准的 shell，与  sh兼容



显示当前使用的 shell

```bash
[root@localhost ~]# echo $SHELL
/bin/bash
```



显示当前系统使用的所有shell

```bash
[root@localhost ~]# cat /etc/shells
/bin/sh
/bin/bash
/usr/bin/sh
/usr/bin/bash
/usr/bin/tmux
/bin/tmux
```





## 登录前提示

``````shell
/etc/issue # 里面的内容会在登录前出现在终端加载页面

vim /etc/issue

##################################################################################
Welcome to the Red Hat training program. Use the following credentials to log in.
Username: your enrollment number
Password: your first name
#################################################################################

``````





## 编辑用户展示公告（登录后提示）

- 概述：

  - /etc/motd 文件的全称是 "Message of the Day"（当日消息）。在Linux和Unix系统中，这个文件的内容会在用户登录到系统后显示在他们的终端上。这为系统管理员提供了一个简单的方法来为登录到系统的用户展示公告、重要消息或任何其他信息。

  - 配置文件

    ``````
    /etc/motd
    ``````

    ``````
    motd网站
    https://www.bootschool.net/ascii-art/search
    ``````

    

- 在VIM中输出彩色字体

  - 步骤：

    ``````
    1. 打开一个新的或现有的 Vim 编辑器：vim filename
    2. 按下 i 进入插入模式。
    3. 按 Ctrl+V 进入 Vim 的特殊字符插入模式。
    4. 接着按 Ctrl+[。这会插入一个 ^[，这实际上是一个转义字符。
    5. 然后直接输入 [32;1m。
    6. 继续输入你的文本，如：Hello, Welcome To My Home - Mystical。
    7. 然后再次按 Ctrl+V 和 Ctrl+[ 插入另一个转义字符。
    8. 接着输入 [0m 来结束彩色输出。
    ``````

  - 示例：

    ``````
    ^[[32;1mHello, Welcome To My Home - Mystical^[[0m
    ``````

    ``````
    ////////////////////////////////////////////////////////////////////
    //                          _ooOoo_                               //
    //                         o8888888o                              //
    //                         88" . "88                              //
    //                         (| ^_^ |)                              //
    //                         O\  =  /O                              //
    //                      ____/`---'\____                           //
    //                    .'  \\|     |//  `.                         //
    //                   /  \\|||  :  |||//  \                        //
    //                  /  _||||| -:- |||||-  \                       //
    //                  |   | \\\  -  /// |   |                       //
    //                  | \_|  ''\---/''  |   |                       //
    //                  \  .-\__  `-`  ___/-. /                       //
    //                ___`. .'  /--.--\  `. . ___                     //
    //              ."" '<  `.___\_<|>_/___.'  >'"".                  //
    //            | | :  `- \`.;`\ _ /`;.`/ - ` : | |                 //
    //            \  \ `-.   \_ __\ /__ _/   .-` /  /                 //
    //      ========`-.____`-.___\_____/___.-`____.-'========         //
    //                           `=---='                              //
    //      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^        //
    //            佛祖保佑       永不宕机     永无BUG                    //
    ////////////////////////////////////////////////////////////////////
    ``````



## Prompt提示符

``````shell
# 格式如下：
PS1="提示符格式命令"

# 格式命令如下：
\[  <提示符样式>  \]  # 这个提示符样式外的\[ \] 可以省略

# 提示符样式如下：
\e[ 样式 + 内容 \e[0m # 以 \e[ 开始，\e[0m 表示关闭设置

# 样式分3部分
格式：F;B;Sm
F: 表示前景色
30 黑色，31 红色，32 绿色，33 黄色，34 蓝色，35 紫色，36 青色，37 白色

B：表示背景色，背景色数值 = F + 10

S：显示的样式如下
0：表示关闭颜色设置
1：表示粗体
4：表示加下划线
5：表示闪烁
7：表示前景色，背景色互换
8：表示隐藏

# 内容：
\u: 表示当前用户
\h: 表示主机名简称
\W: 表示当前工作目录基名
\$: 表示提示符(普通用户$ root用户#) 实测在rocky9不好用
\H: 表示完整主机名
\w: 表示完整工作路径
\t: 表示24小时时间格式为：时：分：秒
\A: 表示24小时时间格式为：时：分
\#: 表示开机命令历史数
\d: 表示日期，格式为：星期 月 日
\v: 表示BASH的版本信息
``````



`````
示例：
PS1="PS1="\e[32;40;1m[\d \t \e[31;40;1m\#] \e[33;40;1m\u@\h:\W \$\e[0m""
注意：
实测\$不好用，可以直接在root的目录下的.bashrc文件中改为#
`````



### CentOS系列

``````bash
# 对所有普通用户生效
vim /etc/profile.d/env.sh  # env.sh自行创建
PS1="\[\e[1;33m\][\u@\h \w] \$\[\e[0m\]"

source env.sh  #使其生效

# 仅对当前用户生效
vim ~/.bashrc
PS1="\[\e[1;33m\][\u@\h \w] \$\[\e[0m\]"
``````



### Ubuntu系列

``````bash
# 对所有普通用户生效
vim /usr/share/bash-completion/bash_completion

# 在文件下方追加
PS1="\[\e[1;33m\][\u@\h \w] \$\[\e[0m\]"

source /usr/share/bash-completion/bash_completion  #使其生效

# 仅对当前用户生效
vim ~/.bashrc
PS1="\[\e[1;33m\][\u@\h \w] \$\[\e[0m\]"
``````







## 会话管理

命令行的典型使用方式是，打开一个终端窗口（terminal window，以下简称"窗口"），在里面输入命令。用户与计算机的这种临时的交互，称为一次"会话"（session）

会话的一个重要特点是，窗口与其中启动的进程是连在一起的。打开窗口，会话开始；关闭窗口，会话结束，会话内部的进程也会随之终止，不管有没有运行完

一个典型的例子就是，SSH 登录远程计算机，打开一个远程窗口执行命令。这时，网络突然断线，再次登录的时候，是找不回上一次执行的命令的。因为上一次 SSH 会话已经终止了，里面的进程也随之消失 了。

为了解决这个问题，会话与窗口可以"解绑"：窗口关闭时，会话并不终止，继续运行，等到以后需要的时候，再让会话"绑定" 其他窗口

终端复用器软件就是会话与窗口的"解绑"工具，将它们彻底分离。



- 它允许在单个窗口中，同时访问多个会话。这对于同时运行多个命令行程序很有用。
- 它可以让新窗口"接入"已经存在的会话。
- 它允许每个会话有多个连接窗口，因此可以多人实时共享会话。
- 它还支持窗口任意的垂直和水平拆分。



类似的终端复用器还有Screen，Tmux



### screen

利用screen 可以实现会话管理,如：新建会话,共享会话等

注意：CentOS7 来自于base源，CentOS8 来自于epel源



范例：安装 screen

```bash
# CentOS7 安装screen
[root@centos7 ~]# yum -y install screen

# CentOS8 安装screen
[root@centos8 ~]# dnf -y install epel-release
[root@centos8 ~]# dnf -y install screen

# ubuntu
[root@ubuntu ~]# apt install screen
```



**命令常见用法**：

```bash
screen -S [SESSION]       # 创建新screen会话
screen -x [SESSION]       # 加入screen会话
screen -r [SESSION]       # 恢复某screen会话
screen -ls                 # 显示所有已经打开的screen会话
Ctrl + a, d               # 剥离当前screen会话
exit                      # 退出并关闭screen会话
```



### tmux

![image-20250708101353256](../../markdown_img/image-20250708101353256.png)

Tmux 是一个终端复用器（terminal multiplexer），类似 screen，但是更易用，也更强大

Tmux 就是会话与窗口的"解绑"工具，将它们彻底分离，功能如下

- 它可以让新窗口"接入"已经存在的会话。它允许在单个窗口中，同时访问多个会话。这对于同时运行多个命令行程序很有用。 
- 它可以让新窗口"接入"已经存在的会话。
- 它允许每个会话有多个连接窗口，因此可以多人实时共享会话。
- 它还支持窗口任意的垂直和水平拆分



#### 安装tmux

```bash
# Rocky
[root@rocky8 ~]# yum install tmux

# Ubuntu
[root@ubuntu2204 ~]# apt update
[root@ubuntu2204 ~]# apt install tmux
```



启动和退出

```bash
[root@ubuntu2204 ~]# tmux

[root@ubuntu2204 ~]# exit
[exited]
```



tmux 窗口有大量的快捷键。所有快捷键都要通过前缀键唤起。默认的前缀键是 **Ctrl+b** ，即先按下  **Ctrl+b** ，快捷键才会生效。帮助命令的快捷键是 Ctrl+b ? 然后，按下 q 键，就可以退出帮助



#### tmux的基本概念

![image-20250708104618323](../../markdown_img/image-20250708104618323.png)



```bat
会话 > 窗口 > 窗格

一个会话可以有多个窗口； 一个窗口可以有多个窗格
```



##### 查看整体结构

```bat
Ctrl + b s       # 查看整体架构
```

![image-20250708105409416](D:\git_repository\cyber_security_learning\markdown_img\image-20250708105409416.png)





#### 会话相关操作

##### 查看会话

```bash
[root@localhost ~]# tmux ls
prac: 2 windows (created Tue Jul  8 10:11:14 2025)
prac2: 1 windows (created Tue Jul  8 10:31:39 2025)
prac3: 1 windows (created Tue Jul  8 10:50:57 2025)
```



##### 创建会话

第一个启动的 Tmux 窗口，编号是0，第二个窗口的编号是1，以此类推。这些窗口对应的会话，就是 0号会话、1号会话。使用编号区分会话，不太直观（当然也可以后续在tmux中更改会话名称），更好的方法是为会话起名。下面命令新建一个指定名称的会话。

```bash
tmux new -s <session-name>
```



##### 更改会话名

```bash
# 进入tmux对应会话后，执行
Ctrl + b  $
```



##### 会话间移动

```bash
Ctrl + b (      # 向前移动
Ctrl + b )      # 向后移动

Ctrl + b s      #  直接在面板选择要选定的会话，然后回车进入
```



##### 分离会话

```bash
Ctrl + b d
```



##### 删除会话

```bash
ot@localhost ~]# tmux ls
prac: 2 windows (created Tue Jul  8 10:11:14 2025)
prac2: 1 windows (created Tue Jul  8 10:31:39 2025)
prac3: 1 windows (created Tue Jul  8 10:50:57 2025)

# 删除会话
[root@localhost ~]# tmux kill-session -t 

[root@localhost ~]# tmux ls
prac: 2 windows (created Tue Jul  8 10:11:14 2025)
prac2: 1 windows (created Tue Jul  8 10:31:39 2025)
```



#### 窗口相关操作

进入会话后，默认有一个窗口

![image-20250708111647939](D:\git_repository\cyber_security_learning\markdown_img\image-20250708111647939.png)



##### 窗口改名

```bash
Ctrl + b ,     # 修改窗口名称
```



##### 创建窗口

```bash
Ctrl + b c   
```



##### 窗口间移动

```bash
Ctrl + b 1|2|3...
```



##### 删除窗口

```bash
Ctrl + b x
```





#### 窗格相关操作

##### 上下切分窗格

```bash
Ctrl + b "
```



##### 左右切分窗格

```bash
Ctrl + b %
```



##### 光标在窗格间移动

```bash
Ctrl + b ;          # 光标切换到上一个窗格
Ctrl + b o          # 光标切换到下一个窗格

Ctrl + b q [num]    # 光标移动到指定窗格
```



##### 更改窗格大小

```bash
Ctrl+b Ctrl+<arrow key>    #按箭头方向调整窗格大小
```



##### 窗格全屏展示

```bash
Ctrl + b z         #当前窗格全屏显示，再使用一次会变回原来大小
```



##### 删除窗格

```bash
Ctrl + b x
```





# 常见信息获取

## 查看用户登录信息

- whoami命令：显示当前登录有效用户
- who命令：显示当前所有的登录会话
- w：显示系统当前所有的登录会话及其所做的操作

``````shell
[Fri Oct 13 22:16:15 59] root@rocky9:/ #w
 22:20:10 up 1 day,  4:39,  2 users,  load average: 0.00, 0.00, 0.00
USER     TTY        LOGIN@   IDLE   JCPU   PCPU WHAT
root     pts/0     21:40    0.00s  0.07s  0.00s w
root     pts/1     21:56    7:22   0.03s  0.01s vim ps_demo.txt
``````



## 操作系统版本

- 查看操作系统版本的配置文件

``````
etc/os-release       # 操作系统详细信息

/etc/redhat-release  # 操作系统版本
``````



## 查看硬件信息

### 查看CPU

``````shell
lscpu

cat /proc/cpuinfo
``````



### 查看内存大小

``````shell
lsmem

free -h
free -h -s 1  # 每秒更新一次内存数据
free -h -c 2  # 总共更新几次，默认一秒一次

cat /proc/meminfo
``````



### 查看硬盘及分区情况

``````shell
lsblk

cat /proc/partitions
``````



## 查看系统版本信息

### 查看系统架构

``````
arch
``````

### 查看内核版本

``````
uname -r
``````

### 查看操作系统发行版本

``````shell
# CentOS
cat /etc/redhat-release

cat /etc/os-release

lsb_release -a

#Ubuntu
cat /etc/os-release

cat /etc/issue
``````



## 显示模式切换

- 查看显示模式

``````
runlevel
``````

- 切换显示模式

``````
init 3 # 切换到字符界面

init 5 # 切换到图形化界面
``````



- 永久切换

``````bash
# 从图形界面 --->  命令行界面
rm -rf /etc/systemd/system/default.target
ln -s /usr/lib/systemd/system/multi-user.target /etc/systemd/system/default.target

# 从命令行界面 --->  图形界面
rm -rf /etc/systemd/system/default.target
ln -s /usr/lib/systemd/system/graphical.target /etc/systemd/system/default.target
``````



## 设置主机名hostname

- 配置文件

``````bash
/etc/hostname   #注意：主机名不要使用下划线
``````

``````bash
# 临时设置主机名
hostname 新主机名
``````

- 通过命令修改hostname配置文件

``````bash
hostnamectl set-hostname ubuntu1804.magedu.org
``````

- 在不重启的情况下，是hostname在prompt上生效，最快的方法是开启一个新的终端会话



## 日期时间

### 系统时间

```bash
date  # 查看系统时间

date -R # 显示时区信息

date +%s  # 显示时间戳（从1970年1月1日到当前时间，经过的秒数）

date +"%F %T" # 时间戳格式化，年月日时分秒

# 输出时间
# -d的基本用法：
# date -d "string"

date -d "yesterday"
date -d "now"
date -d "next friday"
date -d "last month"
date -d "2 weeks ago"

# 格式化输出
date -d "2024-01-01" +"%Y-%m-%d"
date -d "next year" +"%A, %d %B %Y"

# 时间计算
date -d "-3 day" +%F

# 修改时间
# date -s "string"

date -s "-1day"
date -s "-1year"
```



#### 使用date -s 时间修改失败的原因

![image-20250607095505818](D:\git_repository\cyber_security_learning\markdown_img\image-20250607095505818-1751936868686-30.png)

```ABAP
NTP Service: active -->  ubuntu系统上面有时间同步服务
```

关闭时间同步服务

```bash
root@ubuntu24:~# systemctl stop systemd-timesyncd.service
```

![image-20250607095720102](D:\git_repository\cyber_security_learning\markdown_img\image-20250607095720102-1751936868686-31.png)

再次演示

```bash
[root@magedu ~] $date
Thu Jun  5 09:58:14 AM CST 2025
[root@magedu ~] $date -s "-1day"
Wed Jun  4 09:58:17 AM CST 2025
[root@magedu ~] $date
Wed Jun  4 09:58:19 AM CST 2025
```



### 时区命令

命令解读

```basic
查看时区的问题
文件：/etc/localtime、/etc/timezone
命令：timedatectl
```

查看系统支持的时区

```bash
[root@rocky9 ~]# timedatectl list-timezones
Africa/Abidjan
Africa/Accra
...
```

查看当前时区信息

```bash
[root@magedu ~]# timedatectl
               Local time: Sat 2025-06-07 10:04:38 CST
           Universal time: Sat 2025-06-07 02:04:38 UTC
                 RTC time: Sat 2025-06-07 02:04:38
                Time zone: Asia/Shanghai (CST, +0800)
System clock synchronized: yes
              NTP service: active
          RTC in local TZ: no
```

```bash
[root@magedu ~] $ll /etc/localtime 
lrwxrwxrwx 1 root root 33 Jun  7 09:49 /etc/localtime -> /usr/share/zoneinfo/Asia/Shanghai
```

修改时区

```bash
#修改时区
[root@rocky9 ~]# timedatectl set-timezone Asia/Shanghai
```



### 显示日历

```bash
# Ubuntu下载 apt install -y ncal
# Rocky不用下载

[root@magedu ~]# cal
     June 2025        
Su Mo Tu We Th Fr Sa  
 1  2  3  4  5  6  7  
 8  9 10 11 12 13 14  
15 16 17 18 19 20 21  
22 23 24 25 26 27 28  
29 30 

[root@magedu ~]# cal 2 2024 # 显示指定月份日历

[root@magedu ~]# cal 2025    # 显示指定年份的12个月的所有日历
                            2025
      January               February               March          
Su Mo Tu We Th Fr Sa  Su Mo Tu We Th Fr Sa  Su Mo Tu We Th Fr Sa  
          1  2  3  4                     1                     1  
 5  6  7  8  9 10 11   2  3  4  5  6  7  8   2  3  4  5  6  7  8  
12 13 14 15 16 17 18   9 10 11 12 13 14 15   9 10 11 12 13 14 15  
19 20 21 22 23 24 25  16 17 18 19 20 21 22  16 17 18 19 20 21 22  
26 27 28 29 30 31     23 24 25 26 27 28     23 24 25 26 27 28 29  
                                            30 31                 

       April                  May                   June          
Su Mo Tu We Th Fr Sa  Su Mo Tu We Th Fr Sa  Su Mo Tu We Th Fr Sa  
       1  2  3  4  5               1  2  3   1  2  3  4  5  6  7  
 6  7  8  9 10 11 12   4  5  6  7  8  9 10   8  9 10 11 12 13 14  
13 14 15 16 17 18 19  11 12 13 14 15 16 17  15 16 17 18 19 20 21  
20 21 22 23 24 25 26  18 19 20 21 22 23 24  22 23 24 25 26 27 28  
27 28 29 30           25 26 27 28 29 30 31  29 30                 
                                                                  

        July                 August              September        
Su Mo Tu We Th Fr Sa  Su Mo Tu We Th Fr Sa  Su Mo Tu We Th Fr Sa  
       1  2  3  4  5                  1  2      1  2  3  4  5  6  
 6  7  8  9 10 11 12   3  4  5  6  7  8  9   7  8  9 10 11 12 13  
13 14 15 16 17 18 19  10 11 12 13 14 15 16  14 15 16 17 18 19 20  
20 21 22 23 24 25 26  17 18 19 20 21 22 23  21 22 23 24 25 26 27  
27 28 29 30 31        24 25 26 27 28 29 30  28 29 30              
                      31                                          

      October               November              December        
Su Mo Tu We Th Fr Sa  Su Mo Tu We Th Fr Sa  Su Mo Tu We Th Fr Sa  
          1  2  3  4                     1      1  2  3  4  5  6  
 5  6  7  8  9 10 11   2  3  4  5  6  7  8   7  8  9 10 11 12 13  
12 13 14 15 16 17 18   9 10 11 12 13 14 15  14 15 16 17 18 19 20  
19 20 21 22 23 24 25  16 17 18 19 20 21 22  21 22 23 24 25 26 27  
26 27 28 29 30 31     23 24 25 26 27 28 29  28 29 30 31           
                      30
```



## 关机与重启

### 关机

```bash
halt
poweroff
init 0
shutdown -h now
```



### 重启

```bash
reboot
init 6
shutdown -r now
```



### shutdown详解

```bash
shutdown                   # 一分钟后关机
shutdown +10               # 十分钟后关机
shutdown 01:02             # 1点过2分关机
shutdown -r|--reboot       # 一分钟后重启
shutdown -r now            # 现在重启
shutdown -H|--halt         # 一分钟后调用halt关机
shutdown -P|--poweroff     # 一分钟后调用poweroff关机
shutdown -C                # 取消关机计划
```





# 命令分类与执行过程

## shell中可执行的两类命令



### 内部命令

- 内部命令：指集成在特定shell中的命令，当用户登陆时，会自动启用shell，而对应的shell程序中包含一些常见工具。默认的/bin/bash  shell中就集成了很多内部命令，可以通过enable命令查看所有内部命令

- 查看内部命令

  ```bash
  [root@magedu ~]# enable
  enable .
  enable :
  enable [
  enable alias
  enable bg
  enable bind
  enable break
  enable builtin
  enable caller
  enable cd
  enable command
  enable compgen
  enable complete
  enable compopt
  enable continue
  enable declare
  ......
  ```






### 外部命令

- 外部命令

  - 概述：所谓外部命令，就是没有集成在shell程序中。具体表现为一个独立的可执行文件。所以外部命令都能在磁盘中找到对应文件

  - 系统查看外部命令的方式

    - 在系统中有一个叫PATH的变量，里面保存外部命令存放的路径。具体路径可以通过下面命令查看，当执行一个外部命令时， 系统会按PATH中存放的目录路径顺序来查找，一旦在某个目录中找到，就停止继续往下找，并执行此外部命令

    ```bash
    [root@magedu ~]# echo $PATH
    /root/.local/bin:/root/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin
    ```

  - 不同用户的$PATH不同

    ```bash
    # root用户的$PATH路径
    [root@localhost ~]# echo $PATH
    /root/.local/bin:/root/bin:/usr/local/sbin:/sbin:/bin:/usr/sbin:/usr/bin
    
    # magedu用户的$PATH路径
    [magedu@localhost ~]# echo $PATH
    /home/magedu/.local/bin:/home/magedu/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
    ```

    

  - 查看外部命令存放路径

    - which
    - whereis：除了命令外，还显示和命令相关的帮助文档等文件路径

    ```bash
    [root@magedu ~]# which gcc
    /usr/bin/gcc
    
    [root@magedu ~]# whereis gcc
    gcc: /usr/bin/gcc /usr/lib/gcc /usr/libexec/gcc /usr/share/man/man1/gcc.1.gz /usr/share/info/gcc.info.gz
    ```

  - 当第一次执行外部命令后，系统会自动将外部的路径记录到内存缓存区中，下次再执行此外部命令，将会从缓存区中找到路径， 直接到对应的磁盘路径找到此命令并执行。通过hash命令可以查看到已执行过的外部命令及路径

    ```bash
    [root@magedu ~]# hash
    hits	command
       1	/usr/bin/mesg
       1	/usr/bin/vim
    
    ```

  - shell 的 hash 表机制主要用于跟踪和缓存 `$PATH`环境变量指定的目录中找到的命令的位置。非`$PATH`记录的路径下的程序，执行后也不会记录在hash中 







### hash缓存表

系统初始hash表为空，当外部命令执行时，默认会从PATH路径下寻找该命令，找到后会将这条命令的路径记录到hash表中，当再次使用该命令时，shell解释器首先会查看hash表，存在将执行之，如果不存在，将会去PATH路径下寻找，利用hash缓存表可大大提高命令的调用速率。



hash 只对当前用户的当前终端进程有效，是一组**临时数据**；

切换用户后无效；

退出重新登录后会被重置；



hash 命令常见用法

```bash
hash                    # 显示当前终端进程中的 hash 缓存
hash -l                 # 显示详细创建此条 hash 的命令，可作为输入使用
hash -p path name       # 手动创建 hash
hash -t name            # 输出路径
hash -d name            # 删除指定 hash
hash -r                 # 清空所有 hash
```



范例：

```bash
[root@localhost ~]# hash
hits    command
   1    /bin/mesg
   1    /bin/ls
   
[root@localhost ~]# hash -l
builtin hash -p /bin/mesg mesg
builtin hash -p /bin/ls ls

# 手动创建 hash
[root@localhost ~]# builtin hash -p /abc abc
[root@localhost ~]# hash
hits    command
   1    /bin/mesg
   0    /abc
   1    /bin/ls
   
   
# 输出路径
[root@localhost ~]# hash -t ls
/bin/ls


# 删除指定hash
[root@localhost ~]# hash -d ls

# 清空所有hash
[root@localhost ~]# hash -r
```







## 别名

- 概述：所谓别名，就是将一些常用的内部或外部命令，起一个较短的名称，这样每次执行这些常用命令时，就可以用别名替代

- 管理和查看别名

  ```bash
  # 查看所有别名
  $ alias
  
  # 查看指定别名
  $ alias 别名
  
  # 定义别名
  $ alias 别名="命令"
  
  # 取消别名
  $ unlias 别名
  ```

- 上述命令都是使别名临时生效，如果要使别名永久生效，需要写入配置文件(.bashrc)中

  - 仅对当前用户有效，写入 ~/.bashrc
  - 对所有人有效，写入 /etc/.bashrc
  - 启用配置文件：`source 文件名` 或  `. 文件名`

- 执行和别名相同的命令时，需要 `\别名` 或`'别名'` 或 `"别名"` 或 `command 别名`



范例：删除换为移动到垃圾箱

```bash
[root@localhost ~/test]# alias rm
alias rm='time=$(date +%Y-%m-%d-%H:%M:%S); mkdir -p /data/backup/${time}; mv -t /data/backup/${time}'
```







## 指令执行过程

1. 先判断是内部命令还是外部命令

2. 如果是内部命令：直接执行

   如果是外部命令：先去hash里找，是否有该命令记录，如果没有，去PATH路径下找，如果还没有，则报错，command not found；如果找到， 则直接执行，并将可执行文件的路径记录到hash中

3. 如果hash中有该指令路径，但是该指令路径已经转移，即使转移到了PATH路径下，仍然会报错，不存在该文件/目录，此时应清空hash值，重新执行指令

4. 清空hash值的方法

   ```bash
   # 更新（更改）PATH路径：会自动清空hash记录
   bash: hash -r
         hash -d <指定路径>
         hash -l <查看hash表详细数据>
         
   csh：rehash
   ```



### 相关实验

```bash
ls  # 执行ls，并在hash中留有记录
# 将ls转移到其他的$PATH路径下
mv /usr/bin/ls /usr/sbin/

# 执行ls显示失败
[root@mystical /usr/share/bash-completion] $ls
-bash: /usr/sbin/ls: No such file or directory

# 清空hash，则会重新去$PATH找该指令
hash -r

# 在执行即可成功
[root@mystical /usr/share/bash-completion] $ls
bash_completion  completions  helpers
```



### 命令执行优先级

```bat
别名 --> 内部命令 --> hash --> 外部命令
```





### 扩展问题

echo是shell内置命令，但是/usr/bin/echo，也存在独立与shell的外部命令echo，存在这个现象的原因

```basic
独立的非内置的 echo 存在有几个原因，主要是为了提供兼容性、标准化以及在特定情况下的灵活性。以下是一些具体的原因：

1. 标准化和兼容性
POSIX 标准：/usr/bin/echo 程序通常会遵循 POSIX 或其他相关标准，确保在不同的 Unix-like 系统上有一致的行为。
脚本兼容性：在编写可移植的 shell 脚本时，依赖于标准的 /usr/bin/echo 可能比使用特定 shell 的内置 echo 更可靠。

2. 独立于 Shell
不依赖于特定的 shell：独立的 echo 可以在没有启动 shell 的情况下直接执行，这对于某些脚本或系统程序很有用，尤其是在资源有限或需要避免启动完整 shell 会话的环境中。

3. 特定功能的需要
功能差异：不同的 shell 可能会在其内置的 echo 中实现不同的功能或选项。独立的 /usr/bin/echo 程序提供了一个统一的选项集，这可能在跨不同 shell 环境工作时非常有用。

4. 历史原因
遗留系统：在早期的 Unix 系统中，很多现在被认为是内置命令的工具最初是作为独立的程序存在的。随着时间的推移，为了性能和便利性，许多这样的程序被内置到了 shell 中。但是，独立的版本仍然被保留，以保证兼容性和符合标准。
```



### POSIX标准

```basic
POSIX 标准的主要内容包括：

1. 系统调用和库：定义了一系列的 API，包括文件操作、进程控制、线程管理、输入/输出等。

2. Shell 和工具：规定了 shell 的行为和一些基本的命令行工具，如 ls、echo 和 grep 等。

3. 程序编程接口（API）：为 C 语言提供了一套标准的库函数接口，用于实现系统服务。

4. 用户和软件环境：包括了用户环境的配置、软件包管理等方面的标准。

POSIX 标准的意义：

1. 兼容性：POSIX 标准化了 UNIX 系统的核心接口，使得开发者可以编写可在不同 UNIX 系统之间移植的程序。

2. 一致性：通过遵循 POSIX 标准，操作系统厂商可以确保他们的系统提供一致的行为和服务。

3. 可移植性：对于软件开发者来说，POSIX 提供了一套稳定的、不依赖于特定系统的接口，大大提高了代码的可移植性。

4. 在实际应用中，虽然大多数类 UNIX 系统都遵循 POSIX 标准的大部分内容，但很少有系统是完全符合所有 POSIX 规范的。许多系统提供了超出 POSIX 标准的额外功能和扩展，但核心接口和服务通常保持一致。因此，POSIX 标准是理解和使用 UNIX 系统的基础，并且对于确保不同系统之间软件的兼容性和可移植性至关重要。
```





## 命令格式

```bash
COMMAND [OPOTIONS...] [ARGUMENTS...]
COMMAND [COMMAND] [COMMAND] ...

COMMAND     # 命令
OPTIONS     # 选项，用于启用或关闭命令的某个或某些功能
ARGUMENTS   # 参数，命令的作用对象，比如：文件名，用户名等
[]          # 表示里面的内容是可选项，也就是说，一条命令，选项和参数是可以都没有的
...         # 表示可以有多个值，也就是说，一条命令，可以有多个选项，或多个参数
```



选项有多种风格：

- 短选项：UNIX风格选项

  ```bash
  [root@localhost ~]# ls -l -i
  total 12
  33883774 -rw-------. 1 root root  907 Jul  3 11:57 anaconda-ks.cfg
  18528789 drwxr-xr-x. 2 root root    6 Jul  8 09:23 Desktop
  18528790 drwxr-xr-x. 2 root root    6 Jul  8 09:23 Documents
  35582159 drwxr-xr-x. 2 root root    6 Jul  8 09:23 Downloads
  35582160 drwxr-xr-x. 2 root root    6 Jul  8 09:23 Music
  51588157 drwxr-xr-x. 2 root root    6 Jul  8 09:23 Pictures
   3552937 drwxr-xr-x. 2 root root    6 Jul  8 09:23 Public
  51588156 drwxr-xr-x. 2 root root    6 Jul  8 09:23 Templates
  51585325 drwxr-xr-x. 2 root root    6 Jul  8 09:46 test
  34782549 -rw-r--r--. 1 root root  319 Jul  4 12:17 test.sh
  35416137 drwxr-xr-x. 3 root root  109 Jul  4 10:45 tmux-onedark-theme
  35416138 -rw-r--r--. 1 root root 3686 Jul  4 10:42 tmux_seting.sh
   3552939 drwxr-xr-x. 2 root root    6 Jul  8 09:23 Videos
  ```

- 长选项：GNU风格选项

  ```bash
  [root@localhost ~]# which --help
  Usage: /usr/bin/which [options] [--] COMMAND [...]
  Write the full path of COMMAND(s) to standard output.
  
    --version, -[vV] Print version and exit successfully.
    --help,          Print this help and exit successfully.
    --skip-dot       Skip directories in PATH that start with a dot.
    --skip-tilde     Skip directories in PATH that start with a tilde.
    --show-dot       Don't expand a dot to current directory in output.
    --show-tilde     Output a tilde for HOME directory for non-root.
    --tty-only       Stop processing options on the right if not on tty.
    --all, -a        Print all matches in PATH, not just the first
    --read-alias, -i Read list of aliases from stdin.
    --skip-alias     Ignore option --read-alias; don't read stdin.
    --read-functions Read shell functions from stdin.
    --skip-functions Ignore option --read-functions; don't read stdin.
  ```

- BSD风格选项：一个字母，例如a，使用相对较少

  ```bash
  [root@localhost ~]# ps a
      PID TTY      STAT   TIME COMMAND
     2255 tty2     Ssl+   0:00 /usr/libexec/gdm-wayland-session /usr/bin/gnome-sessi
     2264 tty2     Sl+    0:00 /usr/libexec/gnome-session-binary
     3578 tty3     Ss+    0:00 /sbin/agetty -o -- \u --noreset --noclear - linux
     4744 pts/0    Ss     0:00 /bin/bash
     5022 pts/0    S+     0:00 sudo -i
     5026 pts/1    Ss     0:00 sudo -i
     5027 pts/1    S      0:00 -bash
     5080 pts/1    R+     0:00 ps a
     
  [root@localhost ~]# ps --help all
  
  Usage:
   ps [options]
  
  Basic options:
   -A, -e               all processes
   -a                   all with tty, except session leaders
    a                   all with tty, including other users
   -d                   all except session leaders
   -N, --deselect       negate selection
    r                   only running processes
    T                   all processes on this terminal
    x                   processes without controlling ttys
  ```

  







# 字符集和编码及语言环境

许多场合下，字符集与编码这两个概念常被混为一谈，但两者是有差别的。字符集与字符集编码是两个不同层面的概念

charset是character set的简写，即字符集，即二进制和字符的对应关系，不关注最终的存储形式

encoding是charset encoding的简写，即字符集编码，简称编码，实现如何将字符转化为实际的二进制 进行存储，编码决定了空间的使用的大小





<img src="D:\git_repository\cyber_security_learning\markdown_img\image-20250607181801535-1751936868686-32.png" alt="image-20250607181801535" style="zoom:150%;" />



计算机二进制，起源于美国



## ASCII码

计算机内部，所有信息最终都是一个二进制值。上个世纪60年代，美国制定了一套字符编码，对英语字 符与二进制位之间的关系，做了统一规定，即ASCII（American Standard Code for Information   Interchange） 码

ASCII 码一共规定了128个字符的编码，占用了一个字节的后面7位，最前面的一位统一规定为 0



### 查看ASCII表

```bash
[root@localhost ~/test]# yum install -y man-pages

[root@localhost ~/test]# man ascii
AME
       ascii - ASCII character set encoded in octal, decimal, and hexadecimal

DESCRIPTION
       ASCII  is  the  American  Standard Code for Information Interchange.  It is a 7-bit code.  Many 8-bit
       codes (e.g., ISO 8859-1) contain ASCII as their lower half.  The international counterpart  of  ASCII
       is known as ISO 646-IRV.

       The following table contains the 128 ASCII characters.

       C program '\X' escapes are noted.
                                                   │
       Oct   Dec   Hex   Char                      │ Oct   Dec   Hex   Char
       ────────────────────────────────────────────┼───────────────────────────
       000   0     00    NUL '\0' (null character) │ 100   64    40    @
       001   1     01    SOH (start of heading)    │ 101   65    41    A
       002   2     02    STX (start of text)       │ 102   66    42    B
       003   3     03    ETX (end of text)         │ 103   67    43    C
       004   4     04    EOT (end of transmission) │ 104   68    44    D
......
```



## Unicode

由于计算机是美国人发明的，因此，最早只有128个字符被编码到计算机里，即ASCII编码，但是要处理 中文显然一个字节是不够的，至少需要两个字节，而且还不能和ASCII编码冲突，所以，中国制定了  GB2312编码，用来把中文编进去。

全世界有上百种语言，日本把日文编到Shift_JIS里，韩国把韩文编到Euc-kr里，各国有各国的标准，就会 不可避免地出现冲突，结果就是，在多语言混合的文本中，显示出来会有乱码

为了表示世界上所有语言中的所有字符。每一个符号都给予一个独一无二的编码数字，Unicode 是一个 很大的集合，现在的规模可以容纳100多万个符号。Unicode 仅仅只是一个字符集，规定了每个字符对 应的二进制代码，至于这个二进制代码如何存储则没有规定



### Unicode编码方案

- UTF-8：  变长，1到4个字节
- UTF-16：变长，2或4个字节
- UTF-32：固定长度，4个字节

UTF-8 是目前互联网上使用最广泛的一种 Unicode 编码方式，可变长存储。使用 1- 4 个字节表示一个字 符，根据字符的不同变换长度。编码规则如下:

- 对于单个字节的字符，第一位设为 0，后面的 7 位对应这个字符的 Unicode 码。因此，对于英文中的 0  - 127 号字符，与 ASCII 码完全相同。这意味着 ASCII 码的文档可用 UTF-8 编码打
- 对于需要使用 N 个字节来表示的字符（N > 1），第一个字节的前 N 位都设为 1，第 N + 1 位设为0，剩余的 N - 1 个字节的前两位都设为 10，剩下的二进制位则使用这个字符的 Unicode 码来填充



### UTF-8编码流程

以 Unicode 码点编号：“中” 为例

```vb
字符 "中" 在 Unicode 中的编号是：
十进制：20013
十六进制：U+4E2D

```

- U+4E2D = 十进制 20013

- 超过 0x0800，需要 3 字节表示 → UTF-8 格式：`1110xxxx 10xxxxxx 10xxxxxx`

- 填入码点的二进制（0000 0100 1110 0010 1101）→ 取后 16 位 → 填入：

```bash
11100100 10111000 10101101
   E4        B8        AD
```



### UTF-16编码流程

码点在基本多文种平面内（BMP），直接存储 → 就是 `4E 2D`

二进制是：`01001110 00101101`



## 语言环境

默认系统为英文环境，可以修改为中文环境，从而查看帮助或提示可以变为中文

范例：临时修改LANG变量实现中文语言提示

```bash
[root@localhost ~/test]# echo $LANG
en_US.UTF-8             # 英文是en_US.UTF-8

[root@centos7 ~]#magedu
-bash: magedu: command not found

[root@centos7 ~]#LANG=zh_CN.UTF-8

[root@centos7 ~]#echo $LANG
zh_CN.UTF-8

[root@centos7 ~]#magedu
-bash: magedu: 未找到命
```

```bash
[root@localhost ~/test]# localectl list-locales 
C.UTF-8
aa_DJ.UTF-8
aa_ER.UTF-8
aa_ER.UTF-8@saaho
aa_ET.UTF-8
af_ZA.UTF-8
agr_PE.UTF-8
ak_GH.UTF-8
am_ET.UTF-8
an_ES.UTF-8
......

# 如果没有中文包，安装
[root@localhost ~/test]# yum install -y langpacks-zh_CN.noarch

# 通过方法
[root@rocky8 ~]#localectl set-locale LANG=zh_CN.utf8

#或者下面方式,CentOS8支持,但ubuntu和Centos7不支持,不建议使用
[root@rocky8 ~]#localectl set-locale zh_CN.utf8

[root@localhost ~/test]# localectl status
System Locale: LANG=zh_CN.UTF-8
    VC Keymap: us
   X11 Layout: us
   
[root@rocky8 ~]#echo $LANG
 zh_CN.utf8
 
#重新登录后可以看到中文环境
[root@rocky8 ~]#exit
```



范例: Ubuntu 修改语言环境为中文

```bash
[root@ubuntu2204 ~]# localectl status
   System Locale: LANG=en_US.UTF-8
       VC Keymap: n/a
      X11 Layout: us
       X11 Model: pc105
       
[root@ubuntu2204 ~]# apt install language-pack-zh-hans -y

[root@ubuntu2204 ~]# localectl list-locales
C.UTF-8
en_US.UTF-8
zh_CN.UTF-8
zh_SG.UTF-8
......

[root@ubuntu2204 ~]# localectl set-locale LANG=zh_CN.utf8
```





 