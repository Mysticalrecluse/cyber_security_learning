# 1 计算机硬件组成（下）

## 1.1 计算机硬件 主板

### 1.1.1 主板核心参数：供电

<span style="color:red">**思考题，为什么刚买的CPU（AMD Ryzen 9 9950X3D）在不同主板上的性能差距很大**</span>

![image-20250529145912370](D:\git_repository\cyber_security_learning\markdown_img\image-20250529145912370-1751426622682-11.png)

![image-20250529150048154](D:\git_repository\cyber_security_learning\markdown_img\image-20250529150048154-1751426622682-12.png)

![image-20250529150312238](D:\git_repository\cyber_security_learning\markdown_img\image-20250529150312238-1751426622682-13.png)



如上图，供电模块一般位于CPU插槽附近，就是由一个个小方块(**VRM，Voltage Regulator Module，供电模组**)和它周围的电容和芯片组成；**通常高端主板的小方块更多，供电更强**

> VRM（电压调节模块）负责将主板上的 **12V 电压降压为 CPU 所需的 1.xV 电压**，并确保供电稳定、干净、高频率响应。
>
> **上图中红框对应的硬件组成如下：**
>
> | 图中位置                                     | 对应硬件              | 功能                         |
> | -------------------------------------------- | --------------------- | ---------------------------- |
> | 红色“1相~17相”方块                           | 多相供电电感（choke） | 滤波，稳定输出电流，减少纹波 |
> | 每个电感旁边配有 MOSFET + 驱动芯片（未标出） | 高速开关器件          | 实现高频降压（Buck 转换）    |
> | 上方黑色接口（8Pin/8+4Pin）                  |                       |                              |
>
> **所谓“17相供电”是什么意思？**
>
> - 表示这块主板为 CPU 提供了 **17 路独立供电电路（通常指电感+MOS管+PWM控制）**
> - 这样做的目的：
>   - 分担发热
>   - 降低单相负载，提高稳定性
>   - 提升超频或高负载下供电响应能力
>
> **类比：如果说 CPU 是“水龙头”，那这些相就是“17个增压水泵+稳压器”**
>
> **现代主板堆“高相数供电”的原因？**
>
> | 项目                          | 说明                               |
> | ----------------------------- | ---------------------------------- |
> | 高端 CPU 功耗高（动辄 150W+） | 多相可分摊热量、电流压力           |
> | 超频玩家需要供电稳定          | 多相供电能减小电压波动             |
> | 更低纹波、更快响应            | 多相设计+PWM调节可快速响应负载变化 |
>
> 相数越多，供电越稳，越适合高端 CPU 和超频
>
> 主板 VRM 是判断主板好坏的关键之一，特别是对发烧友/工作站来说





![image-20250529150507938](D:\git_repository\cyber_security_learning\markdown_img\image-20250529150507938-1751426622682-14.png)

**整体流程图解释（电力分配链）**

| 类比名词         | 实际硬件        | 电压等级                        | 功能作用                                               |
| ---------------- | --------------- | ------------------------------- | ------------------------------------------------------ |
| 黄河（220V）     | 市电 → 电脑电源 | **220V AC 交流电**              | 提供原始高压能量                                       |
| 自来水（12V）    | 电源输出 → 主板 | **12V / 5V / 3.3V DC 直流电**   | 电源将高压转为设备可用的中低压                         |
| 喷淋系统（1.2V） | 主板供电 → CPU  | **1.2V / 1.0V / 0.9V 动态电压** | 主板上的 **VRM 模块（供电模组）** 进一步稳压，精确供电 |



**电源（Power Supply Unit, PSU）**

- 功能：将 **220V AC（交流电）** 转为多组稳定的 **DC（直流电）输出**。
- 常见输出电压：
  - 12V（供 CPU VRM、GPU）
  - 5V（供 USB 设备）
  - 3.3V（供主板芯片组、内存）



**主板（Motherboard）的作用**

主板是电力的 **二次分配中心和稳压核心**。

🔧 核心部分是 **VRM（Voltage Regulator Module，电压调节模块）**

- VRM 将 12V 电通过 MOSFET 和电感器等电路调节成 **CPU 所需的低电压（如 1.2V）**
- CPU 所需电压很低但电流很大（几十安培），对精度要求极高

主板上的 VRM 由下列组成：

| 模块                 | 作用                        |
| -------------------- | --------------------------- |
| MOSFET（功率晶体管） | 高频开关，将电压“切碎”调制  |
| PWM 控制器           | 控制电压/电流输出频率和时序 |
| 电感（Choke）        | 滤波、平滑电流脉冲          |
| 电容                 | 进一步稳压与能量缓冲        |
| 散热片               | 负责 VRM 发热部分散热       |



 **CPU 的供电要求**

- 现代 CPU 的典型供电电压为 **0.7V ~ 1.4V 动态变化**
- 需精确到 **0.01V**，否则不稳定或直接死机
- 电流高达几十安培，靠主板的 VRM 精确调控



**小知识补充**

- **为什么不直接从电源输出 1.2V？**
  - 因为不同 CPU 电压不同，需要主板**根据 BIOS/微代码动态调节**
  - 电源难以稳定输出这么低压且高精度电流
- **主板好坏一个关键看点就是 VRM 供电质量** 



### 1.1.2 其他主板参数

![image-20250529160504716](D:\git_repository\cyber_security_learning\markdown_img\image-20250529160504716-1751426622682-15.png)



**参数解析**

- **`14 +2 +1` 相增强供电**

  > 表示14相给CPU核心用；2相给CPU核显用；1相给其他辅助电路用

- **DrMOS 80A**

  > DrMOS（Driver MOS）是一种 **高度集成的供电模块**，所以它体积更小、效率更高、发热更低，通常中高端主板更倾向于用 **DrMOS** 来构建 **VRM 模块**
  >
  > **80A** 表示 DrMOS **每相的最大持续供电电流能力**（有些厂商指“峰值”但大多指“额定”）
  >
  > **现代高端 CPU（特别是 AMD 7000 系、Intel K 系）能瞬时拉动 200W+ 的功率**
  >
  > 多相 + 高电流能力 = 电压更稳定、纹波更低
  >
  > 对于：
  >
  > - **超频**
  > - **长时间满载运行（如渲染、科学计算）**
  > - **发烧级硬件平台**
  >
  > DrMOS + 80A 能确保供电系统不崩、不抖、不热炸。
  >
  > ![image-20250529161324373](D:\git_repository\cyber_security_learning\markdown_img\image-20250529161324373-1751426622682-16.png)
  >
  > 上述CPU仅仅烤机几分钟的热成像，供电模组已经达到100多度，温度高就会触发主板的保护机制，降低CPU的供电频率，就会性能下降
  >
  > 因此高端主板都会给供电模块上覆盖一层超厚的金属散热片
  >
  > ![image-20250529161603252](D:\git_repository\cyber_security_learning\markdown_img\image-20250529161603252-1751426622682-17.png)
  >
  > 除了供电模块外，所有的主板都会给芯片组覆盖散热马甲进行散热
  >
  > ![image-20250529161749114](D:\git_repository\cyber_security_learning\markdown_img\image-20250529161749114-1751426622682-18.png)
  >
  > <span style="color:red">**不管再便宜的主板，在芯片组上都会有散热马甲覆**盖</span>
  >
  >  <span style="color:red">**这就说明了芯片组队主板是非常重要的**</span>



### 1.1.3 芯片组（PCH）

<img src="D:\git_repository\cyber_security_learning\markdown_img\image-20250529163619417-1751426622682-19.png" alt="image-20250529163619417" style="zoom:150%;" />

**芯片组（PCH）的本质作用：**

- 芯片组（**Chipset**）是主板上的一个（或多个）专用控制芯片，用来处理 **非核心计算任务的总线管理和设备通信支持**。



**现代芯片组的三大核心功能**

| 功能模块            | 说明                                                     | 举例                             |
| ------------------- | -------------------------------------------------------- | -------------------------------- |
| **通信桥梁**        | 在 CPU 与各类设备（PCIe、USB、SATA、网卡等）之间中转数据 | CPU ⇄ 芯片组 ⇄ SSD、网卡、音频等 |
| **协议/兼容性支持** | 提供对 USB3、SATA、NVMe、PCIe 等协议的电气/逻辑支持      | USB 3.2、PCIe 4.0、SATA AHCI 等  |
| **扩展通道管理**    | 通过芯片组分配非 CPU 直连的 PCIe 通道等资源              | 提供额                           |



#### **1.1.3.1 通信桥梁详解**

上图所示：主板上虽然有很多控制功能的芯片，但严格意义上的“芯片组”指的是 PCH 芯片，是唯一的核心桥接控制器。 其他如音频芯片、网卡芯片、USB 扩展芯片等只是“功能控制器”，它们**通过 PCH 与 CPU 建立间接连接**，不属于芯片组本体。

> **为什么要通过 PCH 中转？**
>
> 原因是：**现代 CPU 只暴露有限数量的高速接口（直连 PCIe/内存）**
>
> - 高速直连（PCIe 5.0/4.0）只保留给：
>   - GPU 插槽
>   - M.2 SSD 插槽
>   - 内存控制器（直接内建于 CPU）
>
> 其他像：
>
> | 外设       | 路径                        |
> | ---------- | --------------------------- |
> | 板载网卡   | 通过 PCH 的 PCIe 通道       |
> | USB 控制器 | 由 PCH 提供                 |
> | 音效芯片   | 接在 PCH 上的 HD Audio 总线 |
> | SATA 硬盘  | PCH 管理的 SATA 控制器      |
>
> 
>
> <span style="color:red">这就是主板上 **PCH 芯片为何重要** —— 它负责“聚合”所有这些低速或中速设备的数据，并统一转发给 CPU。</span>
>
> 
>
> **补充知识点：有些网卡是 CPU 直连的（特殊情况）**
>
> 部分高端主板会这样设计：
>
> | 网卡位置                  | 连接方式                         |
> | ------------------------- | -------------------------------- |
> | 独立 PCIe 网卡            | 插在主 PCIe 插槽，**直连 CPU**   |
> | 主板上的 10G 网卡（高端） | 可能通过 CPU PCIe 通道           |
> | 主板上的千兆网卡          | 大多数走 PCH 提供的 PCIe x1 通道 |









### 1.1.4 BIOS

**主板上的 BIOS（现代称 UEFI BIOS）就是负责在系统启动时，引导和初始化主板上所有关键部件，使它们协调工作，并为操作系统的启动做好准备。**

> **主板 BIOS 就是主板的大脑，在操作系统启动之前，它就负责所有硬件设备的协调和初始化**，包括 CPU、内存、芯片组、外设总线、启动顺序、风扇控制、TPM 安全模块等。

这也是为什么：

- BIOS 出错，整台机器都无法开机（比如内存未初始化，屏幕无显示）
- BIOS 设置错误会导致设备不识别（如 SATA 模式为 RAID，系统就可能无法启动）







## 1.2 计算机硬件 网卡

### 1.2.1 网卡介绍

**网卡是计算机与局域网互联的核心部件**

网卡，又称为网络适配器或网络接口卡**NIC (Network interface Card)**，是构成计算机网络系统中最基本的、最重要的和必不可少的连接设备，计算机主要通过网卡接入网络



**网卡工作内容**

网卡是局域网中连接计算机和传统介质的接口，不仅能实现与局域网传输介质之间的物理连接和电信号匹配，还涉及帧的发送与接收、帧的封装与拆封、介质的访问控制、数据的编码与解码以及数据缓存的功能。



![image-20250530013816213](D:\git_repository\cyber_security_learning\markdown_img\image-20250530013816213-1751426622682-20.png)

### 1.2.2 服务器网卡介绍

**服务器专用网卡 VS 普通网卡**

​    相对于服务器专用网卡来说，普通网卡指应用在普通PC，工作站，消费级电子产品中的网卡，对网卡的可靠性，安全性等要求不高。而服务器与普通PC工作站的不同在于，服务器一直处于工作中，且要求长时间稳定运行，这就要求服务器网卡具有以下特点：

- **数据传输速度快**

  现在是一个数据爆炸的时代，面临海量数据的交互，普通网卡的10Mbps、100Mbps的数据已不满足大数据流量网络，当前服务器常用的网卡速率为10Gbps（即万兆网卡）、25Gpbs、40G、100G等

- **CPU占用率低**

  服务器的CPU是不停工作的，处理着大量的数据。如果一台服务器的大部分时间都在为网卡提供数据响应，势必是影响到其他任务的处理速度。服务器网卡自带的控制芯片，可以处理一些CPU任务，从而减少CPU的计算开销

- **安全性能高**

  如果服务器的网卡出现故障，则服务器将无法接收，发送数据，相当于宕机，所以高可靠性是服务器网卡的一个要求。服务器网卡大都具有容错功能，如intel的AFT（网卡出错冗余），ALB（网卡负载均衡）等技术。







### 1.2.3 网卡分类

**按传播方式分类**： 分为有线网卡和无线网卡

![image-20250530025419014](D:\git_repository\cyber_security_learning\markdown_img\image-20250530025419014-1751426622682-21.png)



**按连接方式分类**：分为集成网卡和独立网卡



![image-20250530030011657](D:\git_repository\cyber_security_learning\markdown_img\image-20250530030011657-1751426622682-22.png)



**按总线接口分类**：分为ISA总线接口网卡（已淘汰）；PCIE总线网卡；USB网卡

![image-20250530030546497](D:\git_repository\cyber_security_learning\markdown_img\image-20250530030546497-1751426622682-23.png)



**按端口类型分类**：RJ-45端口网卡；光端口网卡

![image-20250530030957650](D:\git_repository\cyber_security_learning\markdown_img\image-20250530030957650-1751426622682-24.png)



光端口网卡分为**需要额外来插入光模块**才能接光纤的网卡，和**自带光模块的网卡**。同时还有单模模块和多模模块的区别









## 1.3 计算机硬件 GPU

<span style="color:red">**在运行拥有极致逼真画面的游戏时，显卡每秒需要执行多少次计算？**</span>

每秒执行一亿次运算？

每秒执行一亿次运算仅仅是**1996年的游戏《超级马里奥64》**所需要的运算量

![image-20250530090122922](D:\git_repository\cyber_security_learning\markdown_img\image-20250530090122922-1751426622682-27.png)

**每秒一千亿次运算？**你拥有的电脑可以在**2011年运行《我的世界》**

![image-20250530090222071](D:\git_repository\cyber_security_learning\markdown_img\image-20250530090222071-1751426622682-28.png)

如果你想运行画质逼真的**《赛博朋克2077》**，你需要一块显卡，它每秒能够运行大约**36万亿次运算**

![image-20250530090300337](D:\git_repository\cyber_security_learning\markdown_img\image-20250530090300337-1751426622682-30.png)

想象一下，你每秒做一道长乘法题。（例如：4689732 * 2764569），现在假设地球上的每个人都需要 做类似的计算，但用的数字各不相同，为了达到这块显卡**每秒36万亿次运算**的计算能力，我们**需要大约 4400个住满了地球的人，所有人一起工作，每人每秒完成一次计算**



![image-20250530090355648](D:\git_repository\cyber_security_learning\markdown_img\image-20250530090355648-1751426622682-31.png)

很难想象一个设备能完成所有这些计算，下面我们将了解，为何显卡能做到如此快速的计算，以及显卡 是如何工作的？





### 1.3.1 GPU和CPU的区别

GPU，拥有超过1万个核心（10496 Cores），而CPU仅有24 Cores

<img src="D:\git_repository\cyber_security_learning\markdown_img\image-20250530090942630-1751426622682-32.png" alt="image-20250530090942630" style="zoom:80%;" />

GPU核心数远超CPU，看似GPU理所当然的比CPU强大，但是实际情况要比这复杂的多

如果把GPU想象成一艘巨型游轮，而CPU则是一架大型喷气式飞机，货轮的载货量相当于可以处理的计 算量和数据量，而船或飞机的速度则代表这些计算和数据被处理的速率

本质上，这是一个权衡：大量计算以较慢的速度执行，相较于少量的计算，以极快的速度执行

另一个关键区别是飞机要灵活的多，因为它可以运载乘客，包裹，或者集装箱，而且可以在数以万计的 任何一个机场起降。同样的**CPU也很灵活**，它们可以运行各种各样的程序和指令

![image-20250530091121163](D:\git_repository\cyber_security_learning\markdown_img\image-20250530091121163-1751426622682-33.png)

然后，巨型货轮只能运载货物的集装箱，而且只能在港口之间航行，类似地，GPU比CPU的灵活性要差 得多，它们只能运行简单的指令，比如基本的算术运算。

此外GPU不能运行操作系统，也不能与输入设备或网络交互



**那么GPU和CPU哪一个更快**

这个问题，本质上，如果你想对海量数据运行一系列计算，那么GPU完成任务的速度会更快

然而，如果你需要处理的数据少得多，而且需要快速得到结果，那么CPU会更快。

此外，如果你需要运行操作系统，或支持网络连接，以及各种不同的应用或硬件，那么你需要的会是 CPU







# 2 操作系统概述

## 2.1 Linux 发展历史

### 2.1.1 兼容分时系统Multics：宏达的失败（1964-1969）

![image-20250530100916548](D:\git_repository\cyber_security_learning\markdown_img\image-20250530100916548-1751426622682-65.png)

为了进一步强化大型主机的功能，让主机的资源可以提供更多的使用者来利用，所以在1964年，由贝尔实验室(Bell)，麻省理工学院(MIT)及奇异公司(GE美国通用电气公司)共同发起了Multics（多路信息计算系统）的计划，Multics计划的目的是让大型主机可以同时支持300个以上的终端机连线使用。不过到了1969年前后，由于计划进程缓慢，资金也短缺，所以该计划虽然继续在研究，但最终贝尔实验室还是选择了退出

> 这个失败的项目，反而孕育了一个新纪元。



### 2.1.2 Ken Thompson：为了玩一款游戏，写了一个操作系统（1969）

1966年从加州大学伯克利分校毕业的Ken Thompson加入了贝尔实验室。参与了Multics系统的研发。他基于Multics开发了“star travel”游戏。不幸的是，1969年由于贝尔实验室退出Multics项目，这同时意味着Ken将没有机器可以再玩这个游戏了。面对此情景，Ken作为一个创作者的本性立即体现了出来，于是他决定自己写一个操作系统来满足他玩游戏的需要，Ken找到了一台废弃已久的老式PDP-7，并在这台机器上重写了他的游戏。在这个过程中，Ken有了一个主意，要开发一个全新的操作系统。利用PDP-7上的汇编语言，写出了 Unix 的雏形，被戏称为：

> **UNICS（Uniplexed Information and Computing System）—— Multics 的简化版。**

Ken只花了一个月就编写操作系统的内核，一个月写编辑器，一个月写文件系统。

![image-20250530101009340](D:\git_repository\cyber_security_learning\markdown_img\image-20250530101009340-1751426622682-66.png)



### 2.1.3 Dennis Ritchie 加入：用 C 语言重写 Unix（1973）

Dennis 是 C 语言发明者。

他看了 Unix 后说：

> “汇编太难维护了，我用 C 重写一遍。”

于是 1973 年，第一版 **用 C 语言编写的 Unix 诞生**。

- 可移植性大幅提升  
- 功能迅速扩展  
- Unix 开始在大学与研究机构传播

> 这一年，**Unix 真正诞生**。



### 2.1.4 BSD：大学生将 Unix 变成世界级操作系统（1977）

<img src="D:\git_repository\cyber_security_learning\markdown_img\image-20251217225921245.png" alt="image-20251217225921245" style="zoom:200%;" />

加州伯克利大学（UCB）拿到 Unix 源码后，开始疯狂改进：

- 加入 TCP/IP 网络协议栈
- 引入虚拟内存
- 开发 vi 编辑器、csh shell

形成了著名的：

> **BSD（Berkeley Software Distribution）系 Unix**

BSD 是今天很多系统（如 macOS）的祖先。



### 2.1.5 System V：商业化的 Unix（1979）

<img src="D:\git_repository\cyber_security_learning\markdown_img\image-20251217230014580.png" alt="image-20251217230014580" style="zoom:200%;" />

与此同时，AT&T（Bell 实验室母公司）也决定商业化 Unix：

- 推出了 **System V Release**
- 强调稳定、支持企业和硬件厂商
- 衍生出 HP-UX、AIX、Solaris 等商用 Unix

并且 ——  

>**AT&T 宣布版权收紧，不再向高校提供完整源代码。**

Unix 开始分裂成两个大阵营：

| 分支         | 特点                   |
| ------------ | ---------------------- |
| **BSD**      | 开源精神，技术创新多   |
| **System V** | 商用、企业级、版权严格 |



### 2.1.6 Unix 的问题：越来越封闭（1980 年代初）

<img src="D:\git_repository\cyber_security_learning\markdown_img\image-20251217230056250.png" alt="image-20251217230056250" style="zoom:200%;" />

1970–1980 年代初，Unix 本来是大学和研究机构的宠儿：

- 结构优雅
- 使用 C 语言
- 非常适合教学

但当 AT&T 要将 Unix 商业化后：

- 版权变严格
- 源码不再对学生开放
- 商业分支越来越多（AIX、HP-UX、Solaris）

这让一个 MIT 的程序员非常不爽。

>麻省理工 AI 实验室程序员——**Richard Stallman（RMS）**

Stallman 在 MIT AI 实验室工作，他习惯了“大家共享代码、互相学习”的文化。

但现实却变成了：

> 当你遇到一个 bug，你不能改，它是商业产品。

Stallman 形容当时的处境：

> “程序员失去自由，就像作曲家失去钢琴。”

于是，一个改变计算机世界的计划开始了。



### 2.1.7 GNU 的出现：Stallman 想要重建一个‘人人自由使用的软件世界’（1983）



![image-20250530101246068](D:\git_repository\cyber_security_learning\markdown_img\image-20250530101246068-1751426622682-68.png)



1983 年，Stallman 对外宣布：

🎯 **GNU（GNU’s Not Unix）计划正式开始。**

目标很大胆：

> **重写一个完全自由的 Unix 操作系统。**

为什么不从头设计？  
因为 Unix 的结构太优秀了，所以 GNU 要做：

- 和 Unix 兼容
- 完全自由
- 开源可修改
- 人人可以共享

而 GNU 计划成功的重要原因是：

> ⭐ Stallman 不只是喊口号，他真的做出了关键组件。

例如：

- gcc：世界上最重要的开源编译器
- binutils：汇编器、链接器
- glibc：C 库（所有 C 程序都要用）
- bash：今天 Linux 默认 Shell
- coreutils：ls、mv、cat 等命令

**这些几乎构成了现代 Linux 用户空间的全部基础。**

但 GNU 最大的问题仍然是：❌ **没有内核（Hurd 开发严重落后）**

> Hurd：Hird(Hurd of Interfaces Representing Depth) of Unix-Replacing Daemons richard Stallman 为了无止境寻找完美内核，而忘记了HURD的原本目的：能用的操作系统），开发了30年无疾而终

而这，也为 Linux 诞生留下机会。



### 2.1.8 FSF：为了保护自由，Stallman 建立了一家公司（1985）

1985 年，Stallman 创立：

**FSF（Free Software Foundation，自由软件基金会）**

目的不是挣钱，而是：

- 组织 GNU 项目的开发
- 推动自由软件理念
- 提供法律、版权方面的支持
- 提供硬件、资金赞助

FSF 是一个思想性的组织，它提出四个自由（Four Freedoms）：

> **自由使用、自由学习、自由修改、自由传播。**

这四条自由，构成了自由软件运动的哲学基础。

而为了实现这些自由，他做了一件更重要的事：



### 2.1.9 GPL 的诞生：软件自由的法律武器（1989）

如果软件是自由的，那怎么防止别人把你的代码拿去封闭？

比如：

- 你开源，我拿去改一下变成闭源 commercial 产品 —— 那不是偷劳动成果？

为了避免这种现象，Stallman设计了：

**GPL（GNU General Public License）通用公共许可证**

它是一种 **Copyleft（反版权）机制**：

> “只要你使用 GPL 代码，你必须保持开源。”

换句话说：

- 你可以改
- 你可以卖
- 但你必须把修改公开

这确保了：

> **人人共享 → 人人改进 → 改进不能被垄断**

GPL 成为自由软件运动最重要的武器，也为后面 Linux 的成功奠定法律基础。



### 2.1.10 Linux 的诞生：Linus Torvalds 补上 GNU 最缺的一块拼图（1991）

<img src="D:\git_repository\cyber_security_learning\markdown_img\image-20250530101932286-1751426622682-69.png" alt="image-20250530101932286" style="zoom:150%;" />



1991年的10月5日Linus Benedict Torvalds在comp.os.minix新闻组上发布消息，正式向外宣布他自行编写的完全自由免费的内核诞生（Freeminix-like kernel sources for 386-AT）—FREAX，含义是怪诞的、怪物、异想天开类Unix的内核，在GPL下发布

官方网站：www.kernel.org

最早版本：https://mirrors.edge.kernel.org/pub/linux/kernel/Historic/



#### **Linux的内核版本组成**

- 主版本号
- 次版本号
- 末版本号
- 打包版本号
- 厂商版本号



![image-20250530102340185](D:\git_repository\cyber_security_learning\markdown_img\image-20250530102340185-1751426622682-72.png)



#### Linux 操作系统

完整的类Unix操作系统

Linux内核+GNU工具=Linux/GNU



#### Linux主流反发行版介绍

- slackware：SUSE Linux Enterprise Server (SLES) , OpenSuse桌面

- debian: ubuntu，deepin（深度），mint 

- redhat： RHEL: RedHat Enterprise Linux, 每18个月发行一个新版本 

  ​                 CentOS： **C**ommunity **E**nterprise **O**perating **S**ystem 兼容RHEL的格式 

  ​                 中标麒麟：中标软件 

  ​                 Fedora：每6个月发行一个新版本 

- Alpine： 一个面向安全的轻型 Linux 发行版。它不同于通常 Linux 发行版，Alpine 采用了 musllibc 和 busybox 以减小系统的体积和运行时资源消耗，但功能上比 busybox 又完善的多，只 有5M 左右大小 

- ArchLinux：轻量简洁，遵循K.I.S.S.原则（ keep it simple and stupid ），Manjaro 

- Gentoo：极致性能，不提供传统意义的安装程序，下载源代码在本机上编译安装软件 

- LFS：Linux From scratch 自制Linux，只是一个说明书 

- Android：kernel+busybox（工具集）+java虚拟机



#### **RedHat 红帽公司**

<img src="D:\git_repository\cyber_security_learning\markdown_img\image-20250530102442238-1751426622682-73.png" alt="image-20250530102442238" style="zoom:150%;" />

Marc Ewing早在卡内基梅隆大学读书的时候就戴着他祖父的红色曲球帽. Marc在Marc Ewing大学常把自 己的软件命名为Red Hat — Red hat 1, Red Hat 2 用来区别他人的软件. 所以当他开始自己的Linux项目,  自然就会命名为Red Hat Linux。Ewing非常乐于帮助同学解决计算机问题 “你的朋友可能会说, 去跟我的 朋友Marc交流. 谁是Marc? 他是红帽男孩. ” 所以, 至少在他们最亲密的朋友当中, 红帽子成为了技术专家 的同义词



1993年，Bob Young 建立ACC公司，营销Linux和UNIX的支持软件和书籍杂志 

1995年，Bob Young 收购了Marc Ewing的业务，合并后的ACC公司成为新的Red Hat软件公司，发布 了Red Hat Linux 2.0

 **2018年10月29日**，IBM宣布将以约340亿美元收购开源软件和技术主要供应商红帽公司



#### **CentOS 和 Rockey Linux**

![image-20250530102552478](D:\git_repository\cyber_security_learning\markdown_img\image-20250530102552478-1751426622682-74.png)

**RHEL（Red Hat Enterprise Linux） 红帽企业版Linux**

Red Hat 公司自身的产品中本身就包含了个人版（Red Hat Linux）和企业版 (RHEL) 基于GPL开源协议，不论是Red Hat Linux 还是 Red Hat Enterprise Linux,用户都可以直接从网络 上获取，但是从2003年开始，Red Hat Linux 被新项目（Fedora core）所取代，并且频繁更新，所以几 乎无法在企业环境中使用。 同样基于GPL开源协议，RHEL在发布的时候必须发布源代码，所以无论是二进制的发行版，还是源码，用户都 可以直接免费获取，但是不能在商业化场景中使用，商用必须购买许可（licence），另外Red Hat 公司也 提供技术支持，咨询，解决方案等。



**CentOS （ Community enterprise operating system ） 社区企业操作系统**

就是将 RHEL 发行的源代码从新编译一次，形成一个可使用的二进制版本，RHEL是遵守GPL开源协议的，所 以重新编译是合法。但是得去掉商标，版权信息等。CentOS 可以得到 RHEL 的所有功能，甚至是更好的软 件，但 CentOS 并不向用户提供商业支持，当然也不负上任何商业责任。漏洞修复和软件包升级等，相对于 RHEL的有偿服务来说，也有一定的延时。

**2004年**，Gregory Kurtzer和CentOS的其他创始成员基于开源的RHEL创建了CentOS，将Enterprise Linux引入了社区。

**2014年**，红帽宣布正式赞助CentOS。CentOS的几个核心团队入职Red Hat专门负责其开发。并在Red Hat 在理事会中占了三席，但是其社区属性得到保留，交易结果是一部分包括将CentOS商标和IP转移到Red Hat 以安全保存

CentOS 8于2019年9月交付，紧随RHEL 8之后，CentOS Stream的发布和发布是对下一个次要更新中即将 发布内容预览版本。可以说是RHEL的beta频道。

**2019年**，巨头IBM花重资收购了Red Hat。并承诺Red Hat忠于其开源根基不会改变，声称 Red Hat对开源的 使命和坚定承诺将保持不变。

**2020年12月8日**IBM宣布将惯例支持到2029年CentOS 8，提前在2年内就终结，唯一的升级途径是Centos Stream—AKA，RHEL的Beta发布，并建议不再生产环境中使用。预示着CentOS可能会正式死亡。CentOS已 死，但是CentOS精神将会永存。

随后以CentOS创始人之一Gregory Kurtzer为首，8小时内250人啸聚网络，计划以创建Rocky Linux（Rocky为已经逝世的另外一个CentOS创始人）取代CentOS。Rocky Linux与RHEL兼容目前已经创 建了Github Rocky Linux项目组织（github.com/rocky-linux/rocky）和官网 （rockylinux.org）



![image-20250530102630450](D:\git_repository\cyber_security_learning\markdown_img\image-20250530102630450-1751426622682-75.png)

#### **Debian 和 Ubuntu**

![image-20250530102656315](D:\git_repository\cyber_security_learning\markdown_img\image-20250530102656315-1751426622682-76.png)

Debian 是从 1993 年由 Ian Murdock(伊恩·默多克) 发起的，受到当时 Linux 与 GNU 的鼓舞，目标是成 为一个公开的发行版，经过二十几年的迭代更新Debian 从一个小型紧密的自由软件骇客（hacker）小 组，逐渐成长成今日庞大且运作良好的开发者与用户社群，Debian 的名字是由 Debian 的创始人 Ian  Murdock (伊恩·默多克) 和他的爱妻Debra(黛布拉) 两人的名字组合而成的。



Debian 是由大约一千个分布在世界各地的开发者无偿地利用他们的业余时间开发的，而这些开发者实际 上大部分都没见过面，彼此之间的通讯大多是通过电子邮件（lists.debian.org 上的邮件列表）和 IRC （irc.debian.org 上的#debian 频道）来完成的，目前Debian 提供59000多个软件包的维护与更新。





![image-20250530102727953](D:\git_repository\cyber_security_learning\markdown_img\image-20250530102727953-1751426622682-77.png)

Ubuntu（友帮拓、优般图、乌班图）早期是一个开源的GNU/Linux操作系统，**Ubuntu 是基于Debian  GNU/Linux，支持x86、amd64（即x64）和ppc架构，由全球化的专业开发团队（Canonical Ltd）打 造的**，其名称来自非洲南部祖鲁语或豪萨语的“ubuntu”一词，类似儒家“仁爱”的思想，意思是“人性”、 “我的存在是因为大家的存在”，是非洲传统的一种价值观。



与Debian的不同在于它每6个月会发布一个新版本，Ubuntu的目标在于为一般用户提供一个最新的、同 时又相当稳定的主要由自由软件构建而成的操作系统，Ubuntu具有庞大的社区力量，用户可以方便地从 社区获得帮助，Ubuntu对GNU/Linux的普及特别是桌面普及作出了巨大贡献，由此使更多人共享开源 的成果与精彩



Canonical公司是一个私营公司，由南非的企业家马克·沙特尔沃思(Mark Shuttleworth)创建，主要为了 促进开源软件项目，Canonical在马恩岛登记注册，其雇员分布在世界各地，其主要办事处在伦敦，在蒙 特利尔也有办事处，Canonical公司支持并创建了几个项目，主要都是自由/开源软件（FOSS）或是一些 旨在改善自由软件开发者和贡献者的工具



Ubuntu是各种公有云上最受欢迎的操作系统，这是因为Ubuntu与各大云运营商密切合作，针对云服务 商的基础架构优化内核和系统，加快安全更新速度，并最大限度降低用户默认需要的网络或存储成本。



Ubuntu 没有像其它软件一样有 1.0 版本，是因为其第一个版本是发布于 2004 年，Ubuntu的生日是 2004年的10月20日。



**ubuntu的版本号有个固定的特征，其使用一个形容词和一个动物名称组成，并且形容词和名词的首字母 都是一致的，Ubuntu版本的命名规则是根据正式版发布的年月命名，Ubuntu 16.04 也就意味着 2016 年4月发布的Ubuntu，研发人员与用户可从版本号码就知道正式发布的时间。**



每两年的 4 月份，都会推出一个长期支持版本（LTS），其支持期长达五年，而非 LTS 版本的支持期通常只有半年





## 2.2 Linux 的整体结构 — 五层架构概览



![image-20251217230550942](D:\git_repository\cyber_security_learning\markdown_img\image-20251217230550942.png)



### 2.2.1 用户层（User Space Apps）

这一层是最熟悉的世界：

- 浏览器
- 编辑器
- 开发工具
- 业务程序（Java / Go / Python）
- Docker / kubectl 等 CLI 工具

用户层不会直接接触硬件，也不能直接操作 CPU 或内存。

> 它们只能通过更底层的层次来请求资源。



### 2.2.2 应用程序层（GNU 工具链 / Shell）

这是 Linux 特有的重要一层，由 GNU 项目提供：

- bash、zsh（Shell）
- ls、cat、grep、ps（GNU coreutils）
- gcc、gdb（编译工具链）

这层属于“**用户态工具**”，负责：

- 命令行交互
- 文本处理
- 程序编译

它们本身仍然不能直接操作硬件，而是通过下一层 **系统调用层** 来完成。

>**GNU 工具链 + Linux 内核 = GNU/Linux  
>这个组合就是今天的大多数 Linux 系统（Ubuntu、CentOS）的基础。



### 2.2.3 内核用户接口层（System Call API）

这是“应用程序”与“内核”之间的唯一入口。

比如：

| 用户想做什么 | 需要的系统调用       |
| ------------ | -------------------- |
| 打开文件     | `open()`             |
| 读写数据     | `read()` / `write()` |
| 创建进程     | `fork()`             |
| 创建线程     | `clone()`            |
| 分配内存     | `mmap()`             |

应用程序永远不能直接访问硬件，它必须通过 **系统调用** 请求内核：
```go
用户程序 → 系统调用 API → 内核 → 硬件
```
系统调用是 Linux 安全与隔离的第一道墙。



### 2.2.4 内核资源管理层（Kernel Services Layer）

负责 **资源管理**：

- 进程调度
- 内存分配
- 文件系统
- 网络协议栈（TCP/IP）
- IPC（进程间通信）

应用程序所需的所有资源都由内核统一管理。

资源管理的目标是：

> **将硬件资源分配给每个程序，并保证隔离、安全、高效。**

例子：

- 哪个进程占用 CPU？
- 哪个程序能访问哪块内存？
- 哪个容器使用多少网速？
- 文件操作如何调度磁盘 IO？



### 2.2.5 内核硬件抽象层（Kernel Core Layer）

内核硬件抽象层（Kernel Core Layer）**

负责 **硬件管理**：

- 中断（Interrupt）
- 时钟（Clock）
- 驱动程序（Drivers）
- 原语机制（lock/atomic/spinlock）

这是 Linux 与硬件沟通的基础能力：

> “CPU来一个中断，内核要第一时间响应”

其意义是：

> **把复杂的硬件变成统一接口，让上层不需要关心硬件原理。即（抽象硬件（Hardware Abstraction, HAL））**

例子：

- 程序调用 `read()` 时，不需要懂磁盘驱动
- 程序调用 `send()` 时，不需要懂网卡收发队列
- 程序开启线程时，不需要懂 CPU 调度硬件细节



**总结：Linux 内核两大职责**

职责 1：硬件抽象（Hardware Abstraction）
职责 2：资源管理（Resource Management）**


> **资源管理的前提是硬件抽象。  
> 内核必须先会“和硬件说话”，才能管理程序使用硬件。**

> **内核底层负责“与硬件沟通”，内核上层负责“管理资源”。**  
> 下层是技术手段，上层是管理目标。



### 2.2.6 硬件层（CPU / 内存 / 磁盘 / 网卡）

这是最底层。

Linux 内核通过驱动和中断与硬件通信，硬件把结果返回给内核，再返回给用户态。

因此：硬件抽象 → 资源管理 → 系统调用 → 用户程序 ，这是 Linux 的完整执行链路。



###  问题：当内核把硬件抽象出来之后，它要用什么方式把这些能力提供给用户程序呢？

能不能让应用自己直接访问 CPU？  
> 不能。  

能不能让程序自己控制磁盘硬件？  
>也不能。

所以 Linux 创造了一个非常优雅的统一抽象：

**不管是什么资源，都统一表现为“文件”**

- 键盘是文件
- 网卡是文件
- 磁盘是文件
- 进程信息是文件
- 配置是文件
- 甚至内核本身的信息也是文件

这就是 Linux 最重要的设计哲学：

**“Everything is a File —— 一切皆文件”**

它不仅指字面意义的文件，而是指：

> **所有可以被访问的资源，都通过类文件接口来操作。**

这使得 Linux 从内核到应用层，都拥有了极强的统一性、可扩展性和可编程性。



## 2.3 Linux 的设计哲学 —— 一切皆文件

![image-20251217231104586](D:\git_repository\cyber_security_learning\markdown_img\image-20251217231104586.png)





### 2.3.1 这一哲学的核心思想是什么

一句话：

> **不管底层资源多复杂，都通过文件这个统一接口提供给用户进程。**

文件操作只有五种基本行为：

- 打开（open）
- 读（read）
- 写（write）
- 关闭（close）
- 控制（ioctl）

只要一个资源能通过这套接口控制，它就被视为“文件”。

这让 Linux **极其简单、优雅**：

- 用户程序不需要学习不同 API
- 要操作设备 = 读写文件
- 要获取系统信息 = 读文件
- 要配置系统 = 编辑文件

比如：

| 资源       | 在系统中的文件形式     |
| ---------- | ---------------------- |
| 磁盘       | `/dev/sda`             |
| 内存信息   | `/proc/meminfo`        |
| CPU 信息   | `/proc/cpuinfo`        |
| 网络设备   | `/sys/class/net/eth0/` |
| 随机数设备 | `/dev/random`          |
| 内核开关   | `/proc/sys/*`          |

所有系统资源都被文件化。



### 2.3.2 “一切皆文件” 为什么能成立？（硬件抽象 → 文件接口）

 **① 硬件很复杂（驱动负责控制）**

- 磁盘有不同品牌、协议、控制器
- 网卡有 DMA、Ring Buffer、队列
- 键盘、鼠标、摄像头差别巨大

应用程序无法直接操作它们。



**② 内核通过驱动程序屏蔽硬件差异**

驱动负责：

- 初始化硬件
- 处理中断
- 读写寄存器
- 内存映射

让复杂的硬件变成一个内核内部对象。



**③ 内核把这些对象“挂接”为文件节点（inode）**

比如磁盘：
```go
/dev/sda  ← 设备驱动向 VFS 注册的文件节点
```
比如内核信息：
```go
/proc/cpuinfo  ← 内核的虚拟文件系统
```


**④ 用户进程只需要 read/write 就能操作资源**

```go
echo 1 > /proc/sys/net/ipv4/ip_forward
```
背后发生的逻辑是：

- 用户写入文件
- 内核拦截
- 驱动执行真正的硬件操作

应用永远不需要懂硬件。



### 2.3.3 这个设计有什么意义？

**意义 1：统一性**

无论资源是什么，都用同一种方式操作。

程序不需要重新学习。



**意义 2：可组合性（可用于自动化）**

因为是文件：
```go
cat /proc/cpuinfo | grep model
echo 1024 > /sys/block/sda/queue/read_ahead_kb
```
→ **shell 管道和自动化工具可以天然处理系统资源**

这就是为什么 Linux 的自动化能力如此强。



**意义 3：稳定性（接口不会变）**

硬件可以更新  
驱动可以变化  
但文件接口（read/write）从 1970 年到今天不变

→ Linux 系统保持数十年兼容。



**意义 4：易于调试**

程序员能直接查看内核状态：
```bat
cat /proc/meminfo
cat /proc/interrupts
```
不用任何调试工具。



### 2.3.4 从硬件抽象到一切皆文件的逻辑

最终在学生脑中形成一条清晰链路：
```bat
硬件 → 驱动 → 内核对象 → 虚拟文件节点 → 用户程序 read/write
```
再总结一句话：

> Linux 的强大不是因为文件多，而是因为它把整个世界都变成了“文件”这种统一的接口。





# 3 Linux安装

## 3.1 环境准备

### 3.1.1 VMware Workstation虚拟机软件安装

#### 3.1.1.1 VMware Workstation的下载

**软件检索**

```http
https://www.broadcom.com/
```

注册登录BROADCOM官网**（未注册用户，一定要注册才能下载）**

![image-20250528152516751](D:\git_repository\cyber_security_learning\markdown_img\image-20250528152516751-1751426622682-81.png)

**注册后登录用户**

进入到 个人的 专属软件下载页面  https://support.broadcom.com/group/ecx/productdownloads  【最好专门复制链接进入，查找很繁琐】，点击左边栏的 My Downloads

![image-20250528153352810](D:\git_repository\cyber_security_learning\markdown_img\image-20250528153352810-1751426622682-82.png)

在搜索框输入`vmware workstation`，点击`Show Results`搜索，点击搜索出来的`VMware Workstation Pro`

![image-20250528153612338](D:\git_repository\cyber_security_learning\markdown_img\image-20250528153612338-1751426622682-83.png)

根据操作系统选择要下载的安装包（相信大部分人都是Windows），并选择需要的版本

![image-20250528153935220](D:\git_repository\cyber_security_learning\markdown_img\image-20250528153935220-1751426622682-84.png)

注意：默认情况下，需要勾选 "I agree to xxx" 选项，才可以点击 产品条目右侧的下载选项

![image-20250528154246990](D:\git_repository\cyber_security_learning\markdown_img\image-20250528154246990-1751426622682-85.png)

下载安装包之前，会要求填写个人信息，填写完个人信息后，即可下载`VMware workstation pro`安装包



####  3.1.1.2 VMware Workstation的安装步骤

查看下载的软件

![image-20250528155033460](D:\git_repository\cyber_security_learning\markdown_img\image-20250528155033460-1751426622682-86.png)

双击要下载版本的安装包，进入安装向导界面

![image-20250528155144104](D:\git_repository\cyber_security_learning\markdown_img\image-20250528155144104-1751426622682-87.png)

兼容设置

```ABAP
建议勾选自动安装 WHP
```

> **为什么 VMware Workstation 需要 WHP？**
>
> 从 Windows 10 1803（2018年）开始，如果你启用了：
>
> - Hyper-V
> - Windows Sandbox
> - Device Guard / Credential Guard
> - WSL 2
>
> 这些功能都会启动 **Hyper-V 核心层**，从而导致 VMware 的传统虚拟化方式（基于 VT-x/EPT）**无法直接使用硬件虚拟化**，提示 "VMware and Hyper-V are not compatible"。
>
> 因此：
>
> > **WHP 是 VMware 为了解决与 Hyper-V 冲突而提供的兼容方案**。
>
> 它允许 VMware 在 Hyper-V 层之上运行虚拟机，虽然性能稍差，但保证能用。



选择安装位置

```ABAP
选择VMware Workstation的安装目录。默认位置通常在C盘，但建议更改到其他磁盘以节省C盘空间。点击“更改”按钮，选择新的安装位置，然后点击“确定”。
```

![image-20250528155744663](D:\git_repository\cyber_security_learning\markdown_img\image-20250528155744663-1751426622682-88.png)

后续下一步---> 下一步... 直至安装成功。

```ABAP
安装完成后，系统会提示输入许可证密钥。可以在官网或其他可靠来源获取有效的密钥。将密钥复制到输入框中，并点击“下一步”完成许可证验证。
```

```ABAP
关于序列号，可以从互联网上去检索，下面给了几个，如果不管用的话，重新去互联网上检索即可。
JU090-6039P-08409-8J0QH-2YR7F
ZF3R0-FHED2-M80TY-8QYGC-NPKYF
FC7D0-D1YDL-M8DXZ-CYPZE-P2AY6
ZC3TK-63GE6-481JY-WWW5T-Z7ATA
```



### 3.1.2 虚拟机网络环境准备

#### 3.1.2.1 虚拟网络服务

安装完成vmware Workstation之后，会在windows的服务管理中，存在几个相关的服务

`Windows键 + R`在运行中输入 `services.msc`，进入服务管理，（如果相关服务未开启）开启相关服务

![image-20250528162104223](D:\git_repository\cyber_security_learning\markdown_img\image-20250528162104223-1751426622682-89.png)

vmware服务启动之后，会开启两个虚拟网卡

![image-20250528162901552](D:\git_repository\cyber_security_learning\markdown_img\image-20250528162901552-1751426622682-90.png)

```ABAP
如果没有相关虚拟网卡（或者设备管理器上有，但是显示黄色感叹号）,如果出现上述情况，恭喜中奖，建议重置此电脑，或重装系统
```



#### 3.1.2.2  网络环境定制

VMware Workstation是一款功能强大的桌面虚拟计算机软件，它提供了三种主要的网络模式，以满 足不同用户的需求。

```ABAP
对于这三种网络模式，后续学完网络会详解，现阶段按图例完成配置修改即可
```

进入虚拟网络编辑器

![image-20250528163719971](D:\git_repository\cyber_security_learning\markdown_img\image-20250528163719971-1751426622682-91.png)

修改仅主机网络环境的网段为 192.168.23.0，修改NAT网络环境网段为 10.0.0.0 （要修改网络配置，需要管理员权限）

![image-20250528163917374](D:\git_repository\cyber_security_learning\markdown_img\image-20250528163917374-1751426622682-92.png)

修改**仅主机**网络，按下方图例更改

![image-20250528165500936](D:\git_repository\cyber_security_learning\markdown_img\image-20250528165500936.png)



修改**NAT模式**网络，按下方图例更改

![image-20250528165250417](D:\git_repository\cyber_security_learning\markdown_img\image-20250528165250417-1751426622682-93.png)



## 3.2 Rocky安装

### 3.2.1 VM配置

点击左上角“文件”，在下拉中选择第一项"新建虚拟机"；

后续按下列图例，依次操作即可

![image-20250528173701673](D:\git_repository\cyber_security_learning\markdown_img\image-20250528173701673-1751426622682-94.png)

![image-20250528173923836](D:\git_repository\cyber_security_learning\markdown_img\image-20250528173923836-1751426622682-95.png)

![image-20250528174305845](D:\git_repository\cyber_security_learning\markdown_img\image-20250528174305845-1751426622682-96.png)

![image-20250528174430437](D:\git_repository\cyber_security_learning\markdown_img\image-20250528174430437-1751426622682-97.png)

![image-20250528174555879](D:\git_repository\cyber_security_learning\markdown_img\image-20250528174555879-1751426622682-98.png)

![image-20250528174657976](D:\git_repository\cyber_security_learning\markdown_img\image-20250528174657976-1751426622682-99.png)

![image-20250528174840703](D:\git_repository\cyber_security_learning\markdown_img\image-20250528174840703-1751426622682-100.png)

![image-20250528175031763](D:\git_repository\cyber_security_learning\markdown_img\image-20250528175031763-1751426622683-101.png)



### 3.2.2 系统安装

![image-20250528175330519](D:\git_repository\cyber_security_learning\markdown_img\image-20250528175330519-1751426622683-102.png)

![image-20250528175448687](D:\git_repository\cyber_security_learning\markdown_img\image-20250528175448687-1751426622683-103.png)

![image-20250528175634938](D:\git_repository\cyber_security_learning\markdown_img\image-20250528175634938-1751426622683-104.png)

![image-20250528175810758](D:\git_repository\cyber_security_learning\markdown_img\image-20250528175810758-1751426622683-105.png)

![image-20250528175948707](D:\git_repository\cyber_security_learning\markdown_img\image-20250528175948707-1751426622683-141.png)

![image-20250528180050466](D:\git_repository\cyber_security_learning\markdown_img\image-20250528180050466-1751426622683-106.png)

**安装成功后重启即可**



### 3.2.3 安装VMtools

在 Rocky Linux 9.4 桌面版中，系统默认自带了 `open-vm-tools` 和 `open-vm-tools-desktop`，无需手动安装即可使用剪贴板、拖放等功能。



## 3.3 Ubuntu安装

### 3.3.1 VM创建

点击左上角“文件”，在下拉中选择第一项"新建虚拟机"；

后续按下列图例，依次操作即可

![image-20250528173701673](D:\git_repository\cyber_security_learning\markdown_img\image-20250528173701673-1751426622682-94.png)

![image-20250528173923836](D:\git_repository\cyber_security_learning\markdown_img\image-20250528173923836-1751426622682-95.png)

![image-20250529001829361](D:\git_repository\cyber_security_learning\markdown_img\image-20250529001829361-1751426622683-107.png)

![image-20250529002021338](D:\git_repository\cyber_security_learning\markdown_img\image-20250529002021338-1751426622683-108.png)

![image-20250529002238085](D:\git_repository\cyber_security_learning\markdown_img\image-20250529002238085-1751426622683-109.png)

![image-20250529002410149](D:\git_repository\cyber_security_learning\markdown_img\image-20250529002410149-1751426622683-110.png)

![image-20250529002612743](D:\git_repository\cyber_security_learning\markdown_img\image-20250529002612743-1751426622683-111.png)

![image-20250529002823598](D:\git_repository\cyber_security_learning\markdown_img\image-20250529002823598-1751426622683-112.png)

![image-20250529004009893](D:\git_repository\cyber_security_learning\markdown_img\image-20250529004009893-1751426622683-113.png)

**“虚拟化引擎下三个选项含义与作用**

| 选项                                 | 全称                            | 作用                                               | 默认是否需要勾选             | 适用场景                                 |
| ------------------------------------ | ------------------------------- | -------------------------------------------------- | ---------------------------- | ---------------------------------------- |
| ✅ 虚拟化 Intel VT-x/EPT 或 AMD-V/RVI | **硬件辅助虚拟化**              | 允许虚拟机启用嵌套虚拟化（即虚拟机中再运行虚拟机） | ❌ 默认关闭，但很多功能依赖它 | 安装 KVM、ESXi、Docker（部分内核）等场景 |
| ✅ 虚拟化 CPU 性能计数器              | **Expose Performance Counters** | 允许虚拟机访问主机的性能计数器（如 PMU）           | ❌ 仅用于性能分析和低级优化   | 使用 `perf`、`vtune`、BPF 等性能工具     |
| ✅ 虚拟化 IOMMU（IO 内存管理单元）    | **Intel VT-d / AMD-Vi**         | 提供更精细的设备访问控制（如 PCIe 直通）           | ❌ 很少需要                   | 需要 SR-IOV、设备直通、虚拟化安全研究等  |

![image-20250529005146062](D:\git_repository\cyber_security_learning\markdown_img\image-20250529005146062-1751426622683-114.png)



### 3.3.2 系统安装

![image-20250529005730705](D:\git_repository\cyber_security_learning\markdown_img\image-20250529005730705-1751426622683-115.png)

![image-20250529005900084](D:\git_repository\cyber_security_learning\markdown_img\image-20250529005900084-1751426622683-116.png)

![image-20250529010046547](D:\git_repository\cyber_security_learning\markdown_img\image-20250529010046547-1751426622683-117.png)

![image-20250529010209710](D:\git_repository\cyber_security_learning\markdown_img\image-20250529010209710-1751426622683-118.png)

![image-20250529010423955](D:\git_repository\cyber_security_learning\markdown_img\image-20250529010423955-1751426622683-119.png)

![image-20250529010817169](D:\git_repository\cyber_security_learning\markdown_img\image-20250529010817169-1751426622683-120.png)

![image-20250529011010747](D:\git_repository\cyber_security_learning\markdown_img\image-20250529011010747-1751426622683-121.png)

![image-20250529011123394](D:\git_repository\cyber_security_learning\markdown_img\image-20250529011123394-1751426622683-122.png)

![image-20250529013127098](D:\git_repository\cyber_security_learning\markdown_img\image-20250529013127098-1751426622683-123.png)

**安装成功后重启即可**



### 3.3.3 图形界面不兼容解决方案

由于Ubuntu2404兼容性极差，所以如果图形界面假死，黑屏，卡死，解决不掉，建议部署server版本，然后在server版本基础上安装轻量级图形界面。

#### 3.3.3.1 VM创建

VM配置如2.3.1



#### 3.3.3.2 系统安装

![image-20250529021640541](D:\git_repository\cyber_security_learning\markdown_img\image-20250529021640541-1751426622683-124.png)

![image-20250529021732568](D:\git_repository\cyber_security_learning\markdown_img\image-20250529021732568-1751426622683-125.png)

![image-20250529021825456](D:\git_repository\cyber_security_learning\markdown_img\image-20250529021825456-1751426622683-126.png)

![image-20250529021855179](D:\git_repository\cyber_security_learning\markdown_img\image-20250529021855179-1751426622683-127.png)

**要选择指定选项 — 按空格**

**切换选项 — 按Tab键**

![image-20250529021942858](D:\git_repository\cyber_security_learning\markdown_img\image-20250529021942858-1751426622683-128.png)

![image-20250529022141714](D:\git_repository\cyber_security_learning\markdown_img\image-20250529022141714-1751426622683-129.png)

![image-20250529022219539](D:\git_repository\cyber_security_learning\markdown_img\image-20250529022219539-1751426622683-130.png)

![image-20250529022258447](D:\git_repository\cyber_security_learning\markdown_img\image-20250529022258447-1751426622683-131.png)

![image-20250529022354949](D:\git_repository\cyber_security_learning\markdown_img\image-20250529022354949-1751426622683-132.png)

![image-20250529022423007](D:\git_repository\cyber_security_learning\markdown_img\image-20250529022423007-1751426622683-133.png)

![image-20250529022455156](D:\git_repository\cyber_security_learning\markdown_img\image-20250529022455156-1751426622683-134.png)

![image-20250529022607913](D:\git_repository\cyber_security_learning\markdown_img\image-20250529022607913-1751426622683-135.png)

![image-20250529022648002](D:\git_repository\cyber_security_learning\markdown_img\image-20250529022648002-1751426622683-136.png)

![image-20250529022719734](D:\git_repository\cyber_security_learning\markdown_img\image-20250529022719734-1751426622683-137.png)

![image-20250529023059839](D:\git_repository\cyber_security_learning\markdown_img\image-20250529023059839-1751426622683-138.png)

![image-20250529023153890](D:\git_repository\cyber_security_learning\markdown_img\image-20250529023153890-1751426622683-140.png)

![image-20250529023327093](D:\git_repository\cyber_security_learning\markdown_img\image-20250529023327093-1751426622683-139.png)



#### 3.3.3.3 轻量级桌面版安装

![image-20250529023532311](D:\git_repository\cyber_security_learning\markdown_img\image-20250529023532311-1751426622683-142.png)

![image-20250529024137600](D:\git_repository\cyber_security_learning\markdown_img\image-20250529024137600-1751426622683-143.png)

```bash
# 切换root用户
sudo -i

# 输入密码后回车

# 执行下面指令
apt update && apt install xubuntu-desktop -y

# 安装桌面的过程请耐心等待
```

![image-20250529025444933](D:\git_repository\cyber_security_learning\markdown_img\image-20250529025444933-1751426622683-144.png)



安装成功之后重启

```bash
reboot
```

![image-20250529032105085](D:\git_repository\cyber_security_learning\markdown_img\image-20250529032105085.png)





### 3.3.3 安装Vmtools

#### 3.3.3.1 vmtools简介

默认情况下，登录后的ubuntu桌面展示效果和VMWare平台框之间有一圈黑色的背景，在这种模式下， 主要表现样式是 ubuntu桌面不会自动随着窗口大小调整而自动调整，而且windows主机和ubuntu主 机，还没有实现无缝的数据切换 -- 粘贴复制。



#### 3.3.3.1 vmtools安装

![image-20250529032607267](D:\git_repository\cyber_security_learning\markdown_img\image-20250529032607267-1751426622683-145.png)

![image-20250529032929226](D:\git_repository\cyber_security_learning\markdown_img\image-20250529032929226-1751426622683-146.png)

```bash
apt install -y open-vm-tools-desktop
```

重启后，桌面拉伸到全屏，即为成功，此时可以使用剪贴板进行复制粘贴

![image-20250529033344394](D:\git_repository\cyber_security_learning\markdown_img\image-20250529033344394-1751426622683-147.png)





## 3.4 openEuler安装

### 3.4.1 安装系统

参看2.2节内容

```ABAP
主要的区别：密码设定的时候，比较繁琐和复杂
```



### 3.4.2 注意事项

安装完毕openeuler之后，可以看到有三个网卡

```bash
[root@openeuler-14 ~]# ip a
1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN group 
default qlen 1000
     link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
     inet 127.0.0.1/8 scope host lo
        valid_lft forever preferred_lft forever
     inet6 ::1/128 scope host noprefixroute
        valid_lft forever preferred_lft forever
2: ens33: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc fq_codel state UP 
group default qlen 1000
     link/ether 00:0c:29:ef:3f:ab brd ff:ff:ff:ff:ff:ff
     inet 10.0.0.14/24 brd 10.0.0.255 scope global noprefixroute ens33
        valid_lft forever preferred_lft forever
     inet6 fe80::20c:29ff:feef:3fab/64 scope link noprefixroute
        valid_lft forever preferred_lft forever
3: virbr0: <NO-CARRIER,BROADCAST,MULTICAST,UP> mtu 1500 qdisc noqueue state DOWN 
group default qlen 1000
     link/ether 52:54:00:62:3b:6b brd ff:ff:ff:ff:ff:ff
     inet 192.168.122.1/24 brd 192.168.122.255 scope global virbr0
       valid_lft forever preferred_lft forever
```

virbr0网卡通常是由于系统中安装了虚拟化相关服务（如libvirt）并默认启用了虚拟网络桥接功能所导致 的。我们可以通过如下方法来解决它

```bash
# 查看服务状态
[root@openeuler-14 ~]# systemctl is-enabled libvirtd
enabled
```

```bash
# 关闭服务，同时关闭开机自启动
[root@openeuler-14 ~]# systemctl disable --now libvirt
```

```bash
# 重启主机
[root@openeuler-14 ~]# reboot
```

重启主机之后，再次查看网卡

```bash
[root@openeuler-14 ~]# ip a
1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN group 
default qlen 1000
     link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
     inet 127.0.0.1/8 scope host lo
        valid_lft forever preferred_lft forever
     inet6 ::1/128 scope host noprefixroute
        valid_lft forever preferred_lft forever
2: ens33: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc fq_codel state UP 
group default qlen 1000
     link/ether 00:0c:29:ef:3f:ab brd ff:ff:ff:ff:ff:ff
     inet 10.0.0.14/24 brd 10.0.0.255 scope global noprefixroute ens33
        valid_lft forever preferred_lft forever
     inet6 fe80::20c:29ff:feef:3fab/64 scope link noprefixroute
        valid_lft forever preferred_lft forever
```







