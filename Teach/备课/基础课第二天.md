# 1 计算机硬件组成（下）

## 1.1 计算机硬件 主板

### 1.1.1 主板核心参数：供电

<span style="color:red">**思考题，为什么刚买的CPU（AMD Ryzen 9 9950X3D）在不同主板上的性能差距很大**</span>

![image-20250529145912370](D:\git_repository\cyber_security_learning\markdown_img\image-20250529145912370-1751426622682-11.png)

![image-20250529150048154](D:\git_repository\cyber_security_learning\markdown_img\image-20250529150048154-1751426622682-12.png)

![image-20250529150312238](D:\git_repository\cyber_security_learning\markdown_img\image-20250529150312238-1751426622682-13.png)



如上图，供电模块一般位于CPU插槽附近，就是由一个个小方块(**VRM，Voltage Regulator Module，供电模组**)和它周围的电容和芯片组成；**通常高端主板的小方块更多，供电更强**

> VRM（电压调节模块）负责将主板上的 **12V 电压降压为 CPU 所需的 1.xV 电压**，并确保供电稳定、干净、高频率响应。
>
> **上图中红框对应的硬件组成如下：**
>
> | 图中位置                                     | 对应硬件              | 功能                         |
> | -------------------------------------------- | --------------------- | ---------------------------- |
> | 红色“1相~17相”方块                           | 多相供电电感（choke） | 滤波，稳定输出电流，减少纹波 |
> | 每个电感旁边配有 MOSFET + 驱动芯片（未标出） | 高速开关器件          | 实现高频降压（Buck 转换）    |
> | 上方黑色接口（8Pin/8+4Pin）                  |                       |                              |
>
> **所谓“17相供电”是什么意思？**
>
> - 表示这块主板为 CPU 提供了 **17 路独立供电电路（通常指电感+MOS管+PWM控制）**
> - 这样做的目的：
>   - 分担发热
>   - 降低单相负载，提高稳定性
>   - 提升超频或高负载下供电响应能力
>
> **类比：如果说 CPU 是“水龙头”，那这些相就是“17个增压水泵+稳压器”**
>
> **现代主板堆“高相数供电”的原因？**
>
> | 项目                          | 说明                               |
> | ----------------------------- | ---------------------------------- |
> | 高端 CPU 功耗高（动辄 150W+） | 多相可分摊热量、电流压力           |
> | 超频玩家需要供电稳定          | 多相供电能减小电压波动             |
> | 更低纹波、更快响应            | 多相设计+PWM调节可快速响应负载变化 |
>
> 相数越多，供电越稳，越适合高端 CPU 和超频
>
> 主板 VRM 是判断主板好坏的关键之一，特别是对发烧友/工作站来说





![image-20250529150507938](D:\git_repository\cyber_security_learning\markdown_img\image-20250529150507938-1751426622682-14.png)

**整体流程图解释（电力分配链）**

| 类比名词         | 实际硬件        | 电压等级                        | 功能作用                                               |
| ---------------- | --------------- | ------------------------------- | ------------------------------------------------------ |
| 黄河（220V）     | 市电 → 电脑电源 | **220V AC 交流电**              | 提供原始高压能量                                       |
| 自来水（12V）    | 电源输出 → 主板 | **12V / 5V / 3.3V DC 直流电**   | 电源将高压转为设备可用的中低压                         |
| 喷淋系统（1.2V） | 主板供电 → CPU  | **1.2V / 1.0V / 0.9V 动态电压** | 主板上的 **VRM 模块（供电模组）** 进一步稳压，精确供电 |



**电源（Power Supply Unit, PSU）**

- 功能：将 **220V AC（交流电）** 转为多组稳定的 **DC（直流电）输出**。
- 常见输出电压：
  - 12V（供 CPU VRM、GPU）
  - 5V（供 USB 设备）
  - 3.3V（供主板芯片组、内存）



**主板（Motherboard）的作用**

主板是电力的 **二次分配中心和稳压核心**。

🔧 核心部分是 **VRM（Voltage Regulator Module，电压调节模块）**

- VRM 将 12V 电通过 MOSFET 和电感器等电路调节成 **CPU 所需的低电压（如 1.2V）**
- CPU 所需电压很低但电流很大（几十安培），对精度要求极高

主板上的 VRM 由下列组成：

| 模块                 | 作用                        |
| -------------------- | --------------------------- |
| MOSFET（功率晶体管） | 高频开关，将电压“切碎”调制  |
| PWM 控制器           | 控制电压/电流输出频率和时序 |
| 电感（Choke）        | 滤波、平滑电流脉冲          |
| 电容                 | 进一步稳压与能量缓冲        |
| 散热片               | 负责 VRM 发热部分散热       |



 **CPU 的供电要求**

- 现代 CPU 的典型供电电压为 **0.7V ~ 1.4V 动态变化**
- 需精确到 **0.01V**，否则不稳定或直接死机
- 电流高达几十安培，靠主板的 VRM 精确调控



**小知识补充**

- **为什么不直接从电源输出 1.2V？**
  - 因为不同 CPU 电压不同，需要主板**根据 BIOS/微代码动态调节**
  - 电源难以稳定输出这么低压且高精度电流
- **主板好坏一个关键看点就是 VRM 供电质量** 



### 1.1.2 其他主板参数

![image-20250529160504716](D:\git_repository\cyber_security_learning\markdown_img\image-20250529160504716-1751426622682-15.png)



**参数解析**

- **`14 +2 +1` 相增强供电**

  > 表示14相给CPU核心用；2相给CPU核显用；1相给其他辅助电路用

- **DrMOS 80A**

  > DrMOS（Driver MOS）是一种 **高度集成的供电模块**，所以它体积更小、效率更高、发热更低，通常中高端主板更倾向于用 **DrMOS** 来构建 **VRM 模块**
  >
  > **80A** 表示 DrMOS **每相的最大持续供电电流能力**（有些厂商指“峰值”但大多指“额定”）
  >
  > **现代高端 CPU（特别是 AMD 7000 系、Intel K 系）能瞬时拉动 200W+ 的功率**
  >
  > 多相 + 高电流能力 = 电压更稳定、纹波更低
  >
  > 对于：
  >
  > - **超频**
  > - **长时间满载运行（如渲染、科学计算）**
  > - **发烧级硬件平台**
  >
  > DrMOS + 80A 能确保供电系统不崩、不抖、不热炸。
  >
  > ![image-20250529161324373](D:\git_repository\cyber_security_learning\markdown_img\image-20250529161324373-1751426622682-16.png)
  >
  > 上述CPU仅仅烤机几分钟的热成像，供电模组已经达到100多度，温度高就会触发主板的保护机制，降低CPU的供电频率，就会性能下降
  >
  > 因此高端主板都会给供电模块上覆盖一层超厚的金属散热片
  >
  > ![image-20250529161603252](D:\git_repository\cyber_security_learning\markdown_img\image-20250529161603252-1751426622682-17.png)
  >
  > 除了供电模块外，所有的主板都会给芯片组覆盖散热马甲进行散热
  >
  > ![image-20250529161749114](D:\git_repository\cyber_security_learning\markdown_img\image-20250529161749114-1751426622682-18.png)
  >
  > <span style="color:red">**不管再便宜的主板，在芯片组上都会有散热马甲覆**盖</span>
  >
  >  <span style="color:red">**这就说明了芯片组队主板是非常重要的**</span>



### 1.1.3 芯片组（PCH）

<img src="D:\git_repository\cyber_security_learning\markdown_img\image-20250529163619417-1751426622682-19.png" alt="image-20250529163619417" style="zoom:150%;" />

**芯片组（PCH）的本质作用：**

- 芯片组（**Chipset**）是主板上的一个（或多个）专用控制芯片，用来处理 **非核心计算任务的总线管理和设备通信支持**。



**现代芯片组的三大核心功能**

| 功能模块            | 说明                                                     | 举例                             |
| ------------------- | -------------------------------------------------------- | -------------------------------- |
| **通信桥梁**        | 在 CPU 与各类设备（PCIe、USB、SATA、网卡等）之间中转数据 | CPU ⇄ 芯片组 ⇄ SSD、网卡、音频等 |
| **协议/兼容性支持** | 提供对 USB3、SATA、NVMe、PCIe 等协议的电气/逻辑支持      | USB 3.2、PCIe 4.0、SATA AHCI 等  |
| **扩展通道管理**    | 通过芯片组分配非 CPU 直连的 PCIe 通道等资源              | 提供额                           |



#### **1.1.3.1 通信桥梁详解**

上图所示：主板上虽然有很多控制功能的芯片，但严格意义上的“芯片组”指的是 PCH 芯片，是唯一的核心桥接控制器。 其他如音频芯片、网卡芯片、USB 扩展芯片等只是“功能控制器”，它们**通过 PCH 与 CPU 建立间接连接**，不属于芯片组本体。

> **为什么要通过 PCH 中转？**
>
> 原因是：**现代 CPU 只暴露有限数量的高速接口（直连 PCIe/内存）**
>
> - 高速直连（PCIe 5.0/4.0）只保留给：
>   - GPU 插槽
>   - M.2 SSD 插槽
>   - 内存控制器（直接内建于 CPU）
>
> 其他像：
>
> | 外设       | 路径                        |
> | ---------- | --------------------------- |
> | 板载网卡   | 通过 PCH 的 PCIe 通道       |
> | USB 控制器 | 由 PCH 提供                 |
> | 音效芯片   | 接在 PCH 上的 HD Audio 总线 |
> | SATA 硬盘  | PCH 管理的 SATA 控制器      |
>
> 
>
> <span style="color:red">这就是主板上 **PCH 芯片为何重要** —— 它负责“聚合”所有这些低速或中速设备的数据，并统一转发给 CPU。</span>
>
> 
>
> **补充知识点：有些网卡是 CPU 直连的（特殊情况）**
>
> 部分高端主板会这样设计：
>
> | 网卡位置                  | 连接方式                         |
> | ------------------------- | -------------------------------- |
> | 独立 PCIe 网卡            | 插在主 PCIe 插槽，**直连 CPU**   |
> | 主板上的 10G 网卡（高端） | 可能通过 CPU PCIe 通道           |
> | 主板上的千兆网卡          | 大多数走 PCH 提供的 PCIe x1 通道 |







#### **1.1.3.2 协议/兼容性支持详解**

**协议的电气逻辑和基本控制程序**，是**写在芯片组里的固件/逻辑电路中实现的**。



**“通信协议和兼容性的体现”**

| 你说的   | 对应芯片组功能                                  |
| -------- | ----------------------------------------------- |
| 协议提供 | PCIe 3/4/5、SATA、USB3.x、NVMe 等               |
| 兼容性   | 向下兼容旧设备、BIOS/UEFI识别、设备初始化       |
| CPU协调  | 为非 CPU 直连设备建立中继管理（特别是低速设备） |



**芯片组内部的协议实现结构如下：**

```
          ┌────────────────────────────┐
          │ 芯片组（如 B650）            │
          ├────────────────────────────┤
          │ 硬件逻辑（协议状态机）         │ ← 主要通过数字电路实现协议流程
          │ 控制器嵌入式程序（microcode）  │ ← 内嵌 ROM/EEPROM 中的“协议控制程序”
          │ 缓冲器、PHY 接口等           │
          └────────────────────────────┘
```

- **大部分协议如 USB、SATA、PCIe** 都是通过**状态机 + 微控制器**实现的
- 这些协议**不是运行在操作系统层面**，而是运行在芯片内部控制逻辑中
- 所以你说的“写在芯片里的程序” ✅ 本质是**嵌入在控制器固件/ROM中的硬件协议逻辑**

> 补充知识点：
>
> **“协议”分为不同层次**
>
> | 层级                     | 例子                       | 负责者                           |
> | ------------------------ | -------------------------- | -------------------------------- |
> | 应用层协议               | HTTP、SSH、NFS             | 由 CPU + 操作系统实现            |
> | 传输/网络层              | TCP/IP、USB 传输层         | CPU + 驱动程序                   |
> | **硬件层协议（你说的）** | PCIe、USB PHY、SATA、SMBus | **由芯片组或控制器固件直接实现** |
>
> <span style="color:red">**协议的本质就是一种“可被双方遵守的交互规则”**，它定义了信息怎么组织、什么时候发送、如何处理、如何回应。
> 不管是计算机、硬件、网络，还是人类语言，本质都是 **“通信约定”**。</span>







### 1.1.4 BIOS

**主板上的 BIOS（现代称 UEFI BIOS）就是负责在系统启动时，引导和初始化主板上所有关键部件，使它们协调工作，并为操作系统的启动做好准备。**

> **主板 BIOS 就是主板的大脑，在操作系统启动之前，它就负责所有硬件设备的协调和初始化**，包括 CPU、内存、芯片组、外设总线、启动顺序、风扇控制、TPM 安全模块等。

这也是为什么：

- BIOS 出错，整台机器都无法开机（比如内存未初始化，屏幕无显示）
- BIOS 设置错误会导致设备不识别（如 SATA 模式为 RAID，系统就可能无法启动）







## 1.2 计算机硬件 网卡

### 1.2.1 网卡介绍

**网卡是计算机与局域网互联的核心部件**

网卡，又称为网络适配器或网络接口卡**NIC (Network interface Card)**，是构成计算机网络系统中最基本的、最重要的和必不可少的连接设备，计算机主要通过网卡接入网络



**网卡工作内容**

网卡是局域网中连接计算机和传统介质的接口，不仅能实现与局域网传输介质之间的物理连接和电信号匹配，还涉及帧的发送与接收、帧的封装与拆封、介质的访问控制、数据的编码与解码以及数据缓存的功能。



![image-20250530013816213](D:\git_repository\cyber_security_learning\markdown_img\image-20250530013816213-1751426622682-20.png)

### 1.2.2 服务器网卡介绍

**服务器专用网卡 VS 普通网卡**

​    相对于服务器专用网卡来说，普通网卡指应用在普通PC，工作站，消费级电子产品中的网卡，对网卡的可靠性，安全性等要求不高。而服务器与普通PC工作站的不同在于，服务器一直处于工作中，且要求长时间稳定运行，这就要求服务器网卡具有以下特点：

- **数据传输速度快**

  现在是一个数据爆炸的时代，面临海量数据的交互，普通网卡的10Mbps、100Mbps的数据已不满足大数据流量网络，当前服务器常用的网卡速率为10Gbps（即万兆网卡）、25Gpbs、40G、100G等

- **CPU占用率低**

  服务器的CPU是不停工作的，处理着大量的数据。如果一台服务器的大部分时间都在为网卡提供数据响应，势必是影响到其他任务的处理速度。服务器网卡自带的控制芯片，可以处理一些CPU任务，从而减少CPU的计算开销

- **安全性能高**

  如果服务器的网卡出现故障，则服务器将无法接收，发送数据，相当于宕机，所以高可靠性是服务器网卡的一个要求。服务器网卡大都具有容错功能，如intel的AFT（网卡出错冗余），ALB（网卡负载均衡）等技术。







### 1.2.3 网卡分类

**按传播方式分类**： 分为有线网卡和无线网卡

![image-20250530025419014](D:\git_repository\cyber_security_learning\markdown_img\image-20250530025419014-1751426622682-21.png)



**按连接方式分类**：分为集成网卡和独立网卡



![image-20250530030011657](D:\git_repository\cyber_security_learning\markdown_img\image-20250530030011657-1751426622682-22.png)



**按总线接口分类**：分为ISA总线接口网卡（已淘汰）；PCIE总线网卡；USB网卡

![image-20250530030546497](D:\git_repository\cyber_security_learning\markdown_img\image-20250530030546497-1751426622682-23.png)



**按端口类型分类**：RJ-45端口网卡；光端口网卡

![image-20250530030957650](D:\git_repository\cyber_security_learning\markdown_img\image-20250530030957650-1751426622682-24.png)



光端口网卡分为**需要额外来插入光模块**才能接光纤的网卡，和**自带光模块的网卡**。同时还有单模模块和多模模块的区别





### 1.2.4 智能网卡 SmartNIC

- 微软Azure提出SmartNIC的概念，SmartNIC是通过从服务器CPU卸载网络处理工作负载来提高数据中心的服务器性能。从架构方面来看，智能网卡可基于ASIC，FPGA和MP（Multi-core，包含SoC-GP，SoC-NP）三类核心处理器进行设计
- 相比传统网卡进负责数据链路的传输，网络堆栈算法和协议。智能网卡作为一种有编辑能力的网卡，能够满足数据平面处理需求并兼容现有网络协议生态，进而卸载CPU的网络处理工作负载和任务，在数据中心中提供低延时，高带宽的网络服务，减少CPU算力负担，提高整理解决方案的效率。
- 在同等算力下，使用智能网卡所需的服务器数量更少，从而降低了服务器的前期硬件投入成本，物理空间和相应的运行维护等配套资源消耗也得到节省，大大降低了大规模部署网络服务的总拥有成本



![image-20250530031723367](D:\git_repository\cyber_security_learning\markdown_img\image-20250530031723367-1751426622682-25.png)



基于DPU（数据处理单元）的SmartNIC可以基于ASIC，FPGA和片上系统（SOC）技术实现

![image-20250530032536089](D:\git_repository\cyber_security_learning\markdown_img\image-20250530032536089-1751426622682-26.png)

![image-20250530033200560](D:\git_repository\cyber_security_learning\markdown_img\image-20250530033200560-1751426622682-29.png)

- **ASIC **具有很高的成本效益，可以提供最佳的价格性能，但其灵活性有限。虽然基于ASIC的NIC（例如Mellanox ConnectX-5）可以具有相对容易配置的可编程数据路径，但最终功能将受到基于ASIC中定义的功能的限制。
- **FPGA NIC **（例如Mellanox Innova-2 Flex相比之下）是高度可编程的，并且可以花费足够的时间和精力来相对有效地支持几乎任何功能（在可用门的限制内），然而，众所周知，FPGA难以编程且价格昂贵
- 因此，相对于更复杂的用例，SOC（如Mellanox BlueField DPU可编程SmartNIC）提供了似乎是基于DPU的最佳SmartNIC实施选项：良好的价格，易于编程且高度灵活







## 1.3 计算机硬件 GPU

<span style="color:red">**在运行拥有极致逼真画面的游戏时，显卡每秒需要执行多少次计算？**</span>

每秒执行一亿次运算？

每秒执行一亿次运算仅仅是**1996年的游戏《超级马里奥64》**所需要的运算量

![image-20250530090122922](D:\git_repository\cyber_security_learning\markdown_img\image-20250530090122922-1751426622682-27.png)

**每秒一千亿次运算？**你拥有的电脑可以在**2011年运行《我的世界》**

![image-20250530090222071](D:\git_repository\cyber_security_learning\markdown_img\image-20250530090222071-1751426622682-28.png)

如果你想运行画质逼真的**《赛博朋克2077》**，你需要一块显卡，它每秒能够运行大约**36万亿次运算**

![image-20250530090300337](D:\git_repository\cyber_security_learning\markdown_img\image-20250530090300337-1751426622682-30.png)

想象一下，你每秒做一道长乘法题。（例如：4689732 * 2764569），现在假设地球上的每个人都需要 做类似的计算，但用的数字各不相同，为了达到这块显卡**每秒36万亿次运算**的计算能力，我们**需要大约 4400个住满了地球的人，所有人一起工作，每人每秒完成一次计算**



![image-20250530090355648](D:\git_repository\cyber_security_learning\markdown_img\image-20250530090355648-1751426622682-31.png)

很难想象一个设备能完成所有这些计算，下面我们将了解，为何显卡能做到如此快速的计算，以及显卡 是如何工作的？





### 1.3.1 GPU和CPU的区别

GPU，拥有超过1万个核心（10496 Cores），而CPU仅有24 Cores

<img src="D:\git_repository\cyber_security_learning\markdown_img\image-20250530090942630-1751426622682-32.png" alt="image-20250530090942630" style="zoom:80%;" />

GPU核心数远超CPU，看似GPU理所当然的比CPU强大，但是实际情况要比这复杂的多

如果把GPU想象成一艘巨型游轮，而CPU则是一架大型喷气式飞机，货轮的载货量相当于可以处理的计 算量和数据量，而船或飞机的速度则代表这些计算和数据被处理的速率

本质上，这是一个权衡：大量计算以较慢的速度执行，相较于少量的计算，以极快的速度执行

另一个关键区别是飞机要灵活的多，因为它可以运载乘客，包裹，或者集装箱，而且可以在数以万计的 任何一个机场起降。同样的**CPU也很灵活**，它们可以运行各种各样的程序和指令

![image-20250530091121163](D:\git_repository\cyber_security_learning\markdown_img\image-20250530091121163-1751426622682-33.png)

然后，巨型货轮只能运载货物的集装箱，而且只能在港口之间航行，类似地，GPU比CPU的灵活性要差 得多，它们只能运行简单的指令，比如基本的算术运算。

此外GPU不能运行操作系统，也不能与输入设备或网络交互



**那么GPU和CPU哪一个更快**

这个问题，本质上，如果你想对海量数据运行一系列计算，那么GPU完成任务的速度会更快

然而，如果你需要处理的数据少得多，而且需要快速得到结果，那么CPU会更快。

此外，如果你需要运行操作系统，或支持网络连接，以及各种不同的应用或硬件，那么你需要的会是 CPU





### 1.3.2 GPU的物理结构

#### 1.3.2.1 **印刷电路板（PCB）**

各种各样的组件都安装在上面

![image-20250530091456826](D:\git_repository\cyber_security_learning\markdown_img\image-20250530091456826-1751426622682-34.png)

#### 1.3.2.2 **图形化处理区（GPU）**

![image-20250530091526889](D:\git_repository\cyber_security_learning\markdown_img\image-20250530091526889-1751426622682-35.png)

打开它时，会看到一块名为GA102的大型芯片或晶粒，它由283亿个晶体管构成

![image-20250530091707997](D:\git_repository\cyber_security_learning\markdown_img\image-20250530091707997-1751426622682-36.png)

芯片的大部分区域都被处理核心占据，这些核心具有**分层的组织结构**，具体来说，这块芯片，被**分为7个 图形处理集群，简称GPC**

![image-20250530091849783](D:\git_repository\cyber_security_learning\markdown_img\image-20250530091849783-1751426622682-37.png)



**每个处理集群内有12个流式多处理器，简称SM**

![image-20250530092113317](D:\git_repository\cyber_security_learning\markdown_img\image-20250530092113317-1751426622682-38.png)

每个流式处理器内部有4个Warp和1个光线追踪核心

![image-20250530092151636](D:\git_repository\cyber_security_learning\markdown_img\image-20250530092151636-1751426622682-39.png)

每个Warp内有32个CUDA核心，也叫着色核心，和1个张量核心

![image-20250530092248932](D:\git_repository\cyber_security_learning\markdown_img\image-20250530092248932-1751426622682-40.png)

整个GPU共有10752个CUDA核心，336个量核心，以及84个光线追踪核心。这三个核心执行GPU的所有计算任务，而且每种核心都有不同的功能。

![image-20250530092409303](D:\git_repository\cyber_security_learning\markdown_img\image-20250530092409303-1751426622682-41.png)



#### 1.3.2.3 **CUDA核心** 

CUDA核心可以被看做是简单的计算任务，有加法按钮，乘法按钮等等，通常在运行游戏时使用的最多

![image-20250530092514268](D:\git_repository\cyber_security_learning\markdown_img\image-20250530092514268-1751426622682-42.png)



#### 1.3.2.4 张量核心 TENSOR

张量核心是矩阵乘法和加法计算器，用于几何变换，以及处理神经网络和人工智能

![image-20250530092806524](D:\git_repository\cyber_security_learning\markdown_img\image-20250530092806524-1751426622682-43.png)



#### 1.3.2.5 光线追踪器 Ray Tracing Cores

光线追踪核心是体积最大的，但数量最少，它们用于执行光线追踪算法

![image-20250530092905157](D:\git_repository\cyber_security_learning\markdown_img\image-20250530092905157-1751426622682-44.png)

#### 1.3.2.6 **相同芯片的4款GPU为什么架构款式都不同**

事实是，3080,3090,3080ti和3090ti显卡都使用相同的GA102芯片设计作为它们的GPU

![image-20250530092947796](D:\git_repository\cyber_security_learning\markdown_img\image-20250530092947796-1751426622682-45.png)

这4款GPU的价格不同，而且发布的年份也不同，但是却使用相同的GA102芯片，为什么呢？

因为，在制造过程中，有时会出现图案错误，灰尘颗粒，或其他制造问题导致电路的某些区域损坏并产 生缺陷。与其因为一个小缺陷就把整块芯片丢弃，工程师们会找到缺陷区域，并将其永久隔离和禁用附 近的电路。由于GPU采用高度重复的设计，一个核心中出现的小缺陷只会损坏特定的流式多处理器电 路，而不会影响芯片的其他区域。因此这些电路会经过测试和分类，或根据缺陷的数量进行分级。 3090ti显卡拥有完美无瑕的GA102芯片，所有10752个

![image-20250530093021334](D:\git_repository\cyber_security_learning\markdown_img\image-20250530093021334-1751426622682-46.png)

3090有10496个核心可以工作

![image-20250530093050958](D:\git_repository\cyber_security_learning\markdown_img\image-20250530093050958-1751426622682-47.png)

3080Ti有10240个核心可以工作

![image-20250530093125697](D:\git_repository\cyber_security_learning\markdown_img\image-20250530093125697-1751426622682-48.png)

3080有8704个核心可以工作，这相当于有16个损坏且被禁用的流式多处理器。

![image-20250530093156230](D:\git_repository\cyber_security_learning\markdown_img\image-20250530093156230-1751426622682-49.png)

不同的显卡在最高频率和支持GPU的显存容量和代数也有所不同。

![image-20250530093252386](D:\git_repository\cyber_security_learning\markdown_img\image-20250530093252386-1751426622682-50.png)



#### 1.3.2.7 CUDA核心详解

其内部大约有41万个晶体管，其中5万个晶体管负责执行 A乘以B加C的运算，这被称为融合乘加运算，**简称FMA**，是显卡执行的最常见操作，一半的CUDA核心使用32位浮点数，执行FMA运算，另一半核心则 使用32位整数或32位浮点数。

核心的其他部分负责处理负数，并执行简单的功能，比如位移和位掩码，以及收集和排列传入的指令和 操作数，然后累加并输出结果

因此，这单个核心只是简单的计算器，功能有限。这个计算器在每个时钟周期内完成一次乘法和一次加法运算。

因此这块3090显卡拥有10496个核心和1.7GHz的频率，我们每秒可以得到35.6万亿次计算

![image-20250530093433158](D:\git_repository\cyber_security_learning\markdown_img\image-20250530093433158-1751426622682-51.png)

如果要处理更复杂的运算，比如除法，平方根，三角函数等，则需要特殊功能单元（SFU）执行，它们 的数量很少，每个SM只有4个



#### 1.3.2.8 GA102的其他部分

在边缘有12个显存控制器，NVLink控制器和PCIe接口，底部是一个6MB的2级SRAM缓存，缓存之间这就是**Gigathread引擎**，它管理着内部所有的图形处理集群和流式多处理器

![image-20250530093632301](D:\git_repository\cyber_security_learning\markdown_img\image-20250530093632301-1751426622682-52.png)



#### 1.3.2.9 **显卡内部的其他部分**

![image-20250530094014189](D:\git_repository\cyber_security_learning\markdown_img\image-20250530094014189-1751426622682-53.png)

左侧是用于连接显示器的各种接口

![image-20250530094053606](D:\git_repository\cyber_security_learning\markdown_img\image-20250530094053606-1751426622682-54.png)

右上角是12V输入电源接口

![image-20250530094127841](D:\git_repository\cyber_security_learning\markdown_img\image-20250530094127841-1751426622682-55.png)

下方是插入主板的PCIe引脚

![image-20250530094205820](D:\git_repository\cyber_security_learning\markdown_img\image-20250530094205820-1751426622682-56.png)

在PCB上，大部分较小的组件，即下图粉色部分，构成了电压调节模块，**它将输入的12V电压转换为1.1V**

![image-20250530094248639](D:\git_repository\cyber_security_learning\markdown_img\image-20250530094248639-1751426622682-57.png)

![image-20250530094315854](D:\git_repository\cyber_security_learning\markdown_img\image-20250530094315854-1751426622682-58.png)

这些电力会使GPU发热，因此显卡的大部分重量都来自于带有4根热管的散热器

![image-20250530094353780](D:\git_repository\cyber_security_learning\markdown_img\image-20250530094353780-1751426622682-59.png)

这些热管将热量从GPU和显存芯片传递到散热鳍片，在那里风扇会帮忙散热

![image-20250530094434780](D:\git_repository\cyber_security_learning\markdown_img\image-20250530094434780-1751426622682-60.png)

![image-20250530094506124](D:\git_repository\cyber_security_learning\markdown_img\image-20250530094506124-1751426622682-61.png)



#### 1.3.2.10 显存芯片

除GPU外，一些重要的组件，或许就是24G的显存芯片，技术上称为GDDR6X SDRAM

![image-20250530094602581](D:\git_repository\cyber_security_learning\markdown_img\image-20250530094602581-1751426622682-62.png)

每当你启动一个游戏或等待加载画面时，加载所需的时间主要花在将所有3D模型从固态硬盘移动到这些显存芯片中。

如前所述，GPU在其6MB的共享二级缓存中有少量的数据存储空间，可以容纳大约这么多的游戏环境数 据。因此，为了渲染游戏，不同的场景块会不断地在显存和GPU之间传输。由于核心会不断地执行每秒 数万亿次的计算，GPU是数据饥渴的机器，需要不断地输入TB级的数据，因此这些显存芯片的设计，就 有点像多台起重机同时为一艘货轮装载货物。具体来说，这**24块芯片一次传输384位数据**，这被称为总线宽度，而可以传输的总数据量，也就是**带宽，大约是每秒1.15TB**。

![image-20250530094833480](D:\git_repository\cyber_security_learning\markdown_img\image-20250530094833480-1751426622682-63.png)

相比之下，支持CPU的DRAM条只有64位总线宽度，最大带宽接近每秒64GB

![image-20250530094905778](D:\git_repository\cyber_security_learning\markdown_img\image-20250530094905778-1751426622682-64.png)







# 2 操作系统概述

## 2.1 操作系统历史

### 2.1.1 兼容分时系统Multics

![image-20250530100916548](D:\git_repository\cyber_security_learning\markdown_img\image-20250530100916548-1751426622682-65.png)

为了进一步强化大型主机的功能，让主机的资源可以提供更多的使用者来利用，所以在1964年，由贝尔实验室(Bell)，麻省理工学院(MIT)及奇异公司(GE美国通用电气公司)共同发起了Multics（多路信息计算系统）的计划，Multics计划的目的是让大型主机可以同时支持300个以上的终端机连线使用。不过到了1969年前后，由于计划进程缓慢，资金也短缺，所以该计划虽然继续在研究，但最终贝尔实验室还是选择了退出



### 2.1.2 Unix

1966年从加州大学伯克利分校毕业的Ken Thompson加入了贝尔实验室。参与了Multics系统的研发。他基于Multics开发了“star travel”游戏。不幸的是，1969年由于贝尔实验室退出Multics项目，这同时意味着Ken将没有机器可以再玩这个游戏了。面对此情景，Ken作为一个创作者的本性立即体现了出来，于是他决定自己写一个操作系统来满足他玩游戏的需要，Ken找到了一台废弃已久的老式PDP-7，并在这台机器上重写了他的游戏。在这个过程中，Ken有了一个主意，要开发一个全新的操作系统。利用PDP-7上的汇编语言，Ken只花了一个月就编写操作系统的内核，在这个一个月中，它一周一个内核，一个文件系统，一个编辑器和一个编译程序的完成

![image-20250530101009340](D:\git_repository\cyber_security_learning\markdown_img\image-20250530101009340-1751426622682-66.png)

**1969 Unix雏形 UNICS**

​	Ken Thompson 汇编语言 B语言

**1973 正式命名为Unix**

​        Dennis Ritchie C语言

**1977 BSD**

​        Berkeley Software Distribution 伯克利大学

<img src="D:\git_repository\cyber_security_learning\markdown_img\image-20250530101136473-1751426622682-67.png" alt="image-20250530101136473" style="zoom:150%;" />

**1979 System V架构 版权声明**

​        Hp-Unix IBM AIX "不对学生提供版权"收回版权



### 2.1.3 GNU

![image-20250530101246068](D:\git_repository\cyber_security_learning\markdown_img\image-20250530101246068-1751426622682-68.png)

**GNU: GNU is Not Unix**

1984年由**Richard Stallman**（早期黑客）发起并创建,软件自由的传教士，[GNU Project](http://www.gnu.org/) 和 [FSF](http://www.fsf.org/) 的创办人（完美主义者）。

目标是编写大量兼容于Unix系统的自由软件

官方网站：http://www/gnu.org

**GPL：GNU General Public License**，具有传播特性

自由软件基金会: **Free Software Foundation(FSF)**

允许用户任意复制，传递，修改及再发布

基于自由软件修改再次发布的软件，仍需遵守GPL（法律许可）

**LGPL：Lesser General Pulic License**, LGPL相对于GPL较为宽松，允许不公开全部源代码



GNU操作系统：

Hurd：Hird(Hurd of Interfaces Representing Depth) of Unix-Replacing Daemons richard Stallman 为了无止境寻找完美内核，而忘记了HURD的原本目的：能用的操作系统），开发了30年无疾而终



#### 2.1.3.1 关于Richard Stallman的有趣语录

``````
I could have made money this way, and perhaps amused myself writing code. But I knew that at the end of my career, I would look back on years of building walls to divide people, and feel I had spent my life making the world a worse place.
``````

我可以找份工作赚钱，并沉浸在编码的快乐中。但在职业生涯结束后，回首目睹自己筑就的高墙将人与人分隔开，我会觉得我耗尽毕生精力只换来了一个更糟糕的世界。



``````
Proprietary software keeps users divided and helpless. Divided because each user is forbidden to redistribute it to others, and helpless because the users can't change it since they don't have the source code. They can't study what it really does. So the proprietary program is a system of unjust power.
``````

私有软件使用户孤立、无助。因为禁止将软件给他人使用所以孤立，因为无法改变源码所以无助。他们不能学习其中真正的工作方式，所以整个私有软件体系就是一种不公的力量。



``````
Value your freedom or you will lose it, teaches history. 'Don't bother us with politics', respond those who don't want to learn.
``````

历史告诉我们不珍惜自由便失去自由，然而有的人不懂吸取教训，只知道说“别拿政治烦我们”



``````
Facebook mistreats its users. Facebook is not your friend; it is a surveillance engine. For instance, if you browse the Web and you see a 'like' button in some page or some other site that has been displayed from Facebook. Therefore, Facebook knows that your machine visited that page.
``````

Facebook 蹂躏它们的用户。它不是你们的朋友；它就是个监控引擎。举个例子，你是否曾在一些网页或网站上看到 Facebook 的 “like” 按键。对，Facebook 知道你的电脑曾访问过那些网页。



``````
People could no longer learn hacking the way I did, by starting to work on a real operating system, making real improvements. In fact, in the 1980s I often came across newly graduated computer science majors who had never seen a real program in their lives. They had only seen toy exercises, school exercises, because every real program was a trade secret. They never had the experience of writing features for users to really use, and fixing the bugs that real users came across. The things you need to know to do real work.
``````

(时过境迁，)人们没法再像我当初那样通过改进实实在在的操作系统来学习编程了。上世纪 80 年代，我常遇见计算机专业的毕业生，有生以来没见过真正的程序。他们接触的到的只有小玩意和学校的作业，因为每一个程序都是商业机密。他们没有机会为用户去写真正实用的特性，修复用户真正遭遇的问题。而这些正是真正的工作中你需要掌握的(东西)。



``````
It is hard to write a simple definition of something as varied as hacking, but I think what these activities have in common is playfulness, cleverness, and exploration. Thus, hacking means exploring the limits of what is possible, in a spirit of playful cleverness. Activities that display playful cleverness have "hack value".
``````

对于如“hacking”这般多样化的东西真的很难简单的下定义，不过在我看来诸如此类的行为都会有以下的这些共同点：嬉乐、智慧和探索。因此，hacking 意味着对可能的极限的探索，一颗向往快乐与智慧的心。能带来快乐与智慧的行为就有 “hack 的价值” 。



``````
For personal reasons, I do not browse the web from my computer. (I also have no net connection much of the time.) To look at page I send mail to a daemon which runs wget and mails the page back to me. It is very efficient use of my time, but it is slow in real time.
``````

出于个人原因，我不会在我的电脑上浏览网页。（大部分时间处于没有网络连接的状态。）要浏览网页，我需要给一个守护进程发 mail，然后它会运行 wget 并把页面通过 mail 发还给我。这对我而言已经是最效率了，但那真的比实时慢太多了。



``````
With paper printed books, you have certain freedoms. You can acquire the book anonymously by paying cash, which is the way I always buy books. I never use a credit card. I don't identify to any database when I buy books. Amazon takes away that freedom.
``````

印刷出来的书，当然是自由的。你可以付现金匿名买书，这也是我一直买书的方式。我绝不会使用信用卡，我买书时不会被任何数据库记下。是亚马逊把自由夺走了。



``````
One reason you should not use web applications to do your computing is that you lose control.
``````

给你个为什么不应该使用 web 应用的理由，因为你失去了计算机的控制权。



``````
If you use a proprietary program or somebody else's web server, you're defenceless. You're putty in the hands of whoever developed that software.
``````

如果你使用私有程序或他人的 web 服务器，那么你只能任人鱼肉。被软件的开发者轻易操纵。



### 2.1.4 Linux

#### 2.1.4.1 Linux历史

<img src="D:\git_repository\cyber_security_learning\markdown_img\image-20250530101932286-1751426622682-69.png" alt="image-20250530101932286" style="zoom:150%;" />



1991年的10月5日Linus Benedict Torvalds在comp.os.minix新闻组上发布消息，正式向外宣布他自行编写的完全自由免费的内核诞生（Freeminix-like kernel sources for 386-AT）—FREAX，含义是怪诞的、怪物、异想天开类Unix的内核，在GPL下发布

官方网站：www.kernel.org

最早版本：https://mirrors.edge.kernel.org/pub/linux/kernel/Historic/



**Linux操作系统：**

完整的类Unix操作系统

Linux内核+GNU工具=Linux/GNU

如：CentOS，Ubuntu，Android

![image-20250530102113668](D:\git_repository\cyber_security_learning\markdown_img\image-20250530102113668-1751426622682-70.png)

<img src="D:\git_repository\cyber_security_learning\markdown_img\image-20250530102139829-1751426622682-71.png" alt="image-20250530102139829" style="zoom:150%;" />

**关于Linus Benedict Torvalds的有趣语录**

``````
Only wimps use tape backup: _real_ men just upload their important stuff on ftp, and let the rest of the world mirror it
``````

*只有愚昧的人才会用磁带来做备份，真正聪明的人会上传他们最重要的东西到FTP服务器上，而剩下事情是，让世界各地的人来镜像这些东西*



``````
Software is like sex; it’s better when it’s free.
``````

*软件就像是性一样，仅当是自由的时候才会更好*



``````
Is “I hope you all die a painful death” too strong?
``````

*（“我希望你们所有人在痛苦中死去”这句话是不是太强硬啦？）——这句话是，Linus是在拒绝某些硬件产商想在Linux的内核中植入特定的硬件处理程序，对那些硬件产商说的。*



``````
Talk is cheap. Show me the code
``````

*能说算不上什么，有本事就把你的代码给我看看*



``````
You see. I don’t think any new thoughts. I think thoughts that other people have thought, and I rearrange them. But Sara, she thinks thoughts that never were before
``````

*（您看，我没有任何新的想法。我的想法都是别人已经想过的，而我只是去重新组织一下别人的想法。但是莎拉不一样，她的想法是从来没有人想过的）—— 这是Linus给和他的母亲说起他的姐姐Sara。*



**Linux的内核版本组成**

- 主版本号
- 次版本号
- 末版本号
- 打包版本号
- 厂商版本号



![image-20250530102340185](D:\git_repository\cyber_security_learning\markdown_img\image-20250530102340185-1751426622682-72.png)

**Linux发行版**

- slackware：SUSE Linux Enterprise Server (SLES) , OpenSuse桌面

- debian: ubuntu，deepin（深度），mint 

- redhat： RHEL: RedHat Enterprise Linux, 每18个月发行一个新版本 

  ​                 CentOS： **C**ommunity **E**nterprise **O**perating **S**ystem 兼容RHEL的格式 

  ​                 中标麒麟：中标软件 

  ​                 Fedora：每6个月发行一个新版本 

- Alpine： 一个面向安全的轻型 Linux 发行版。它不同于通常 Linux 发行版，Alpine 采用了 musllibc 和 busybox 以减小系统的体积和运行时资源消耗，但功能上比 busybox 又完善的多，只 有5M 左右大小 

- ArchLinux：轻量简洁，遵循K.I.S.S.原则（ keep it simple and stupid ），Manjaro 

- Gentoo：极致性能，不提供传统意义的安装程序，下载源代码在本机上编译安装软件 

- LFS：Linux From scratch 自制Linux，只是一个说明书 

- Android：kernel+busybox（工具集）+java虚拟机



**RedHat 红帽公司**

<img src="D:\git_repository\cyber_security_learning\markdown_img\image-20250530102442238-1751426622682-73.png" alt="image-20250530102442238" style="zoom:150%;" />

Marc Ewing早在卡内基梅隆大学读书的时候就戴着他祖父的红色曲球帽. Marc在Marc Ewing大学常把自 己的软件命名为Red Hat — Red hat 1, Red Hat 2 用来区别他人的软件. 所以当他开始自己的Linux项目,  自然就会命名为Red Hat Linux。Ewing非常乐于帮助同学解决计算机问题 “你的朋友可能会说, 去跟我的 朋友Marc交流. 谁是Marc? 他是红帽男孩. ” 所以, 至少在他们最亲密的朋友当中, 红帽子成为了技术专家 的同义词



1993年，Bob Young 建立ACC公司，营销Linux和UNIX的支持软件和书籍杂志 

1995年，Bob Young 收购了Marc Ewing的业务，合并后的ACC公司成为新的Red Hat软件公司，发布 了Red Hat Linux 2.0

 **2018年10月29日**，IBM宣布将以约340亿美元收购开源软件和技术主要供应商红帽公司



**CentOS 和 Rockey Linux**

![image-20250530102552478](D:\git_repository\cyber_security_learning\markdown_img\image-20250530102552478-1751426622682-74.png)

**RHEL（Red Hat Enterprise Linux） 红帽企业版Linux**

Red Hat 公司自身的产品中本身就包含了个人版（Red Hat Linux）和企业版 (RHEL) 基于GPL开源协议，不论是Red Hat Linux 还是 Red Hat Enterprise Linux,用户都可以直接从网络 上获取，但是从2003年开始，Red Hat Linux 被新项目（Fedora core）所取代，并且频繁更新，所以几 乎无法在企业环境中使用。 同样基于GPL开源协议，RHEL在发布的时候必须发布源代码，所以无论是二进制的发行版，还是源码，用户都 可以直接免费获取，但是不能在商业化场景中使用，商用必须购买许可（licence），另外Red Hat 公司也 提供技术支持，咨询，解决方案等。



**CentOS （ Community enterprise operating system ） 社区企业操作系统**

就是将 RHEL 发行的源代码从新编译一次，形成一个可使用的二进制版本，RHEL是遵守GPL开源协议的，所 以重新编译是合法。但是得去掉商标，版权信息等。CentOS 可以得到 RHEL 的所有功能，甚至是更好的软 件，但 CentOS 并不向用户提供商业支持，当然也不负上任何商业责任。漏洞修复和软件包升级等，相对于 RHEL的有偿服务来说，也有一定的延时。

**2004年**，Gregory Kurtzer和CentOS的其他创始成员基于开源的RHEL创建了CentOS，将Enterprise Linux引入了社区。

**2014年**，红帽宣布正式赞助CentOS。CentOS的几个核心团队入职Red Hat专门负责其开发。并在Red Hat 在理事会中占了三席，但是其社区属性得到保留，交易结果是一部分包括将CentOS商标和IP转移到Red Hat 以安全保存

CentOS 8于2019年9月交付，紧随RHEL 8之后，CentOS Stream的发布和发布是对下一个次要更新中即将 发布内容预览版本。可以说是RHEL的beta频道。

**2019年**，巨头IBM花重资收购了Red Hat。并承诺Red Hat忠于其开源根基不会改变，声称 Red Hat对开源的 使命和坚定承诺将保持不变。

**2020年12月8日**IBM宣布将惯例支持到2029年CentOS 8，提前在2年内就终结，唯一的升级途径是Centos Stream—AKA，RHEL的Beta发布，并建议不再生产环境中使用。预示着CentOS可能会正式死亡。CentOS已 死，但是CentOS精神将会永存。

随后以CentOS创始人之一Gregory Kurtzer为首，8小时内250人啸聚网络，计划以创建Rocky Linux（Rocky为已经逝世的另外一个CentOS创始人）取代CentOS。Rocky Linux与RHEL兼容目前已经创 建了Github Rocky Linux项目组织（github.com/rocky-linux/rocky）和官网 （rockylinux.org）



![image-20250530102630450](D:\git_repository\cyber_security_learning\markdown_img\image-20250530102630450-1751426622682-75.png)

**Debian 和 Ubuntu**

![image-20250530102656315](D:\git_repository\cyber_security_learning\markdown_img\image-20250530102656315-1751426622682-76.png)

Debian 是从 1993 年由 Ian Murdock(伊恩·默多克) 发起的，受到当时 Linux 与 GNU 的鼓舞，目标是成 为一个公开的发行版，经过二十几年的迭代更新Debian 从一个小型紧密的自由软件骇客（hacker）小 组，逐渐成长成今日庞大且运作良好的开发者与用户社群，Debian 的名字是由 Debian 的创始人 Ian  Murdock (伊恩·默多克) 和他的爱妻Debra(黛布拉) 两人的名字组合而成的。



Debian 是由大约一千个分布在世界各地的开发者无偿地利用他们的业余时间开发的，而这些开发者实际 上大部分都没见过面，彼此之间的通讯大多是通过电子邮件（lists.debian.org 上的邮件列表）和 IRC （irc.debian.org 上的#debian 频道）来完成的，目前Debian 提供59000多个软件包的维护与更新。





![image-20250530102727953](D:\git_repository\cyber_security_learning\markdown_img\image-20250530102727953-1751426622682-77.png)

Ubuntu（友帮拓、优般图、乌班图）早期是一个开源的GNU/Linux操作系统，**Ubuntu 是基于Debian  GNU/Linux，支持x86、amd64（即x64）和ppc架构，由全球化的专业开发团队（Canonical Ltd）打 造的**，其名称来自非洲南部祖鲁语或豪萨语的“ubuntu”一词，类似儒家“仁爱”的思想，意思是“人性”、 “我的存在是因为大家的存在”，是非洲传统的一种价值观。



与Debian的不同在于它每6个月会发布一个新版本，Ubuntu的目标在于为一般用户提供一个最新的、同 时又相当稳定的主要由自由软件构建而成的操作系统，Ubuntu具有庞大的社区力量，用户可以方便地从 社区获得帮助，Ubuntu对GNU/Linux的普及特别是桌面普及作出了巨大贡献，由此使更多人共享开源 的成果与精彩



Canonical公司是一个私营公司，由南非的企业家马克·沙特尔沃思(Mark Shuttleworth)创建，主要为了 促进开源软件项目，Canonical在马恩岛登记注册，其雇员分布在世界各地，其主要办事处在伦敦，在蒙 特利尔也有办事处，Canonical公司支持并创建了几个项目，主要都是自由/开源软件（FOSS）或是一些 旨在改善自由软件开发者和贡献者的工具



Ubuntu是各种公有云上最受欢迎的操作系统，这是因为Ubuntu与各大云运营商密切合作，针对云服务 商的基础架构优化内核和系统，加快安全更新速度，并最大限度降低用户默认需要的网络或存储成本。



Ubuntu 没有像其它软件一样有 1.0 版本，是因为其第一个版本是发布于 2004 年，Ubuntu的生日是 2004年的10月20日。



**ubuntu的版本号有个固定的特征，其使用一个形容词和一个动物名称组成，并且形容词和名词的首字母 都是一致的，Ubuntu版本的命名规则是根据正式版发布的年月命名，Ubuntu 16.04 也就意味着 2016 年4月发布的Ubuntu，研发人员与用户可从版本号码就知道正式发布的时间。**



每两年的 4 月份，都会推出一个长期支持版本（LTS），其支持期长达五年，而非 LTS 版本的支持期通常只有半年





## 2.2 操作系统层级结构

<img src="D:\git_repository\cyber_security_learning\markdown_img\image-20250530103709896-1751426622682-78.png" alt="image-20250530103709896" style="zoom:150%;" />





**第一层：**各种物理设备，组件，包括CPU，内存，硬盘，网卡等

**第二层：**

- 时钟管理：
  - 应用场景：CPU时间分片
- 中断处理
  - 应用场景：时钟中断，操作系统状态切换，
- 原语：原子的原，表示一种执行起来，不可中断的程序，它会一口气执行到结束
  - 设备驱动
  - CPU切换

**第三层：**

这里设计到操作系统的一些功能：进程管理，存储（内存）管理，设备管理，文件系统等

在裸机之上，这两层是操作系统内核的功能

**第四层：**

非内核功能：比如Linux操作系统，它是一个什么样的操作系统呢，它其实就是以linux为内核的一系列操作系统，我们把它们统称为Linux操作系统，那么对于这些操作系统，它们相同的都是使用的是LInux内核，而不同的是非内核功能，也就是操作系统里面个性化定制的一些应用程序，所有以Linux为内核开发的操作系统，统称Linux操作系统

**第五层：应用程序**

通常是用户使用安装的应用程序





### 2.2.1 内核介绍

内核是操作系统最基本，最核心的部分
实现操作系统内核功能的那些程序就是内核程序

> **内核程序的表现形式**：
>
> - 内核模块（Kernel Module） → `.ko` 文件
>   - 后缀：`.ko`（Kernel Object）
>   - 功能：添加驱动、文件系统、网络协议、钩子等
>   - 加载方式：`insmod` / `modprobe`
>   - 运行位置：运行在 Linux 内核内部（Ring 0）
>
> 示例
>
> ```bash
> lsmod         # 查看已加载模块
> insmod mydriver.ko
> dmesg         # 查看模块日志
> ```
>
> 
>
> **完整内核本体（Kernel Image） → `vmlinux` / `bzImage`**

```ABAP
内核模块（.ko 文件）不是可执行程序，它必须加载进内核才能生效
用户态不能直接执行.ko，需通过系统调用加载
```





### 2.2.2 内核分类

下面，针对于不同操作系统的设计思路，引入宏内核和微内核的概念



**宏内核(大内核)**

在我们通用的操作系统中，大多数操作系统都是大内核的
就是把第二、三层作为内核功能



**微内核（小内核）**

该体系认为内核功能没有必要做的特别复杂，我们把内核功能就做核心的三个：时钟管理，中断处理，原语
把三层以上包括三层，都变成非内核功能

微内核仅包含时钟，中断，原语三部分功能，而进程管理，内存管理，设备管理等交给非内核功能去实现



**内核的功能和意义**

在操作系统执行的过程中，有一些功能是操作系统内核去实现的，并且只能由操作系统内核实现，包括时钟管理，中断，原语(设备驱动（包含我们的键盘怎么驱动起来，摄像头如何抓拍数据，CPU切换等)，这些功能是用户程序完全无法进行的

场景：
假设有一个微信应用程序，我们希望访问摄像头，来进行一个视频会议
此时作为一个用户程序，其实是有对底层设备，计算机资源的使用需求的
那么是这部分需求如何满足？-----> 用户自己是没有权限去做的，这个事情只能由内核去做
用户程序请求内核去做这部分关于计算机资源调用的需求，因此此时就涉及到一个调用关系，此时必须在用户态**下沉**到内核态，去请求数据
也就是说，摄像头由内核驱动的，摄像头启动后，数据是不是要回到应用层数据中，让微信去处理这些数据，这是就涉及到数据从用户态到内核态再到用户态的过程





### 2.2.3 比较宏内核和微内核的两种机制

**宏内核**

![image-20250530120038010](D:\git_repository\cyber_security_learning\markdown_img\image-20250530120038010-1751426622682-79.png)

根据上述场景，当我们用微信拍摄一张照片，此时发生微信调用摄像头驱动拍摄照片，摄像头拍摄完后将数据返给微信，此时微信拿到这张照片，这个过程发生2次切换



**微内核**

![image-20250530120113870](D:\git_repository\cyber_security_learning\markdown_img\image-20250530120113870-1751426622682-80.png)

根据上述场景，此时进行设备管理的时候，其实发生在应用层，激活设备，检查设备是否可用，此时要从设备管理下到内核去看，因为驱动实在底层原语里面去做的，然后原语检查摄像头可以用，再返回给设备管理，告诉设备管理可以用，这个时候，设备发送请求去启动摄像头，启动摄像头之后，这个中间可能会有更多的这种交互，也就是会说他由用户到切换到内核态的次数应该是增加了的，这个过程此时还仅仅发生在设备管理，而这个场景中，这个图片还可能涉及到存储，这里存储管理也还要下沉到内核态，以及从内核态上到用户态，后续我拍照的过程中，摄像机的进程进行切换，比如我原先用微信，现在要用一个程序来执行拍照的功能，然后这个功能可能还需要对照片进行美化，美颜操作，这里还会涉及进程的切换，这个进程的切换也必须进入到内核，然后再从内核出来。
因此会发现，如果使用微内核后，我们由用户态进入内核态的频次会急剧增加 



此时我们还没有学什么是用户态和内核态，目前只是在操作系统的层级上划分一条线，标记用户空间和内核空间，我们会发现用户做不了的事情必须由内核去执行，所以我们需要切换到内核状态去做，内核做完后将数据还给应用程序，此时就一定会发生切换



而且上述过程我们发现，内核的功能越少，如果只包含第二层，我们应用程序和内核之间的变换状态的次数会急剧升高，这意味着微内核中过多的状态转换会导致很多的性能损失（**状态的转换是由成本的**），频繁地切换CPU状态会降低系统性能



**宏内核和微内核的对比**

宏内核：

- 优点：
  - 资源利用率更高，高性能  
- 缺点：
  - 当前linux内核代码已经超3000万行，如此庞大的代码量，无论是维护还是升级更新都很麻烦

微内核

- 优点：内核功能少，结构清晰，因为第三层设备管理，内存管理，进程管理等功能作为用户空间的的程序，这就意味着，普通开发者也可以去开发和优化，只有核心功能是由操作系统内核提供的，上层的进程，内存，设备管理都变成了应用层软件，都是用户软件，因此：开发成本降低，升级更新，维护成本也会变低
- 缺点：需要频繁的在内核和用户态之间切换，性能差



典型的大内核/宏内核操作系统：Linux、Unix
典型的微内核操作系统：Windows NT





## 2.3 操作系统运行机制

### 2.3.1 应用程序和内核程序

**应用程序（可执行文件）**

- 是运行在用户态的普通程序
- 依赖系统调用来间接操作资源
- 受到操作系统的**内存隔离保护**



**内核程序（.ko内核模块）**

- 是运行在内核态的系统核心部分
- 拥有所有资源访问权
- 稍有 bug 就可能 **导致整个系统崩溃**





### 2.3.2 特权指令和非特权指令

**非特权指令**

**非特权指令**（**Unprivileged Instructions**）是指可以在任意特权级别（Ring 0~3）执行，**不会触发异常，也不会越权访问系统资源**的指令。

应用程序只能使用“非特权指令”，如加法指令，减法指令，这种数学操作，不需要操作系统的**额外硬件**就可以执行的指令，仅需要CPU就可以处理，我们不需要访问磁盘，不需要访问外设就可以做的事情，就是非特权指令



**特权指令**

是指 **只能在 Ring 0（内核态）执行** 的**汇编指令**。

内核程序中，操作系统作为管理者，用来操作计算机资源的指令称为特权指令，比如：C语言中的memset()将一段内存清0，又或者打开文件，打开设备，这些都是特权指令



**特权指令与非特权指令的由来**

在CPU设计和生产的时候，就划分了特权指令和非特权指令，这里其实有是CPU指令集中就已经区分好的，因此CPU执行指令前，一定就能够判断这条指令它到底是什么类型，是特权指令还是非特权指令，所谓特权指令就是操作系统作为管理者，它来管理计算机资源用到的指令，而非特权指令时应用程序可以直接做的，常见的就是数学计算。



```ABAP
cpu能判断出指令类型，那么如何区分此时正在进行的是内核程序还是应用程序？
```





### 2.3.3 内核态和用户态

CPu有两种状态，“内核态”和“用户态”（重要）
处于内核态时，说明此时正在运行的是内核程序，此时可以执行特权指令（当然也可以执行非特权指令）
处于用户态时，说明此时正在运行的是应用程序，此时只能执行非特权指令
(如果当前处于用户态，你却非要调用特权指令，CPU就会报错)

拓展：CPU中有一个寄存器叫程序状态字寄存器(PSW)，其中有个二进制位，**1表示内核态，0表示用户态**，所以CPU在每个时刻可以去看自己的寄存器，里面的值是多少，进而判断当前状态

别名：内核态=核心态=管态； 用户态=目态



**理解内核态和用户态的意义**

当我们进行程序设计或者管理维护的时候，特别是大型软件设计与优化，我们会考虑我们的应用程序它的性能，常见的会影响程序性能的其中一个问题就是：由程序引起的用户态到内核态的一个频繁切换，如果过于频繁切换，就会导致程序效率底下，这也是了解内核态和用户态的意义之一



**内核态和用户态的切换**

**内核态 -> 用户态**：执行一条特权指令——修改PSW的标志位为“用户态”，这个动作意味着操作系统将主动让出CPU使用权，此时CPU的使用权归用户态，内核态到用户态是由操作系统主动让出的，它让出的过程就是使用一个特权指令，修改PSW寄存器上的值



**用户态 -> 内核态**：由“中断”引发，硬件自动完成变态过程(除了非法使用特权指令外，还有很多事情会触发中断信号。一个共性是，但凡需要操作系统介入的地方，都会触发中断信号)，触发**中断信号**意味着**操作系统将强行夺回CPU的使用权**



每个进程都是自私的，都希望拥有更多的CPU时间，所以用户态不可能主动让出CPU，所以从用户态到内核态通常需要由中断引起，这个中断通常是硬件自动完成的

```ABAP
在某些体系结构（如 MIPS、ARM）中，PSW 或类似的状态寄存器中确实包含一个位，用于表示当前是用户态还是内核态。但在 x86 架构中，**当前特权级由代码段选择子（CS）的最低两位决定**，而不是在 PSW（EFLAGS）中体现。
```

```ABAP
什么是中断
比如：吃饭的时候，老板来了个电话
比如：睡觉的时候，被闹钟吵醒
比如：应用程序正在执行的过程中，被打断，操作系统强行夺回CPU控制权，变为内核态
```



**触发中断的几种常见情况（共性：凡是需要操作系统介入的地方）**

- 用户态应用程序非法使用特权指令，会被操作系统中断，并夺回CPU控制权
- 程序执行过程中，被分配的CPU时间片的时间到了，也触发中断，然后被夺回CPU控制权
- 除0，非法操作
- 应用程序操作鼠标键盘，这个操作鼠标硬盘，这种IO操作，必须交给操作系统内核去做 ，这个也会产生中断，这个通常是通过系统调用实现的，这里有个概念："陷入"（从用户态陷入内核态）







## 2.4 中断(Interrupts)和异常

### 2.4.1 异常（内中断）

CPU内部产生的错误

- 除0
- 内存越界产生的段错误等
- 陷入指令
- 故障：访问内存，但所需数据并不在访问的内存中，就会引发故障，故障就是我出错了，但是没关系，下次重新做，可以由操作系统修改的
- 终止（除零，段错误），只能杀死进程



### 2.4.2 中断（外中断）

外部信号导致CPU中断，就是中断

<span style="color:red">“中断”是让操作系统内核夺回CPU使用权的唯一途径</span>
如果没有“中断”机制，那么一旦应用程序上CPU运行，CPU就会一直运行这个程序，直到程序执行结束，或者程序主动让出CPU的使用权，而这种程序主动让出使用权的方式，风险很大。因此需要一种机制让应用程序让出CPU，这种就是中断



### 2.4.3 内中断与外中断的区别

**内中断**

与当前执行的指令有关（比如CPU在执行指令的时候发现了问题），中断信号来源于CPU内部

**案例**

比方一段程序访问数组地址，CPU的基址寄存器是0，长度的寄存器是100，你访问101，就会发生数组越界，此时就会发生段错误
当然，也有人数组越界的时候，没有发生段错误，而仅仅是数据错误，这是因为，虽然数组越界了，但此时的内存地址还在该程序的进程内，如果你越界的地址恰巧在该程序进程内存之外，那么一定会发生段错误



**外中断**

与当前执行的指令无关，中断信号来源于CPU外部

- 时钟信号
- 进行写操作，但是写入的磁盘地址错误发生中断，这种中断是在CPU外部产生的，因此是外中断
- 时钟中断
- IO中断，由输入输出设备发出的中断信号

**扩展知识：陷入**

trap指令（陷入指令）：由用户态进入内核态的过程，也就是CPU的使用权由用户态转交给内核态的过程



**中断的基本原理**

不同的中断信号，需要用不同的中断处理程序来处理，当CPU检测到中断信号后，会根据中断信号的类型去查询“中断向量表”，以此来找到相应的中断处理程序在内存中存放的位置

```shell
中断向量表：本质是一个数组，里面存放着一个个中断处理程序的指针，下标表示一个个中断信号类型
显然，中断处理程序一定是内核程序，需要运行在内核态
```







## 2.5 系统调用（system call）



从**纯粹的代码实现角度来看 Linux 操作系统的整体结构**

| Level      | Describe                                                     | Lang     |
| ---------- | ------------------------------------------------------------ | -------- |
| 用户态程序 | 发起系统调用，触发上下文切换                                 | 高级语言 |
| 系统调用   | 是用户态访问内核态的唯一入口                                 | C        |
| 抽象层     | VFS、网络协议栈、进程调度器、内存管理、IPC子系统（管道，信号，共享内存）等 | C        |
| 驱动层     | 实现硬件控制逻辑、注册接口，如字符设备驱动（`/dev/ttyS0`, `/dev/input/mouse0`）块设别驱动（NVMe、SATA、MMC），网络设备驱动（e1000e, r8169），显卡驱动（i915, amdgpu） | C        |
| 底层控制层 | 驱动内部直接操作硬件的代码：对寄存器读写、DMA、中断响应等。  | C/汇编   |
| 物理层     | 真正的硬件设备，不属于代码范畴，但是操作目标                 | N/A      |



### 2.5.1 系统调用(system call)

什么是call,call就是摇人，打架打不过怎么办，摇人！call，就是这个事你处理不了，请别人帮你做，就叫call

```shell
操作系统是计算机资源的管理者
是不是意味着应用程序不具备使用计算机资源的权限
如果有程序想使用硬件怎么办
```

比如去银行取钱，取20块钱，你不可能自己去金库把钱取走，你这就不是取钱，而是抢银行
去银行取钱（用户看作是应用程序），使用银行卡取（用什么卡），取多少，就是取钱的参数，取钱的过程是由柜员（系统调用）将钱去给你 ---  对应着 ----->  你虽然对计算机有拥有权，但是你不能直接往计算机的屏幕打字，你想往计算机的程序上打字，必须借助操作系统内核把字打印在硬件上。因为只有硬件才有对底层资源的操作权限。
此外，还会有安全措施，监督系统调用的过程

系统调用，就是操作系统提供给应用程序（程序员/编程人员）使用的接口，可以理解为一种可供应用程调用的特殊函数，`应用程序可以通过系统调用来请求获得操作系统内核的服务`



### 2.5.2 接口

操作系统作为用户和计算机硬件之间的接口，需要向上提供一些简单易用的服务。主要包括命令接口和程序接口。其中，程序接口由一组`系统调用`组成

- 用户与计算机系统之间的接口
  - 给用户使用的
    - CUI
    - 命令接口
      - 联机命令接口
      - 脱机命令接口
  - 给应用程序使用的
    - 程序接口（系统调用）



#### 2.5.2.1 API

**定义：**

> **API** 是一组 **编程接口**，描述应用程序如何与操作系统或库进行交互。



**举例：**

```C
int read(int fd, void *buf, size_t count);  // POSIX API
```

- API 定义了函数名、参数、返回值、语义（如 errno）
- 它是 **程序员在写代码时调用的接口**
- 实际的 API 实现可能调用系统调用，也可能是纯用户态函数（如 `malloc()`）



#### 2.5.2.2  ABI

**定义：**

> 它定义了**二进制层面**程序和操作系统（或库）之间如何协作运行，包括：

| 内容         | 含义                                    |
| ------------ | --------------------------------------- |
| 调用约定     | 函数参数用哪些寄存器传，返回值放哪      |
| 系统调用接口 | syscall 用哪个指令、哪个寄存器          |
| 二进制格式   | 可执行文件的结构（如 ELF）              |
| 数据表示     | 基本数据类型（int、long）大小、对齐方式 |
| 栈布局       | 函数调用栈帧如何组织                    |

**ABI 是“编译出来”的代码必须严格遵循的机器执行规范**。



**举例讲解**

调用一个普通函数 `int add(int a, int b)`

ABI 规定如下：

| 参数编号    | 使用的寄存器（x86_64 System V ABI） |
| ----------- | ----------------------------------- |
| 第 1 个参数 | `rdi`                               |
| 第 2 个参数 | `rsi`                               |
| 第 3 个参数 | `rdx`                               |
| 返回值      | `rax`                               |



**汇编表示：**

```assembly
mov rdi, 3      ; a = 3
mov rsi, 4      ; b = 4
call add
mov rax, result ; 返回值在 rax 中
```

所以如果你编写汇编程序或链接 `.o` 文件，**必须遵守 ABI 规定的寄存器使用规则**，否则结果就错了！



```basic
ABI（应用二进制接口） 是实现跨语言调用（cross-language calling）的基础和前提条件之一。
它定义了函数如何在二进制层面传递参数、返回值、调用和链接，从而让不同语言生成的代码能够在运行时“理解彼此”。
```



**ABI 是如何让跨语言调用成为可能的？**

ABI 统一了以下关键规则：

| 项目                                   | 作用                             |
| -------------------------------------- | -------------------------------- |
| **函数调用约定（Calling Convention）** | 明确参数通过哪些寄存器或栈传递   |
| **返回值约定**                         | 结果放在哪个寄存器中（如 `rax`） |
| **栈帧布局**                           | 局部变量、返回地址的存放位置     |
| **结构体布局和对齐**                   | 保证传递的复合类型字段顺序一致   |
| **动态链接格式（如 ELF、PE）**         | 提供一致的符号导入导出机制       |



**如果不遵守 ABI，会发生什么？**

举个典型错误例子：

- 编译器 A 假设第一个参数用 `rdi`
- 编译器 B 假设第一个参数在栈偏移 8 字节
- 你在 A 中定义函数，在 B 中调用，参数就错乱了

💥 导致程序运行时崩溃、数据错位、行为不可预期。



<span style="color:red">**ABI 的不同确实是 Linux 和 Windows 不兼容的根本原因之一**</span>











# 3 Linux安装

## 3.1 环境准备

### 3.1.1 VMware Workstation虚拟机软件安装

#### 3.1.1.1 VMware Workstation的下载

**软件检索**

```http
https://www.broadcom.com/
```

注册登录BROADCOM官网**（未注册用户，一定要注册才能下载）**

![image-20250528152516751](D:\git_repository\cyber_security_learning\markdown_img\image-20250528152516751-1751426622682-81.png)

**注册后登录用户**

进入到 个人的 专属软件下载页面  https://support.broadcom.com/group/ecx/productdownloads  【最好专门复制链接进入，查找很繁琐】，点击左边栏的 My Downloads

![image-20250528153352810](D:\git_repository\cyber_security_learning\markdown_img\image-20250528153352810-1751426622682-82.png)

在搜索框输入`vmware workstation`，点击`Show Results`搜索，点击搜索出来的`VMware Workstation Pro`

![image-20250528153612338](D:\git_repository\cyber_security_learning\markdown_img\image-20250528153612338-1751426622682-83.png)

根据操作系统选择要下载的安装包（相信大部分人都是Windows），并选择需要的版本

![image-20250528153935220](D:\git_repository\cyber_security_learning\markdown_img\image-20250528153935220-1751426622682-84.png)

注意：默认情况下，需要勾选 "I agree to xxx" 选项，才可以点击 产品条目右侧的下载选项

![image-20250528154246990](D:\git_repository\cyber_security_learning\markdown_img\image-20250528154246990-1751426622682-85.png)

下载安装包之前，会要求填写个人信息，填写完个人信息后，即可下载`VMware workstation pro`安装包



####  3.1.1.2 VMware Workstation的安装步骤

查看下载的软件

![image-20250528155033460](D:\git_repository\cyber_security_learning\markdown_img\image-20250528155033460-1751426622682-86.png)

双击要下载版本的安装包，进入安装向导界面

![image-20250528155144104](D:\git_repository\cyber_security_learning\markdown_img\image-20250528155144104-1751426622682-87.png)

兼容设置

```ABAP
建议勾选自动安装 WHP
```

> **为什么 VMware Workstation 需要 WHP？**
>
> 从 Windows 10 1803（2018年）开始，如果你启用了：
>
> - Hyper-V
> - Windows Sandbox
> - Device Guard / Credential Guard
> - WSL 2
>
> 这些功能都会启动 **Hyper-V 核心层**，从而导致 VMware 的传统虚拟化方式（基于 VT-x/EPT）**无法直接使用硬件虚拟化**，提示 "VMware and Hyper-V are not compatible"。
>
> 因此：
>
> > **WHP 是 VMware 为了解决与 Hyper-V 冲突而提供的兼容方案**。
>
> 它允许 VMware 在 Hyper-V 层之上运行虚拟机，虽然性能稍差，但保证能用。



选择安装位置

```ABAP
选择VMware Workstation的安装目录。默认位置通常在C盘，但建议更改到其他磁盘以节省C盘空间。点击“更改”按钮，选择新的安装位置，然后点击“确定”。
```

![image-20250528155744663](D:\git_repository\cyber_security_learning\markdown_img\image-20250528155744663-1751426622682-88.png)

后续下一步---> 下一步... 直至安装成功。

```ABAP
安装完成后，系统会提示输入许可证密钥。可以在官网或其他可靠来源获取有效的密钥。将密钥复制到输入框中，并点击“下一步”完成许可证验证。
```

```ABAP
关于序列号，可以从互联网上去检索，下面给了几个，如果不管用的话，重新去互联网上检索即可。
JU090-6039P-08409-8J0QH-2YR7F
ZF3R0-FHED2-M80TY-8QYGC-NPKYF
FC7D0-D1YDL-M8DXZ-CYPZE-P2AY6
ZC3TK-63GE6-481JY-WWW5T-Z7ATA
```



### 3.1.2 虚拟机网络环境准备

#### 3.1.2.1 虚拟网络服务

安装完成vmware Workstation之后，会在windows的服务管理中，存在几个相关的服务

`Windows键 + R`在运行中输入 `services.msc`，进入服务管理，（如果相关服务未开启）开启相关服务

![image-20250528162104223](D:\git_repository\cyber_security_learning\markdown_img\image-20250528162104223-1751426622682-89.png)

vmware服务启动之后，会开启两个虚拟网卡

![image-20250528162901552](D:\git_repository\cyber_security_learning\markdown_img\image-20250528162901552-1751426622682-90.png)

```ABAP
如果没有相关虚拟网卡（或者设备管理器上有，但是显示黄色感叹号）,如果出现上述情况，恭喜中奖，建议重置此电脑，或重装系统
```



#### 3.1.2.2  网络环境定制

VMware Workstation是一款功能强大的桌面虚拟计算机软件，它提供了三种主要的网络模式，以满 足不同用户的需求。

```ABAP
对于这三种网络模式，后续学完网络会详解，现阶段按图例完成配置修改即可
```

进入虚拟网络编辑器

![image-20250528163719971](D:\git_repository\cyber_security_learning\markdown_img\image-20250528163719971-1751426622682-91.png)

修改仅主机网络环境的网段为 192.168.23.0，修改NAT网络环境网段为 10.0.0.0 （要修改网络配置，需要管理员权限）

![image-20250528163917374](D:\git_repository\cyber_security_learning\markdown_img\image-20250528163917374-1751426622682-92.png)

修改**仅主机**网络，按下方图例更改

![image-20250528165500936](D:\git_repository\cyber_security_learning\markdown_img\image-20250528165500936.png)



修改**NAT模式**网络，按下方图例更改

![image-20250528165250417](D:\git_repository\cyber_security_learning\markdown_img\image-20250528165250417-1751426622682-93.png)



## 3.2 Rocky安装

### 3.2.1 VM配置

点击左上角“文件”，在下拉中选择第一项"新建虚拟机"；

后续按下列图例，依次操作即可

![image-20250528173701673](D:\git_repository\cyber_security_learning\markdown_img\image-20250528173701673-1751426622682-94.png)

![image-20250528173923836](D:\git_repository\cyber_security_learning\markdown_img\image-20250528173923836-1751426622682-95.png)

![image-20250528174305845](D:\git_repository\cyber_security_learning\markdown_img\image-20250528174305845-1751426622682-96.png)

![image-20250528174430437](D:\git_repository\cyber_security_learning\markdown_img\image-20250528174430437-1751426622682-97.png)

![image-20250528174555879](D:\git_repository\cyber_security_learning\markdown_img\image-20250528174555879-1751426622682-98.png)

![image-20250528174657976](D:\git_repository\cyber_security_learning\markdown_img\image-20250528174657976-1751426622682-99.png)

![image-20250528174840703](D:\git_repository\cyber_security_learning\markdown_img\image-20250528174840703-1751426622682-100.png)

![image-20250528175031763](D:\git_repository\cyber_security_learning\markdown_img\image-20250528175031763-1751426622683-101.png)



### 3.2.2 系统安装

![image-20250528175330519](D:\git_repository\cyber_security_learning\markdown_img\image-20250528175330519-1751426622683-102.png)

![image-20250528175448687](D:\git_repository\cyber_security_learning\markdown_img\image-20250528175448687-1751426622683-103.png)

![image-20250528175634938](D:\git_repository\cyber_security_learning\markdown_img\image-20250528175634938-1751426622683-104.png)

![image-20250528175810758](D:\git_repository\cyber_security_learning\markdown_img\image-20250528175810758-1751426622683-105.png)

![image-20250528175948707](D:\git_repository\cyber_security_learning\markdown_img\image-20250528175948707-1751426622683-141.png)

![image-20250528180050466](D:\git_repository\cyber_security_learning\markdown_img\image-20250528180050466-1751426622683-106.png)

**安装成功后重启即可**



### 3.2.3 安装VMtools

在 Rocky Linux 9.4 桌面版中，系统默认自带了 `open-vm-tools` 和 `open-vm-tools-desktop`，无需手动安装即可使用剪贴板、拖放等功能。



## 3.3 Ubuntu安装

### 3.3.1 VM创建

点击左上角“文件”，在下拉中选择第一项"新建虚拟机"；

后续按下列图例，依次操作即可

![image-20250528173701673](D:\git_repository\cyber_security_learning\markdown_img\image-20250528173701673-1751426622682-94.png)

![image-20250528173923836](D:\git_repository\cyber_security_learning\markdown_img\image-20250528173923836-1751426622682-95.png)

![image-20250529001829361](D:\git_repository\cyber_security_learning\markdown_img\image-20250529001829361-1751426622683-107.png)

![image-20250529002021338](D:\git_repository\cyber_security_learning\markdown_img\image-20250529002021338-1751426622683-108.png)

![image-20250529002238085](D:\git_repository\cyber_security_learning\markdown_img\image-20250529002238085-1751426622683-109.png)

![image-20250529002410149](D:\git_repository\cyber_security_learning\markdown_img\image-20250529002410149-1751426622683-110.png)

![image-20250529002612743](D:\git_repository\cyber_security_learning\markdown_img\image-20250529002612743-1751426622683-111.png)

![image-20250529002823598](D:\git_repository\cyber_security_learning\markdown_img\image-20250529002823598-1751426622683-112.png)

![image-20250529004009893](D:\git_repository\cyber_security_learning\markdown_img\image-20250529004009893-1751426622683-113.png)

**“虚拟化引擎下三个选项含义与作用**

| 选项                                 | 全称                            | 作用                                               | 默认是否需要勾选             | 适用场景                                 |
| ------------------------------------ | ------------------------------- | -------------------------------------------------- | ---------------------------- | ---------------------------------------- |
| ✅ 虚拟化 Intel VT-x/EPT 或 AMD-V/RVI | **硬件辅助虚拟化**              | 允许虚拟机启用嵌套虚拟化（即虚拟机中再运行虚拟机） | ❌ 默认关闭，但很多功能依赖它 | 安装 KVM、ESXi、Docker（部分内核）等场景 |
| ✅ 虚拟化 CPU 性能计数器              | **Expose Performance Counters** | 允许虚拟机访问主机的性能计数器（如 PMU）           | ❌ 仅用于性能分析和低级优化   | 使用 `perf`、`vtune`、BPF 等性能工具     |
| ✅ 虚拟化 IOMMU（IO 内存管理单元）    | **Intel VT-d / AMD-Vi**         | 提供更精细的设备访问控制（如 PCIe 直通）           | ❌ 很少需要                   | 需要 SR-IOV、设备直通、虚拟化安全研究等  |

![image-20250529005146062](D:\git_repository\cyber_security_learning\markdown_img\image-20250529005146062-1751426622683-114.png)



### 3.3.2 系统安装

![image-20250529005730705](D:\git_repository\cyber_security_learning\markdown_img\image-20250529005730705-1751426622683-115.png)

![image-20250529005900084](D:\git_repository\cyber_security_learning\markdown_img\image-20250529005900084-1751426622683-116.png)

![image-20250529010046547](D:\git_repository\cyber_security_learning\markdown_img\image-20250529010046547-1751426622683-117.png)

![image-20250529010209710](D:\git_repository\cyber_security_learning\markdown_img\image-20250529010209710-1751426622683-118.png)

![image-20250529010423955](D:\git_repository\cyber_security_learning\markdown_img\image-20250529010423955-1751426622683-119.png)

![image-20250529010817169](D:\git_repository\cyber_security_learning\markdown_img\image-20250529010817169-1751426622683-120.png)

![image-20250529011010747](D:\git_repository\cyber_security_learning\markdown_img\image-20250529011010747-1751426622683-121.png)

![image-20250529011123394](D:\git_repository\cyber_security_learning\markdown_img\image-20250529011123394-1751426622683-122.png)

![image-20250529013127098](D:\git_repository\cyber_security_learning\markdown_img\image-20250529013127098-1751426622683-123.png)

**安装成功后重启即可**



### 3.3.3 图形界面不兼容解决方案

由于Ubuntu2404兼容性极差，所以如果图形界面假死，黑屏，卡死，解决不掉，建议部署server版本，然后在server版本基础上安装轻量级图形界面。

#### 3.3.3.1 VM创建

VM配置如2.3.1



#### 3.3.3.2 系统安装

![image-20250529021640541](D:\git_repository\cyber_security_learning\markdown_img\image-20250529021640541-1751426622683-124.png)

![image-20250529021732568](D:\git_repository\cyber_security_learning\markdown_img\image-20250529021732568-1751426622683-125.png)

![image-20250529021825456](D:\git_repository\cyber_security_learning\markdown_img\image-20250529021825456-1751426622683-126.png)

![image-20250529021855179](D:\git_repository\cyber_security_learning\markdown_img\image-20250529021855179-1751426622683-127.png)

**要选择指定选项 — 按空格**

**切换选项 — 按Tab键**

![image-20250529021942858](D:\git_repository\cyber_security_learning\markdown_img\image-20250529021942858-1751426622683-128.png)

![image-20250529022141714](D:\git_repository\cyber_security_learning\markdown_img\image-20250529022141714-1751426622683-129.png)

![image-20250529022219539](D:\git_repository\cyber_security_learning\markdown_img\image-20250529022219539-1751426622683-130.png)

![image-20250529022258447](D:\git_repository\cyber_security_learning\markdown_img\image-20250529022258447-1751426622683-131.png)

![image-20250529022354949](D:\git_repository\cyber_security_learning\markdown_img\image-20250529022354949-1751426622683-132.png)

![image-20250529022423007](D:\git_repository\cyber_security_learning\markdown_img\image-20250529022423007-1751426622683-133.png)

![image-20250529022455156](D:\git_repository\cyber_security_learning\markdown_img\image-20250529022455156-1751426622683-134.png)

![image-20250529022607913](D:\git_repository\cyber_security_learning\markdown_img\image-20250529022607913-1751426622683-135.png)

![image-20250529022648002](D:\git_repository\cyber_security_learning\markdown_img\image-20250529022648002-1751426622683-136.png)

![image-20250529022719734](D:\git_repository\cyber_security_learning\markdown_img\image-20250529022719734-1751426622683-137.png)

![image-20250529023059839](D:\git_repository\cyber_security_learning\markdown_img\image-20250529023059839-1751426622683-138.png)

![image-20250529023153890](D:\git_repository\cyber_security_learning\markdown_img\image-20250529023153890-1751426622683-140.png)

![image-20250529023327093](D:\git_repository\cyber_security_learning\markdown_img\image-20250529023327093-1751426622683-139.png)



#### 3.3.3.3 轻量级桌面版安装

![image-20250529023532311](D:\git_repository\cyber_security_learning\markdown_img\image-20250529023532311-1751426622683-142.png)

![image-20250529024137600](D:\git_repository\cyber_security_learning\markdown_img\image-20250529024137600-1751426622683-143.png)

```bash
# 切换root用户
sudo -i

# 输入密码后回车

# 执行下面指令
apt update && apt install xubuntu-desktop -y

# 安装桌面的过程请耐心等待
```

![image-20250529025444933](D:\git_repository\cyber_security_learning\markdown_img\image-20250529025444933-1751426622683-144.png)



安装成功之后重启

```bash
reboot
```

![image-20250529032105085](D:\git_repository\cyber_security_learning\markdown_img\image-20250529032105085.png)





### 3.3.3 安装Vmtools

#### 3.3.3.1 vmtools简介

默认情况下，登录后的ubuntu桌面展示效果和VMWare平台框之间有一圈黑色的背景，在这种模式下， 主要表现样式是 ubuntu桌面不会自动随着窗口大小调整而自动调整，而且windows主机和ubuntu主 机，还没有实现无缝的数据切换 -- 粘贴复制。



#### 3.3.3.1 vmtools安装

![image-20250529032607267](D:\git_repository\cyber_security_learning\markdown_img\image-20250529032607267-1751426622683-145.png)

![image-20250529032929226](D:\git_repository\cyber_security_learning\markdown_img\image-20250529032929226-1751426622683-146.png)

```bash
apt install -y open-vm-tools-desktop
```

重启后，桌面拉伸到全屏，即为成功，此时可以使用剪贴板进行复制粘贴

![image-20250529033344394](D:\git_repository\cyber_security_learning\markdown_img\image-20250529033344394-1751426622683-147.png)





## 3.4 openEuler安装

### 3.4.1 安装系统

参看2.2节内容

```ABAP
主要的区别：密码设定的时候，比较繁琐和复杂
```



### 3.4.2 注意事项

安装完毕openeuler之后，可以看到有三个网卡

```bash
[root@openeuler-14 ~]# ip a
1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN group 
default qlen 1000
     link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
     inet 127.0.0.1/8 scope host lo
        valid_lft forever preferred_lft forever
     inet6 ::1/128 scope host noprefixroute
        valid_lft forever preferred_lft forever
2: ens33: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc fq_codel state UP 
group default qlen 1000
     link/ether 00:0c:29:ef:3f:ab brd ff:ff:ff:ff:ff:ff
     inet 10.0.0.14/24 brd 10.0.0.255 scope global noprefixroute ens33
        valid_lft forever preferred_lft forever
     inet6 fe80::20c:29ff:feef:3fab/64 scope link noprefixroute
        valid_lft forever preferred_lft forever
3: virbr0: <NO-CARRIER,BROADCAST,MULTICAST,UP> mtu 1500 qdisc noqueue state DOWN 
group default qlen 1000
     link/ether 52:54:00:62:3b:6b brd ff:ff:ff:ff:ff:ff
     inet 192.168.122.1/24 brd 192.168.122.255 scope global virbr0
       valid_lft forever preferred_lft forever
```

virbr0网卡通常是由于系统中安装了虚拟化相关服务（如libvirt）并默认启用了虚拟网络桥接功能所导致 的。我们可以通过如下方法来解决它

```bash
# 查看服务状态
[root@openeuler-14 ~]# systemctl is-enabled libvirtd
enabled
```

```bash
# 关闭服务，同时关闭开机自启动
[root@openeuler-14 ~]# systemctl disable --now libvirt
```

```bash
# 重启主机
[root@openeuler-14 ~]# reboot
```

重启主机之后，再次查看网卡

```bash
[root@openeuler-14 ~]# ip a
1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN group 
default qlen 1000
     link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
     inet 127.0.0.1/8 scope host lo
        valid_lft forever preferred_lft forever
     inet6 ::1/128 scope host noprefixroute
        valid_lft forever preferred_lft forever
2: ens33: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc fq_codel state UP 
group default qlen 1000
     link/ether 00:0c:29:ef:3f:ab brd ff:ff:ff:ff:ff:ff
     inet 10.0.0.14/24 brd 10.0.0.255 scope global noprefixroute ens33
        valid_lft forever preferred_lft forever
     inet6 fe80::20c:29ff:feef:3fab/64 scope link noprefixroute
        valid_lft forever preferred_lft forever
```







