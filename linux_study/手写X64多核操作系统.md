# 总汇
汇编，C语言（指针），硬件CPU（运行模式，段页机制，32位段机制，64位段机制，32位页地址，32位页地址）（用户态和内核态，本质是由CPU的段机制进行隔离的，它会做一些权限判断，因为有段机制做隔离，这里衍生一个门的机制）

CPU的页机制是和内存联系的，CPU的页地址提供的是虚拟内存，设计物理内存管理模块，虚拟内存管理模块

硬盘，因为内核是在硬盘里面的，需要使用汇编操控硬盘，将内核从硬盘加载到内存（boot,load, 加载内核）

中断，设计时钟中断（实现任务管理模块），实时时钟中断，键盘中断

APIC芯片：多核协同实现

进入用户态：门机制，快速调用(syscall,sysret),中断门，系统调用


目标：凌驾于操作系统之上，无视内核的各种保护机制，实现对操作系统的全操控


## 学习目标
- 将汇编，C语言，OS融会贯通
- 深入理解汇编语言，尤其是执行流，能够熟练使用汇编语言编程
- 深入理解C语言，能脑补出C语言编译后的汇编代码及运行时的内存图
- 熟练使用汇编语言操控硬件，汇编，C语言之间的互调及开发时的单步调式
- 深刻理解CPU运行模式，CPU寻址，用户态与内核态之间的切换
- 深刻理解屏幕驱动底层实现，printf,printk底层实现
- 深刻理解物理内存，虚拟内存，CPU的段页机制，CPU的运行逻辑
- 深刻理解中断的底层实现，键盘中断，时钟中断底层实现
- 深刻理解任务切换，线程上下文，系统调用
- 64位CPU的段页门机制，多核中断控制芯片，多核任务切换机制

## OS原理
```
https://www.bilibili.com/video/BV1N741177F5
https://www.bilibili.com/video/BV1bf4y147PZ
```

## 开发OS环境搭建
调试汇编使用bochs
调试C语言使用qemu

初期练手汇编使用OD





# 环境搭建

## 安装nasm

``````bash
apt install -y nasm
``````



## 安装bochs

作用：调试汇编，GDT，IDT，分页等，必须用bochs

必须安装bochs2.7



1. 先安装依赖

``````
apt install libx11-dev build-essential xorg-dev libgtk2.0-dev libreadline-dev 
``````



2. 配置

``````
./configure --with-x11 --with-x --enable-all-optimizations --enable-readline --enable-debugger-gui --enable-x86-debugger --enable-a20-pin --enable-fast-function-calls --enable-debugger
``````



3. 编译

``````
make -j4 (-j后面跟CPU数，加快编译速度)
make install (必须root权限执行)
``````



## 安装qemu

作用：调试C语言可以用qemu，也只能用qemu

``````bash
apt install -y qemu
``````





# 汇编
## 汇编学到什么程度才能熟练使用
能够非常熟练的实现以下功能，就代表你能熟练使用汇编

1. 熟练学出函数：无参无返回值，无参有返回值，有参有返回值
2. 声明变量：全局变量，局部变量
3. 实现运算：基本运算，位运算
4. 熟练实现条件判断
5. 熟练实现循环结构

思考：为什么没有提到实现数组，字符串，结构体




## C语言学的OK的标准
- 给一段C语言函数，能写出对应的汇编代码
- 运行时，给一个函数，能够写出函数在内存中的运行图




## 学习汇编的意义
任何操作系统的开头部分一定是用汇编
操控硬件几乎只能用汇编

有些控制使用汇编比C语言更容易

扩展：云原生概念：
将java代码不经过虚拟机，直接编译为机器码，即为原生代码



## CPU架构、指令集、汇编、硬编码之间的关系
### CPU架构

1. CISC（复杂指令集）
   1. Intel芯片
2. RISC(精简指令集)
   1. ARM芯片
   2. MAC M1、M2



### 指令集

- 指令集(Instruction Set Architecture, ISA)可以看做是一组约定的二进制数字(机器码)和CPU动作之间的关系集合

#### 指令集如何工作
指令集为每个操作分配了一个唯一的二进制编码

| 二进制指令编码 | 指令名称 | 功能           | 备注                 |
| -------------- | -------- | -------------- | -------------------- |
| `0b00000001`   | ADD      | 加法运算       | 对寄存器的两个值求和 |
| `0b00000010`   | SUB      | 减法运算       |                      |
| `0b00000011`   | LOAD     | 从内存加载数据 |                      |
| `0b00000100`   | STORE    | 存储数据到内存 |                      |
|                |          |                |                      |

#### 指令执行流程

当CPU读取这些二进制指令后，按照以下步骤执行：

- 取指(Fetch)：从内存中取出下一条指令
- 译码(Decode)：根据指令集的约定，将二进制编码解析为具体的操作
- 执行(Execute)：根据指令的含义，由CPU内部的硬件电路完成对应的动作



### 汇编风格

相同的指令集，可能有不同的汇编风格对应相同的硬编码

相同的CPU架构，不同的操作系统，它们的指令集相同，但是汇编风格是不同的

**大多数情况下**：汇编语言中的每条指令对应于指令集中的一条机器指令，因此可以近似看作是一一对应的。

**例外情况**：由于伪指令、指令变体等原因，汇编语言的某些指令可能映射为多条或不同的机器指令。



#### 汇编风格举例

- Intel
  - MASM（Windows平台默认）
  - NASM（MASM的扩展）
  - ATT
    - Linux源码使用的是ATT风格的汇编
- ARM



### 机器码（硬编码）结构

逆向必学

``````
https://www.bilibili.com/video/BV1bh4y1r7oG
``````



## 寄存器、CPU缓存、内存之间的关系

 

## CPU包含哪些寄存器

- 通用寄存器
  - x86（32位）: rax、rbx、rcx、rdx、rsi、rdi、rbp、rsp（rbp、rsp这两个寄存器和栈相关）
  - x64新增：r8、r9、r10、r11、r12、r13、r14、r15
- 段寄存器
  - cs、ss、ds、es、fs、gs
- 指令寄存器 (X86 **EIP**、X64 **RIP**)
  - 指向下一个程序执行的地址
- 标准寄存器 (X86 eflags、X64 rflags) **状态寄存器**
- 控制寄存器 (CR0 - CR4、CR3页表)
  - CR0：用来控制CPU的模式切换，CPU的模式从实模式--->保护模式--->32位兼容模式--->64位长模式
- 调试寄存器 (DR0 - DR7)
- 描述符寄存器（GDTR、LDTR、IDTR）
- 任务寄存器（TR）
  - 用户态切内核态的时候，需要切栈，需要使用TR寄存器

......（x64 CPU有新增寄存器，如型号专属寄存器）



### 通用寄存器

#### rax寄存器

**作用：存放函数返回值**

- **rax** ：64位     8B     只有64位CPU才有，**特殊用途：函数返回值（默认的）非常重要**
  -   **eax**：32位      4B     32位、64位CPU都有
    - **ax**：16位       2B       16位、32位、64位CPU都有
      - **ah**：8位    8位、16位、32位、64位CPU都有
      - **al**：8位   8位、16位、32位、64位CPU都有



- 通用寄存器中，只有rax，rbx，rcx，rdx有高8位和低8位，比如(ah,al;bh,bl...)，除此之外，只有低8位，没有高8位
- 



#### rcx寄存器

- **作用：**
  - **记录循环次数**
  - **this指针（C++）**



#### rsi(source)寄存器

- 作用：用于做数据的拷贝，存放开始的位置
  - 拷贝内存的时候，将开始的位置存放在rsi寄存器中



#### rdi(destination)寄存器

- 作用：用于做数据的拷贝，存放结束的位置
  - 拷贝内存的时候，将结尾的位置存放在rdi寄存器中



#### rbp,rsp寄存器

- 作用：栈寄存器
- push和pop会影响这两个寄存器



### C到汇编转换

``````C
int a = 10;
a += 1;

// 只用一个寄存器实现
push eax        // 将eax寄存器压栈
xor eax, eax    // 将eax寄存器清零
    
mov eax, 0x0a
add eax, 0x1
mov [ebp - 8], eax
// 后续学习，需要将结果写进内存
    
    
// 用多个寄存器实现
xor eax, eax
xor ebx, ebx
mov eax, 10
mov ebx, 1
add eax, ebx
``````



### 扩展：Bochs断点

``````
xchg bx bx
``````





