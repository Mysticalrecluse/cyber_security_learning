# 解析式和生成器表达式

# 列表解析式
a = [x ** 2  for x in range(10)]
print(a)

b = [(i+1,i) for i in range(10)]
print(b) # [(1, 0), (2, 1), (3, 2), (4, 3), (5, 4), (6, 5), (7, 6), (8, 7), (9, 8), (10, 9)]
d = dict(b)
print(d) # {1: 0, 2: 1, 3: 2, 4: 3, 5: 4, 6: 5, 7: 6, 8: 7, 9: 8, 10: 9}

# 如果含有else,或者elif，则不能使用列表解析式
c = [(i, j) for i in range(7) if i > 4 for j in range(20, 25) if j > 23]
print(c) # [(5, 24), (6, 24)]

# 格式转换
l = [str(i) for i in range(5)]
print(l) # ['0', '1', '2', '3', '4']

l2 = list(map(str, range(5)))
print(l2) # ['0', '1', '2', '3', '4']

# 集合解析式
a = {x ** 2 for x in range(10)}
print(a) # {0, 1, 64, 4, 36, 9, 16, 49, 81, 25}

# 字典解析式
d = {i: i + 1 for i in range(10)}
print(d) # {0: 1, 1: 2, 2: 3, 3: 4, 4: 5, 5: 6, 6: 7, 7: 8, 8: 9, 9: 10}


# 扩展函数介绍：chr()和ord()函数
# chr()函数，返回指定整数对应的字符
# chr(i) -> str
print(chr(97)) # a
print(chr(65)) # A

# ord()函数，返回指定字符对应的整数
# ord(c) -> int
print(ord('a')) # 97
print(ord('A')) # 65
print(ord('啊')) # 21834
print(hex(ord('啊'))) # 0x556a ,hex(),bin(),oct()返回值都是字符串

print([chr(x) for x in range(65, 70)]) # ['A', 'B', 'C', 'D', 'E']

d1 = {chr(i): i for i in range(65, 70)}
print(d1) # {'A': 65, 'B': 66, 'C': 67, 'D': 68, 'E': 69}

# 生成器
# 生成器表达式
a = (x ** 2 for x in range(10))
print(hex(id(a))) # 0x7f9a2c3d5e40
print(a) # <generator object <genexpr> at 0x7f9a2c3d5e40>

x = (i for i in range(5))
print(x) # <generator object <genexpr> at 0x7f9a2c3d5e40>
for i in x:
    print(i, end=" ") # 0 1 2 3 4
print("---------")
for i in x:
    print(i, end=" ") # 无输出,生成器只能迭代一次

# 生成器相关函数
# next()函数，返回生成器的下一个元素
# next(generator) -> next value
x = (i for i in range(5))
print(next(x)) # 0
print(next(x)) # 1
for i in x:
    print(i, end=" ") # 2 3 4, 生成器只能迭代一次,之前已经迭代了0,1

# 列表是可迭代对象，但是不是迭代器
# 可迭代对象：可以使用for循环遍历的对象
# 迭代器：可以使用next()函数获取下一个元素的对象
# 生成器是迭代器，也是可迭代对象，生成器是一种特殊的迭代器
# 迭代器的特点：惰性计算，节省内存，本质：指针不能回头，只能往前走
# 惰性计算：只有在需要的时候才计算，不需要的时候不计算
# for循环可以迭代生成器，但如果已经到头，再次迭代相当于迭代空列表，但是next()函数会报错
# 解决方案：next(x, default),使用default参数，当迭代结束时，返回default参数
x1 = (i for i in range(5))
for i in x1:
    print(i, end=" ") # 0 1 2 3 4
print("---------")
print(next(x1, "end")) # end
print(next(x1, "end")) # end

# 迭代器不可索引，不可切片
# range()不是迭代器，是可迭代对象，可以索引，可以切片
print(range(5)[2]) # 2

# 列表和生成器的区别
# 列表：占用内存大，一次性生成所有元素，占用内存大
# 1. 列表立即构建，元素都在了，可以反复使用；生成器对象会立即构建，但是元素不会立即生成，起初只是一个空壳，只有在调用next()函数时，才会生成元素
# 2. 内存：列表元素内存立即都占用了；生成器的内存只占用一个生成器对象的大小的内存
# 3. 速度：列表生成速度快，生成器生成速度慢，因为列表中元素都已经生成，生成器中元素还没有生成，需要调用next()函数生成
# 从内存和速度上来说，生成器更优秀，但是生成器只能迭代一次，列表可以反复迭代，所以在需要反复迭代的情况下，使用列表，否则使用生成器
# 可迭代对象可以通过iter()函数转换为迭代器

# 列表解析式是一种语法糖
## 编译器会优化，不会因为简写而影响效率，反而有略微提高
## 减少了程序员的工作量，提高了代码的可读性

# 生成器表达式和列表解析式的对比
## 计算方式：生成器表达式惰性计算，列表解析式立即计算
## 内存占用：
### 单从返回值本身来看，生成器表达式省内存，列表解析式返回新的列表
### 生成器表达式没有数据，内存占用少，使用的时候，一次返回一个数据，只会占用一个数据空间
### 列表解析式构造新的列表，需要为所有元素立即占用掉内存

## 计算速度
### 单看计算时间，生成器表达式耗时非常短，列表解析式耗时较长
### 但生成器本身并没有返回任何值，只返回了一个生成器对象
### 列表解析式构造并返回了一个新的列表

# sorted
# sorted(iterable, key=func, reverse=False) -> list
# 生成器也是可迭代对象，可以使用sorted()函数进行排序

# key参数,指定排序的规则,默认为None,但不改变原列表
sorted(dict(a=1, b='123', c=200).value(),key=str) # [1, 200, '123']
