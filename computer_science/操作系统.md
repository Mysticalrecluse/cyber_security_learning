# 操作系统



## 进程

### 进程的组成与特征

#### 进程的概念

- **程序 (Program)**
  - 是**静态的**，就是个存放在磁盘里的可执行文件，如：Tim.exe
- **进程 (Process)**
  - 是**动态的**，是程序的一次执行过程，如：可同时启动多次Tim程序

```ABAP
同一个程序多次执行会对应多个进程
```

 

#### 进程的组成

- **进程控制块（PCB）**

  - 进程描述信息
  - 进程控制和管理信息
  - 资源分配清单
  - 处理机相关信息

  

- **程序段**

  - 程序的代码（指令序列）

  

- **数据段**

  - 运行过程中产生的各种数据（如：程序中定义的变量）

  

```ABAP
PCB是给操作系统用的
程序段、数据段是给进程自己用的
```





#### 进程的组成 — PCB

当进程被创建时，操作系统会为该进程分配一个唯一的，不重复的”身份证号“ — PID（Process ID，进程ID）

- 操作系统要记录PID
- 进程所属用户ID（UID）
- 记录给进程分配了哪些资源
  - 分配了多少内存
  - 正在使用哪些I/O设备
  - 正在使用哪些文件
- 记录进程的运行情况
  - CPU使用时间
  - 磁盘使用情况
  - 网络流量使用情况

```ABAP
这些信息都被保存在一个数据结构PCB(Process Control Block)中，即进程控制块
操作系统需要对各个并发运行的进程进行管理，但凡管理时所需要的信息，都会被放在PCB中
```

```ABAP
程序段、数据段、PCB三部分组成了进程实例（instance）（进程映像image）
进程是进程实体（程序）的运行过程，是系统运行资源分配和调度的一个独立单位
```





**PCB组成**

PCB是进程存在的唯一标志，当进程被创建时，操作系统为其创建PCB，当进程结束时，会回收其PCB

![image-20250120093524820](D:\git_repository\cyber_security_learning\markdown_img\image-20250120093524820.png)

```ABAP
范例：
同时挂三个QQ号，对应三个QQ进程，它们的PCB，数据段各不相同，但是程序段的内容是相同的（都是运行着相同的QQ程序）
```



#### 进程的特征

- **动态性：**进程是程序的一次执行过程，是动态地产生、变化和消亡的
- **并发性：**内存中多个进程实体，各进程可并发执行
- **独立性 *：**进程是独立运行，独立获得资源，独立接收调度的基本单位
- **异步性：**各进程按各自独立的，不可预知的速度向前推进，操作系统要提供“**进程同步机制**”来解决异步问题
- **结构性：**每个进程都会配置一个PCB。结构上看，进程由程序段、数据段、PCB组成





### 进程的状态与转换



#### 创建态与就绪态

创建态是一种**瞬时状态**，创建过程中，不会长期处于创建状态，它并不是一个瞬时状态。

![image-20250120114455939](D:\git_repository\cyber_security_learning\markdown_img\image-20250120114455939.png)



#### 运行态

![image-20250120114750714](D:\git_repository\cyber_security_learning\markdown_img\image-20250120114750714.png)



根据上述情景，当CPU运行到**指令3**，但此时打印机资源被占用，在获得所需资源之前，进程无法在继续进行，于是就会进入**阻塞态**



#### 阻塞态

![image-20250120115243474](D:\git_repository\cyber_security_learning\markdown_img\image-20250120115243474.png)

当阻塞态的进程，得到了所需资源，但由于没有CPU资源，因此进入**就绪态**

在进程运行的过程中，可能会**请求等待某个事件的发生**（如等待某种系统资源的分配，或者等待其他进程的响应）

在这个事件发生之前，进程无法继续往下执行，此时系统会让这个进程下CPU，并让它进入“**阻塞态**”

当CPU空闲时，又会选择另一个“就绪态”进程上CPU





#### 终止态

![image-20250120115811226](D:\git_repository\cyber_security_learning\markdown_img\image-20250120115811226.png)

一个进程可以执行exit系统调用，请求操作系统终止该进程。此时该进程会进入“**终止态**”，操作系统会让该进程下CPU

并回收内存空间等资源，最后还要回收该进程的PCB，当终止进程的工作完成后，这个进程就会彻底消失

```ABAP
进程PCB中，会有一个变量state来表示进程的当前状态。如：1表示创建态、2表示就绪态...
为了对同一个状态下的各个进程进行统一管理，操作系统会将各个进程的PCB组织起来
```



### 进程组织

根据前面所述，可以看到进程在不同的状态之间进行切换，操作系统为了能够管理状态的切换，他就需要一种方式把不同状态的进程组织起来

在操作系统中，进程的组织有两种方式

- 链接方式



#### 链接方式（Linked List）

![image-20250120141827450](D:\git_repository\cyber_security_learning\markdown_img\image-20250120141827450.png)



在就绪队列中，通常会把优先级高的进程放在队列前面

而对于阻塞队列，操作系统会根据阻塞原因不同，在分为多个阻塞队列

![image-20250120142342641](D:\git_repository\cyber_security_learning\markdown_img\image-20250120142342641.png)







#### 索引方式（Red-Black Tree / IDR）

![image-20250120142534262](D:\git_repository\cyber_security_learning\markdown_img\image-20250120142534262.png)

**总结**



![image-20250120142613402](D:\git_repository\cyber_security_learning\markdown_img\image-20250120142613402.png)



#### 查看进程组织的内核实现

进程的核心数据结构是 `task_struct`，以下字段反映了组织方式：

- **链表字段**：旧版本的内核中，`task_struct` 包含 `tasks` 字段，用于双向链表。
- **红黑树字段**：现代内核中，`task_struct` 包含 `rb_node`，用于红黑树管理。

```bash
[root@es-node1 ~]# cd /usr/src/linux-headers-$(uname -r)/
[root@es-node1 /usr/src/linux-headers-5.15.0-102-generic]# grep -rn 'rb_node' include/linux/sched.h
530:	struct rb_node			run_node;
582:	struct rb_node			rb_node;
782:	struct rb_node			core_node;
854:	struct rb_node			pushable_dl_tasks;
```





### 进程控制

#### 什么是进程控制

进程控制的主要功能是对系统中的所有进程实施有效的管理，它具有创建新进程、撤销已有进程，实现进程状态转换等功能

**简单理解：进程控制就是要实现进程状态转换**

![image-20250120143625793](D:\git_repository\cyber_security_learning\markdown_img\image-20250120143625793.png)





#### 如何实现进程控制

![image-20250120143742813](D:\git_repository\cyber_security_learning\markdown_img\image-20250120143742813.png)

**操作系统使用原语实现进程控制**

- 为什么要用“原语”实现？
  - 原语的执行具有“原子性”，一气呵成
- 为何进程控制（状态转换）的过程要“一气呵成”
  - 如果不能“一气呵成”，就可能导致操作系统中的某些关键数据结构信息不统一的情况，这会影响操作系统进行别的管理工作



![image-20250120144442004](D:\git_repository\cyber_security_learning\markdown_img\image-20250120144442004.png)



假设此时进程2等待的事件发生，则操作系统中，负责进程控制的内核程序至少需要做两件事

- 将PCB2的state设为1
- 将PCB2从阻塞队列放到就绪队列中



```ABAP
如果完成第一步后，收到中断，那么PCB2的state=1，但仍然处于阻塞队列中
```



#### 如何实现原语的”原子性“

原语的执行具有原子性，即执行过程中只能一气呵成，期间不允许被中断

可以用 “**关中断指令**” 和 “**开中断指令**” 这两个**特权指令**实现原子性

![image-20250120144927878](D:\git_repository\cyber_security_learning\markdown_img\image-20250120144927878.png)



在操作系统中，每一次指令执行完，都会检查是不是有中断发生，如果有中断发生，就会终止当前发生的程序，去响应中断信号（这个是**操作系统设计的核心思想**之一）

```ABAP
这里的指令值得是汇编指令流里面的指令
```

而原语通过在执行过程中，关中断指令，实现了指令流的原子性，避免被中断信号中断

当原语执行完成后，再开中断指令，响应外部中断信号

```ABAP
中断程序结束后，不一定会直接回原进程执行
比如：程序遇到除0操作，会触发中断，中断执行后，并不会回到原先的错误程序，而是直接杀死进程
```





### 进程控制原语



#### 创建原语



![image-20250120150011182](D:\git_repository\cyber_security_learning\markdown_img\image-20250120150011182.png)



#### 撤销原语

<img src="D:\git_repository\cyber_security_learning\markdown_img\image-20250120152207690.png" alt="image-20250120152207690" style="zoom:25%;" />

- **僵死态**：zombie，结束进程，父进程结束前，子进程不关闭

  - 既不占有CPU资源，也仅占用极少的内存
  - 进程列表中存在，重启时会从进程列表中清除
  - 死的进程，无法再次杀死
  - 实现

  ```bash
  echo $BASHPID
  # 1436
  bash
  echo $BASHPID
  # 1809
  echo $PPID
  # 1436
  
  kill -19 1436 # 将父进程变为停止态 stat为T
  kill -15 1809 # 给子进程发送后一个15信号，15信号为正常结束关闭进程
  # 关闭进程后，回收该进程所有资源
  # 正常关闭进程后，该进程应该在进程列表中清除，但是由于父进程为停止态，无法回收子进程的尸体，因此子进程变为了僵尸态 
  
  kill -18 1436 # 激活父进程
  # 由于父进程被激活，因此子进程的被回收，子进程从进程列表清除
  
  # 强杀父进程的时候，可以将子进程也杀死
  ```

  

- **孤儿进程**：

  - 父进程创建了子进程，子进程还活着，父进程死了，通常孤儿进程会被`init/systemd`1号进程接管

- **闲逛进程**：

  - 什么都不做，在CPU上走一趟
  - 用于在整个系统没有任何就绪进程需要运行的时候，（CPU不能一直空着），因此操作系统创建一个闲逛进程，去占用当前CPU



#### 阻塞与唤醒原语



![image-20250120154158861](D:\git_repository\cyber_security_learning\markdown_img\image-20250120154158861.png)

```ABAP
保护进程现场：将当前进程的状态信息保存在内存或寄存器中
```



##### 切换原语

<img src="D:\git_repository\cyber_security_learning\markdown_img\image-20250120154646048.png" alt="image-20250120154646048" style="zoom:25%;" />



```ABAP
进程的上下文信息，在刚开始的时候，存放在CPU上（CPU上有很多寄存器，在程序运行过程中，寄存器上会存储各种值）
当进程发生切换时，需要把这些信息存放到PCB中，然后把PCB移到下相应的队列中
然后在就绪队列中，找出一个新的PCB，将它放到CPU上，并更新PCB的值
并根据新的PCB恢复运行上下文
```



### 进程调度

#### 处理机调度 — 调度的基本概念

调度案例：

银行处理用户服务时，普通用户先来先服务；VIP用户优先被服务



**调度的前提：资源是优先的**

```ABAP
当有一堆任务要处理，但由于资源有限，这些事情没法同时处理。这就需要确定某种规则来决定处理这些任务的顺序，这就是“调度”研究的问题
```



#### 进程调度的时机

**进程调度（低级调度）**：就是按照某种算法从就绪队列中选择一个进程为其分配处理机。

![image-20250120163356202](D:\git_repository\cyber_security_learning\markdown_img\image-20250120163356202.png)

```ABAP
临界资源：一个时间段内只允许一个进程使用的资源，各进程需要互斥的访问临界资源
临界区：访问临界资源的那段代码

内核程序临界区一般是用来访问某种内核数据结构的，比如进程的就绪队列（由各就绪进程的PCB组成）
```





### 线程



#### 线程概念

线程（Threads），是比进程更小的概念，也称为轻量级进程（Light Weight Process, LWP），是将进程进一步细分的单位。

 在多道程序操作系统中，引入进程的概念。用于解决单处理器环境中程序的并发执行问题。

为了进一步提高程序的并发执行程序，又引入了线程的概念，一个进程可以同时拥有多个线程，借助多个线程实现程序的并发执行。



未引入线程概念时，进程有两个特点：是`资源所有权`和`调度/执行`的单位。

- 前者指一个进程拥有对资源的控制和所有权，包括内存，I/O通道、I/O设备等
- 后者指进程是一个可以被操作系统调度的独立实体。



```ABAP
在引入线程前，进程是操作系统调度的做小单位；
在引入线程且是操作系统内核支持的线程后，线程是操作系统调度的最小单位。
同时进程仍是操作系统分配资源的最小单位，线程的引入并未改变进程资源所有权这一点
```



#### 线程的优势

- **进一步提高并发性**
  - 线程可以进一步细化进程中的各种任务，提高任务的并发性。在单处理器系统中，线程模型可以分离同一个进程内的CPU计算和I/O访问，让它们并发进行
  - 在多处理器系统中，引入线程模型前，无论有多少处理器，和一个进程只能占用一个处理器；引入线程模型后，每个线程都能占用一个处理器，这使得多处理器系统的优势得以充分发布
- **共享地址空间与可用数据**
  - 进程间由于相互的"隔离"，无法直接共享数据，这就带来了进程间通信的问题。而线程模型的引入，使得并行实体拥有了共享地址空间、数据的能力。换言之，线程之间可以直接共享数据而不需要经由操作系统内核，在速度上有很大优势
- **线程更轻量级**
  - 线程无论是创建、切换还是撤销，都远快于进程。在很多操作系统中，一个线程中创建比进程的创建快10~100倍
  - 在短时间需要反复开启或撤销大量线程时，线程的轻量级是十分有优势的。
- **提高交互性**
  - 线程还能提高图形界面程序的交互性，避免程序"卡死"





#### 线程与进程间比较

```C
main() {
    ComputePI("Pi.txt");
    PrintClassList("classlist.txt");
}
// ComputerPI一直不结束，我们就一直看不到classlist.txt的执行结果
```

```C
// 线程是程序中一个单一的顺序控制流程
// 程序中创建了两个线程：两个独立的执行控制流程
main() {
    create_thread(ComputePI, "pi.txt");
    create_thread(PrintClassList, "classlist.txt")
}
// create_thread
// 创建了一个线程，仿佛在另外一个处理器执行ComputerPI函数中的控制流程
// 又创建了一个线程，仿佛在另外一个处理器上执行PrintClassList函数中的控制流程
```

![image-20250120105003290](D:\git_repository\cyber_security_learning\markdown_img\image-20250120105003290.png)


```ABAP
在一个进程中，多线程共享code,data,files，但是寄存器和栈是私有的
寄存器和栈是每个线程独立拥有的资源，这里的拥有不是指物理层面的拥有，而是指各自记录自己的寄存器和栈中的值，而这些值记录在TCB中
```



#### 线程的应用

一个应员工中的多个任务可以分离成多个线程，增加应用的资源占有率，提高响应速度和交互性

**文字处理word**

- 显示线程
- 读数据线程
- 拼写检查线程



**在线播放器**

- 一个线程音频解码
- 一个线程视频解码
- 一个线程网络接收



**浏览器**

- 一个线程显示图形和文字
- 另一个线程从网络接收数据





#### 线程的三种基本状态

和传统进程相似，线程也有三个基本状态：执行态、阻塞态、就绪态。线程状态之间的转换和进程之间的转换是一样的

- **执行态**：在该状态下，线程获得处理器并运行
- **就绪态**：表示线程可以被调度执行，被分配处理器就可以执行工作
- **阻塞态**：指线程在执行过程中，因为某些事件而阻塞并等待



#### 线程控制块 — TCB

每个线程具有一个对应的线程控制块（Thread Control Block，TCB），用于控制和管理线程的状态，保存线程的信息。

**线程控制块中有一下几类信息**

- **线程标识符（TID）**。每个线程的唯一标识符
- **寄存器信息。**用来记录包括通用寄存器，程序计数器，状态寄存器等关键寄存器信息
- **线程执行状态**
- **优先级**，用于线程调度
- **线程专有存储区**，用于线程切换时保存现场信息
- **信号屏蔽**。每个线程拥有各自的信号屏蔽字。
- **堆栈指针**



#### 线程的实现

- **内核级线程**（Kernel Level Threads）

- **用户级线程**（User Level Threads）



##### **用户级线程（ULT）**

![image-20250120112928192](D:\git_repository\cyber_security_learning\markdown_img\image-20250120112928192.png)

**用户级线程的优点**

- **可以在不支持线程的操作系统中实现线程**。具体实现上，主要通过用户空间的线程库实现，应用程序使用线程库进行多线程设计，进程成通过调用函数开启多线程
- **可以允许进程自主定制调度算法**。操作系统只负责把处理器与其他资源分配给进程，由进程继续将这些资源分配给该进程创建的线程，线程的调度与资源分配都由进程自主完成，可以更好地安排各个线程的工作，也使得线程具有更好的扩展性
- **线程的切换完全在本进程中完成，而没有内核的参与**，所以这种实现方式的效率更高



**用户级线程的缺点**

- 一旦某个线程阻塞，该线程所属的整个进程都会被阻塞
- 如果只使用用户级线程，一个多线程程序不能利用多处理器技术。因为操作系统只会为一个进程分配一个处理器，所以一个进程中只能有一个线程处于执行状态



##### 内核级线程（KLT）

![image-20250120112710513](D:\git_repository\cyber_security_learning\markdown_img\image-20250120112710513.png)

**内核级线程的优点**

- 在多处理系统中，内核可以调度一个进程内的多个线程到多个处理器上运行
- 当一个线程被阻塞，内核可以调度该进程中的另一个线程到处理器上运行
- 操作系统内核自身可以使用多线程



**内核级线程的缺点**

- 线程切换时，需要内核介入。模式切换带来了额外开销。
- 用户级线程的性能 > 内核级线程 > 进程，且两两之间都有一个数量级及以上的性能差距





### 上下文切换

#### 进程间上下文切换

- **上下文切换定义**： 上下文切换是指在同一个 CPU 上从一个正在运行的进程切换到另一个进程所需的操作。
- **涉及的上下文信息**：
  - **进程上下文信息**存储在 **PCB**（Process Control Block）中。
  - PCB 保存的内容
    - CPU 寄存器（如程序计数器、通用寄存器等）
    - 虚拟内存映射表
    - 打开的文件描述符表
    - 信号处理状态
    - 优先级等调度信息
  - 上下文切换时
    - 保存当前进程的上下文信息到其 PCB 中。
    - 恢复目标进程的上下文信息，从其 PCB 中加载到 CPU。



#### 线程间上下文切换

- **线程与进程的关系**：
  - 线程是进程中的执行单元，同一进程内的多个线程共享进程资源（如内存空间、文件描述符等）。
  - 因此，线程间上下文切换涉及的是 **线程独有的上下文**。
- **线程上下文信息**存储在 **TCB**（Thread Control Block）中。
  - TCB 保存的内容：
    - CPU 寄存器状态
    - 线程栈指针
    - 线程私有数据
    - 线程状态（如 READY, RUNNING 等）
  - 上下文切换时：
    - 保存当前线程的上下文信息到其 TCB 中。
    - 恢复目标线程的上下文信息，从其 TCB 中加载到 CPU。



#### 区别：进程与线程的上下文切换

- **开销**：

  - **进程上下文切换**比**线程上下文切换**开销大。

  - 原因是线程共享进程资源，因此线程切换时无需切换内存页表、文件描述符表等。

- **涉及的资源**：

  - **进程切换**需要切换整个地址空间、虚拟内存映射等。

  - **线程切换**只需切换寄存器状态和线程私有数据。

- **调度器**：

  - 进程调度由内核的 **进程调度器**完成。

  - 线程调度可以由用户态的线程库完成（如用户线程）或内核完成（如内核线程）。