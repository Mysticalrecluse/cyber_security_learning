# GFW防火墙阻断原理



GFW是7层网络设备，因此最高可以解析到应用层网络报文。



![image-20250801094948016](D:\git_repository\cyber_security_learning\markdown_img\image-20250801094948016.png)



## 国内客户端访问Google的过程



### 可能拦截的情况1：DNS污染（DNS拦截）

1. 客户端访问`www.Google.com`，敲下回车的一瞬间，会先检查本地的DNS缓存里面有没有保持 google.com 的IP地址（即 `www.google.com` 的域名解析条目），如果没有的话，会去寻找hosts的文件。如果都没有的话，他就会向你的本机电脑配置的DNS服务器发送DNS请求，去查询解析的iP地址

   > 本地 DNS 缓存是第一层，`hosts` 文件条目会预加载到缓存中并拥有最高优先级。若缓存中没有对应记录，系统会按照 `/etc/nsswitch.conf` 或 Windows 客户端的解析顺序检查 `hosts` 文件；只有两者都未命中时才会向配置的 DNS 服务器发送请求。需要注意的是，某些浏览器或应用实现了自己的 DNS 解析器，可能会绕过系统的 `hosts` 文件或缓存，这时 `hosts` 条目不会生效

   ```bat
   1. 检查本地缓存
   2. 查看/etc/hosts
   3. 向DNS服务器发送请求数据包 --> 查询IP地址
   ```

   

<img src="D:\git_repository\cyber_security_learning\markdown_img\image-20250801094857290.png" alt="image-20250801094857290" style="zoom:80%;" />

2. 本机上配置的DNS服务器地址是8.8.8.8，而8.8.8.8在国际互联网。在向8.8.8.8请求域名的解析的过程中，会经过GFW（<span style="color:gray">这里假设在向8.8.8.8申请google的域名解析的这个过程没有被GFW拦截，但实际上是可能会被拦截的</span>）。8.8.8.8域名服务器收到解析请求后，会将解析结果（比如`9.9.9.9`）返回给客户端，但是在返回的过程中，会经过GFW，这里GFW可以检查到数据包的内容，发现解析的是google的IP，于是会将解析结果改为`9.9.9.8` ，数据包返回客户端后，客户端拿到的是被修改后的解析结果，因此无法访问 `www.google.com`





### 基于DNS污染的解决方案1 — 修改hosts文件

修改hosts文件，是互联网早期的翻墙解决方案。以绕过GFW的DNS污染问题。

![image-20250801103201814](D:\git_repository\cyber_security_learning\markdown_img\image-20250801103201814.png)







### 可能拦截的情况2 — TCP 重置攻击



客户端在于服务端建立连接之前，需要进行TCP握手，提前建立连接。在建立连接的过程中，客户端发送数据包给 google 服务器。在国际互联网经过路由发现服务端不在国内，于是会经过GFW来到国际互联网。但是在经过 GFW 的时候，GFW会进行动作。之前讲过GFW是7层设备，可以解析应用层流量。而像IP的地址的信息，它只要解析到网络层就能知道你的意图。

数据包在经过 GFW 的时候，当解析到网络层的时候，发现你的数据包IP是（假设9.9.9.9，即Google的IP地址），而 GFW 的黑名单List里有该域名解析记录，于是会识别到你的意图，因此拦截掉这个数据包

或者它会伪造 google 服务器，返回给你一个数据包。（路由器可以做NAT修改里面的IP地址），因此 GFW 可以很容易做到这点，于是 GFW 伪造成 Google 服务器给你返回一个信息“滚蛋”。并将数据包返回给客户端。客户端看到收到的数据包是“滚蛋”，于是放弃与 Google 连接。但实际上，该数据包信息是 GFW 伪造的。这种情况就叫做 TCP 重置攻击



### 基于 TCP 重置攻击的解决方案1 — 修改IP地址，使用黑名单上没有的IP地址

通常，google服务器上会有多个可以连接的IP地址，如果某个IP地址在 GFW 的黑名单之外，则可以成功进行TCP连接。





### 可能拦截的情况3 — 关键字过滤（Keyword Filtering）

虽然通过上面的手段，可能可以成功建立TCP连接后，当后续进行 http 通信时，GFW 会检查 HTTP 请求中的明文 URL、主机名或敏感关键字（如特定路径、参数）。

其实现的原理是：基于 DPI（深度包检测），在 TCP 层分析 HTTP 请求，检测敏感字符串。

> GFW在网关处实时分析数据包内容，判断是否为 VPN（OpenVPN、Shadowsocks）、Tor 等流量特征。
>
> 使用模式匹配、流量特征检测（如握手字节序列）来识别加密隧道。
>
> 即便是 TLS 流量，也可能因为 SNI（Server Name Indication）暴露目标域名而被识别。
>
> 解决方案：流量混淆、TLS ESNI/Encrypted ClientHello 等技术可以部分规避



当发现该数据包是访问 Google 服务器的时候，可能会进行 RST 包注入。从而使连接中断。

当使用RST包注入中断连接时，浏览器会出现“连接被重置”错误。





### 基于  RST 包注入的解决方案 — 重连

RST 注入只会中断当前 TCP 连接，重连可能成功；某些 VPN 使用随机化和混淆可降低被检测概率。







### 基于“代理”的解决方案 

部署一台代理服务器，让代理服务器帮你访问 Google，因为代理服务器和Google服务器都在国际互联网，因此相互通信并不经过 GFW，而代理服务器不在GFW的拦截名单，因此可以实现通过代理服务器访问国际互联网。

但是当你向代理服务器发送数据包的时候，无论是使用http还是socket，都会因为数据包内容（比如：帮我访问Google服务器），从而被GFW识别意图，从而拦截，甚至将代理服务器加入黑名单。





### 基于代理失效的解决方案 — 加密

常见的加密手段：IPSec，OpenVPN等



但是这些加密虽然可以隐藏数据包意图，但是这些加密的特征非常明显。GFW 可以很容易发现这个数据包的特征。因为VPN本身不是用于翻墙的，而是用于合并公司内网的，因此 GFW 并不会马上封锁拦截这个数据包，但是会将这个 IP 加入监控列表中，后续会起进行持续性监控。当这个你和这个IP进行长时间的大流量访问时，就可能被GFW阻断。



那么如何既能加密，有没有特征呢？



### shadowsocks一个为翻墙而生的协议

**shadowsocks** 该协议发明的目的就是为了绕过防火墙检查，因为该协议既能完成加密，同时有没有明显特征

#### **Shadowsocks (SS) 设计初衷**

- **发明者**是中国程序员 clowwindy（2012 年左右）。
- **目的**：为突破 GFW 对国际网络流量的审查与干扰。
- **设计理念**：相比于传统 VPN（OpenVPN、PPTP）具有显著协议特征，Shadowsocks 采用了**代理 + 流量加密 + 无明显特征**的方式，尽量让其流量看起来像普通的 HTTPS/TCP 流量。



#### **Shadowsocks 的技术特点**

1. **基于 SOCKS5 代理**：
    SS 在客户端与服务器之间建立一个加密隧道，客户端使用本地 SOCKS5 代理转发流量。
2. **对称加密 + 流量混淆**：
   - 使用 AES-256-GCM、ChaCha20-Poly1305 等现代对称加密算法。
   - 加密后数据包不含可见的协议头部信息，使 DPI 难以直接识别。
3. **无固定握手特征**（原始 SS）：
   - 原版 SS 设计时没有像 OpenVPN 那样固定握手流程，因此**初期 GFW 难以通过特征识别封锁**。



#### ❗ **后来为什么 GFW 仍然能检测到 Shadowsocks？**

- **流量模式仍然存在统计特征**：即使加密，SS 的数据包大小、时间间隔等可被 GFW 通过流量行为分析检测。
- **无认证防探测**：原始 SS 在握手时没有验证机制，GFW 可以主动探测（发送伪客户端请求），若服务器返回符合 SS 协议的响应，就能确认并封锁。
- **DPI 特征更新**：近年来 GFW 的 DPI 能通过特定模式匹配（如初始握手包特征）识别未混淆的 SS。





#### **演化与对策**

- **ShadowsocksR (SSR)**：在 SS 的基础上加入混淆插件、伪装 HTTP/TLS 流量，增加检测难度。
- **V2Ray (VMess/VLESS)**：支持多层混淆、TLS 封装（看起来像普通 HTTPS 流量）。
- **Trojan**：完全伪装成合法的 TLS 流量（几乎不可区分）。





## GFW 主动探测的情况

### **量行为分析与主动探测（Active Probing）**

- **原理**：当怀疑某个 IP/端口运行代理（如 Shadowsocks），GFW会主动发起探测连接（模拟客户端），确认是否是被封禁的服务。
- **实现方式**：GFW扫描可疑服务器，发送特定握手包探测是否响应代理协议。
- **特征**：Shadowsocks/Trojan 如果没有混淆，可能被快速探测并封锁。
- **局限性**：增加认证/混淆（如 obfs、V2Ray 的 VMess+TLS）可降低探测成功率。





### 流量特征封锁（Statistical & Heuristic Filtering）

- **原理**：基于统计特征（包大小、时间间隔、握手模式）判断是否为 VPN/代理流量，即使其内容加密。

- **实现方式**：分析 TLS 握手指纹（JA3）、TCP 行为等特征进行分类。
- **特征**：表现为部分 VPN 连接成功率降低或延迟异常。
- **局限性**：使用随机化和混淆协议（如 TLS camouflage）能缓解。







# 项目实验



## shadowsocks服务部署



**ss协议采用的是对称加密**



### 通信原理

![image-20250801121354860](D:\git_repository\cyber_security_learning\markdown_img\image-20250801121354860.png)







### 搭建部署

```bash
# 直接apt安装
[root@ubuntu2204 ~]# apt install shadowsocks-libev

# 查看运行状态
[root@ubuntu2204 ~]# systemctl status shadowsocks-libev.service 
● shadowsocks-libev.service - Shadowsocks-libev Default Server Service
     Loaded: loaded (/lib/systemd/system/shadowsocks-libev.service; enabled; vendor preset: enabled)
     Active: active (running) since Fri 2025-08-01 12:15:58 CST; 24s ago
       Docs: man:shadowsocks-libev(8)
   Main PID: 136038 (ss-server)
      Tasks: 1 (limit: 4534)
     Memory: 936.0K
        CPU: 10ms
     CGroup: /system.slice/shadowsocks-libev.service
             └─136038 /usr/bin/ss-server -c /etc/shadowsocks-libev/config.json

8月 01 12:15:58 ubuntu2204.wang.org systemd[1]: Started Shadowsocks-libev Default Server Service.
8月 01 12:15:58 ubuntu2204.wang.org ss-server[136038]:  2025-08-01 12:15:58 INFO: UDP relay enabled
8月 01 12:15:58 ubuntu2204.wang.org ss-server[136038]:  2025-08-01 12:15:58 INFO: initializing ciphers... chacha20-ietf-poly1305
8月 01 12:15:58 ubuntu2204.wang.org ss-server[136038]:  2025-08-01 12:15:58 INFO: tcp server listening at [::1]:8388
8月 01 12:15:58 ubuntu2204.wang.org ss-server[136038]:  2025-08-01 12:15:58 INFO: tcp server listening at 127.0.0.1:8388
8月 01 12:15:58 ubuntu2204.wang.org ss-server[136038]:  2025-08-01 12:15:58 INFO: udp server listening at [::1]:8388
8月 01 12:15:58 ubuntu2204.wang.org ss-server[136038]:  2025-08-01 12:15:58 INFO: udp server listening at 127.0.0.1:8388

# 端口查看
[root@ubuntu2204 ~]#ss -nltp
State      Recv-Q     Send-Q      Local Address:Port    Peer Address:Port        Process                                        
LISTEN      0          4096       127.0.0.53%lo:53      0.0.0.0:*                users:(("systemd-resolve",pid=27465,fd=14))     
LISTEN      0          128        0.0.0.0:22            0.0.0.0:*                users:(("sshd",pid=69737,fd=3))                 
LISTEN      0          1024       127.0.0.1:8388        0.0.0.0:*                users:(("ss-server",pid=136038,fd=6))           
LISTEN      0          128        [::]:22               [::]:*                   users:(("sshd",pid=69737,fd=4))                 
LISTEN      0          1024       [::1]:8388            [::]:*                   users:(("ss-server",pid=136038,fd=5)) 

# 编辑配置文件
[root@ubuntu2204 ~]#vim /etc/shadowsocks-libev/config.json
{
    "server":["0.0.0.0"],                 # 这里开放端口
    "mode":"tcp_and_udp",
    "server_port":8388,
    "local_port":1080,                                                                                                           
    "password":"wvD2eYOrZGJB",            # 密码password和加密方式method，在客户端配置要保证和这里一致
    "timeout":86400,
    "method":"chacha20-ietf-poly1305"     # 这里如果改成 aes-128-gcm 一定要用小写
}

# 重启服务
[root@ubuntu2204 ~]#systemctl restart shadowsocks-libev.service

# 查看端口，成功开放
[root@ubuntu2204 ~]#ss -nltp
State      Recv-Q     Send-Q      Local Address:Port    Peer Address:Port        Process                                        
LISTEN      0          4096       127.0.0.53%lo:53      0.0.0.0:*                users:(("systemd-resolve",pid=27465,fd=14))     
LISTEN      0          128        0.0.0.0:22            0.0.0.0:*                users:(("sshd",pid=69737,fd=3))                 
LISTEN      0          1024       0.0.0.0:8388        0.0.0.0:*                users:(("ss-server",pid=136038,fd=6))


# 查看cpu是否支持aes指令集
[root@ubuntu2204 ~]#lscpu|grep aes
标记：                           fpu vme de pse tsc msr pae mce cx8 apic sep mtrr pge mca cmov pat pse36 clflush mmx fxsr sse sse2 ss syscall nx pdpe1gb rdtscp lm constant_tsc arch_perfmon rep_good nopl xtopology tsc_reliable nonstop_tsc cpuid tsc_known_freq pni pclmulqdq ssse3 fma cx16 pcid sse4_1 sse4_2 x2apic movbe popcnt tsc_deadline_timer **aes** xsave avx f16c rdrand hypervisor lahf_lm abm 3dnowprefetch invpcid_single ssbd ibrs ibpb stibp ibrs_enhanced fsgsbase tsc_adjust bmi1 avx2 smep bmi2 erms invpcid rdseed adx smap clflushopt clwb sha_ni xsaveopt xsavec xgetbv1 xsaves arat umip pku ospke gfni vaes vpclmulqdq rdpid movdiri movdir64b fsrm md_clear flush_l1d arch_capabilities
```



[补充1： ChaCha20-ietf-Poly1305 和 AES-128-GCM 加密方式对比](#补充1：ChaCha20-ietf-Poly1305 和 AES-128-GCM 加密方式对比)

[补充2：什么是AEAD](#补充2：什么是AEAD)

[补充3：什么是重放攻击](#补充3：什么是重放攻击)



### 客户端连接

![image-20250801140123833](D:\git_repository\cyber_security_learning\markdown_img\image-20250801140123833.png)



填好信息后，进行测试

![image-20250801140442761](D:\git_repository\cyber_security_learning\markdown_img\image-20250801140442761.png)



这里如果timeout测试失败，可能是Ubuntu的防火墙问题，解决方案

```bash
# 解决方案1：关闭防火墙
[root@ubuntu2204 ~]# systemctl disable --now  ufw

# 解决方案2：开放端口
[root@ubuntu2204 ~]# ufw allow 8388

# 查看ufw状态
[root@ubuntu2204 ~]# ufw status
```



使用这个代理节点进行真连接测试（本质就是向 google 发送一个数据包），并在服务器观察日志信息

```bash
[root@ubuntu2204 ~]#journalctl -u shadowsocks-libev.service -f
8月 01 13:52:06 ubuntu2204.wang.org ss-server[136533]:  2025-08-01 13:52:06 INFO: initializing ciphers... AES-128-GCM
8月 01 13:52:06 ubuntu2204.wang.org ss-server[136533]:  2025-08-01 13:52:06 ERROR: invalid cipher name: AES-128-GCM
8月 01 13:52:06 ubuntu2204.wang.org ss-server[136533]:  2025-08-01 13:52:06 ERROR: failed to initialize ciphers
8月 01 13:52:06 ubuntu2204.wang.org systemd[1]: shadowsocks-libev.service: Main process exited, code=exited, status=255/EXCEPTION
8月 01 13:52:06 ubuntu2204.wang.org systemd[1]: shadowsocks-libev.service: Failed with result 'exit-code'.
8月 01 13:54:46 ubuntu2204.wang.org systemd[1]: Started Shadowsocks-libev Default Server Service.
8月 01 13:54:46 ubuntu2204.wang.org ss-server[136602]:  2025-08-01 13:54:46 INFO: UDP relay enabled
8月 01 13:54:46 ubuntu2204.wang.org ss-server[136602]:  2025-08-01 13:54:46 INFO: initializing ciphers... aes-128-gcm
8月 01 13:54:46 ubuntu2204.wang.org ss-server[136602]:  2025-08-01 13:54:46 INFO: tcp server listening at 0.0.0.0:8388
8月 01 13:54:46 ubuntu2204.wang.org ss-server[136602]:  2025-08-01 13:54:46 INFO: udp server listening at 0.0.0.0:8388
```



![image-20250801141037375](D:\git_repository\cyber_security_learning\markdown_img\image-20250801141037375.png)



**结果证明直接被墙了!!!**



此时解决方案1：更换端口再次尝试（比如将端口换为18388）

```bash
# 编辑配置文件
[root@ubuntu2204 ~]#vim /etc/shadowsocks-libev/config.json
{
    "server":["0.0.0.0"],                 # 这里开放端口
    "mode":"tcp_and_udp",
    "server_port":18388,
    "local_port":1080,                                                                                                           
    "password":"wvD2eYOrZGJB",            # 密码password和加密方式method，在客户端配置要保证和这里一致
    "timeout":86400,
    "method":"chacha20-ietf-poly1305"     # 这里如果改成 aes-128-gcm 一定要用小写
}

# 重启服务
[root@ubuntu2204 ~]#systemctl restart shadowsocks-libev.service

# 查看端口，成功开放
[root@ubuntu2204 ~]#ss -nltp
State      Recv-Q     Send-Q      Local Address:Port    Peer Address:Port        Process                                        
LISTEN      0          4096       127.0.0.53%lo:53      0.0.0.0:*                users:(("systemd-resolve",pid=27465,fd=14))     
LISTEN      0          128        0.0.0.0:22            0.0.0.0:*                users:(("sshd",pid=69737,fd=3))                 
LISTEN      0          1024       0.0.0.0:18388        0.0.0.0:*                users:(("ss-server",pid=136038,fd=6))
```



再次尝试，则会发现重放攻击

![image-20250801141319254](D:\git_repository\cyber_security_learning\markdown_img\image-20250801141319254.png)



```http
https://m.ip138.com/iplookup.php?ip=124.117.196.42
```

可以看到 `124.117.196.42` 这是一个新疆的ip

![image-20250801141446182](D:\git_repository\cyber_security_learning\markdown_img\image-20250801141446182.png)



基于上述的情况可以判断，裸奔的ss协议可以被 GFW 精准探测

```bat
实际情况是，部分主机即使使用裸奔的ss协议，仍然可以使用，因此判断，GFW 的探测范围有限，但随着GFW的探测范围的逐渐扩大，即使当前裸奔ss协议可以用，也可能后续会被探测到，从而导致翻墙失效
```



### ss 协议 的 Plugin插件功能

**功能**：对数据流量进行伪装，比如把经过ss加密后的数据流量伪造成普通的http



**plugin 实现原理**

![image-20250801142309796](D:\git_repository\cyber_security_learning\markdown_img\image-20250801142309796.png)



- 客户端将数据包发往ss代理服务器，在ss服务器使用密码和加密方式对数据进行加密处理
- 数据加密处理后，将数据包发给plugin服务，plugin的作用是在伪造数据包（比如：在数据包前面加上一段http头部，从而将数据包伪装成http数据包）
- GFW 查看http头部信息，判断给数据包是http数据包，因此就可能直接放行，而不会进行重放攻击

- 数据包经过 GFW，被发送给服务端的plugin，服务端plugin将数据包头部摘掉，并发给ss服务，在ss服务上，进行解密，从而获得我的的访问意图，从而帮我们去访问 google



#### 使用v2ray-plugin进行测试

```bash
# 使用 Ubuntu 自带的v2ray-plugin
[root@ubuntu2204 ~]#apt install shadowsocks-v2ray-plugin

# 查看这个dpkg的释放内容
[root@ubuntu2204 ~]#dpkg -L shadowsocks-v2ray-plugin 
/.
/usr
/usr/bin
/usr/bin/ss-v2ray-plugin
/usr/share
/usr/share/doc
/usr/share/doc/shadowsocks-v2ray-plugin
/usr/share/doc/shadowsocks-v2ray-plugin/changelog.Debian.gz
/usr/share/doc/shadowsocks-v2ray-plugin/copyright
/usr/share/man
/usr/share/man/man1
/usr/share/man/man1/ss-v2ray-plugin.1.gz

# 修改配置文件
[root@ubuntu2204 ~]#vim /etc/shadowsocks-libev/config.json 
{
    "server":["0.0.0.0"],
    "mode":"tcp_and_udp",
    "server_port":28388,
    "local_port":1080,
    "password":"wvD2eYOrZGJB",
    "timeout":86400,
    "method":"aes-128-gcm",
    "plugin":"ss-v2ray-plugin",
    "plugin_opts":"server"
}

# 重启服务
[root@ubuntu2204 ~]#systemctl status shadowsocks-libev.service 
● shadowsocks-libev.service - Shadowsocks-libev Default Server Service
     Loaded: loaded (/lib/systemd/system/shadowsocks-libev.service; enabled; vendor preset: enabled)
     Active: active (running) since Fri 2025-08-01 14:39:07 CST; 1s ago
       Docs: man:shadowsocks-libev(8)
   Main PID: 137180 (ss-server)
      Tasks: 8 (limit: 4534)
     Memory: 1.9M
        CPU: 12ms
     CGroup: /system.slice/shadowsocks-libev.service
             ├─137180 /usr/bin/ss-server -c /etc/shadowsocks-libev/config.json
             └─137181 ss-v2ray-plugin

8月 01 14:39:07 ubuntu2204.wang.org systemd[1]: Started Shadowsocks-libev Default Server Service.
8月 01 14:39:07 ubuntu2204.wang.org ss-server[137180]:  2025-08-01 14:39:07 INFO: plugin "ss-v2ray-plugin" enabled
8月 01 14:39:07 ubuntu2204.wang.org ss-server[137180]:  2025-08-01 14:39:07 INFO: UDP relay enabled
8月 01 14:39:07 ubuntu2204.wang.org ss-server[137180]:  2025-08-01 14:39:07 INFO: initializing ciphers... aes-128-gcm
8月 01 14:39:07 ubuntu2204.wang.org ss-server[137180]:  2025-08-01 14:39:07 INFO: tcp server listening at 127.0.0.1:34433
8月 01 14:39:07 ubuntu2204.wang.org ss-server[137180]:  2025-08-01 14:39:07 INFO: udp server listening at 0.0.0.0:8388
8月 01 14:39:07 ubuntu2204.wang.org ss-server[137181]: 2025/08/01 14:39:07 V2Ray 4.34.0 (V2Fly, a community-driven edition of V2Ray.) Custom (go1.17.3 linux/amd64)
8月 01 14:39:07 ubuntu2204.wang.org ss-server[137181]: 2025/08/01 14:39:07 A unified platform for anti-censorship.
8月 01 14:39:07 ubuntu2204.wang.org ss-server[137181]: 2025/08/01 14:39:07 [Warning] v2ray.com/core: V2Ray 4.34.0 started
```



服务端加了插件后，在客户端也要安装插件，这里需要使用支持插件的客户端

```bash
# 下载，在windows系统下安装
shadowsocks-windows: https://github.com/shadowsocks/shadowsocks-windows

# 下载v2ray-plugin，并将其放入shadowsockets同目录下，并在shadowsockets软件下写入插件名
https://github.com/shadowsocks/v2ray-plugin
```

![image-20250801144707382](D:\git_repository\cyber_security_learning\markdown_img\image-20250801144707382.png)



- 插件程序是v2ray-plugin，因为v2ray-plugin下载完并解压后，将其放入shadowsockets同目录下，并改名为v2ray-plugin.exe
- 插件选项：“server”，和服务端配置相同



然后在V2ray上连接

```bash
IP: 127.0.0.1
port: 1080
```



此时即可成功！！







## trojan协议服务部署



ss协议，即使使用plugin做http伪装，但是由于http是明文报文，所以还是有被GFW探测的可能，因此建议引入TLS，这里使用 trojan 协议



### trojan协议介绍

**Trojan 是一种“天生伪装成 HTTPS” 的代理协议**，它的设计目标就是让流量在外部观察者（如 GFW）看来和**标准 HTTPS 流量完全一致**



#### **Trojan 的关键特性**

1. **使用标准 TLS（HTTPS）**
   - Trojan 直接复用了标准的 TLS 1.2/1.3 协议进行加密和握手，而不是自定义的加密算法。
   - 外部抓包看起来就是一个**普通的 TLS 连接**，无法区分与真实 HTTPS 网站的差别。
2. **服务器可以同时运行真实 HTTPS 网站**
   - Trojan 服务器常配置为：
     - **80/443 端口 → Nginx/Apache 提供正常 HTTPS 网站**
     - Trojan 流量通过同一个 TLS 证书与域名进行通信
   - 因此即使 GFW 主动探测 IP，也只能得到合法网站的 TLS 响应。
3. **强认证机制**
   - 客户端与服务器通过预共享密码/密钥认证，GFW 的主动探测包无法得到有效响应。
   - 任何没有正确认证的 TLS 连接都会被视为普通 HTTPS 流量处理。



#### **为什么说是“天生伪装”？**

- **相比 Shadowsocks / V2Ray**：
  - Shadowsocks 需要额外混淆插件（obfs）来模拟 HTTPS。
  - V2Ray 需要手动配置 TLS（VMess + TLS）才能看起来像 HTTPS。
  - **Trojan 则直接使用 TLS 作为其本身的通信协议**，因此“天生”就是 HTTPS 流量。



#### **抗检测性**

- **DPI 难以区分**：所有握手与流量都符合 TLS 规范，GFW 只能看到标准加密流量。
- **主动探测无效**：GFW 发出的伪造请求不会触发 Trojan 服务响应，服务器返回正常网站页面。
- **流量指纹随机性高**：与普通浏览器的 TLS 流量非常接近。





![image-20250801152636603](D:\git_repository\cyber_security_learning\markdown_img\image-20250801152636603.png)





因为trojan是完全模仿https，因此我们要搭建trojan的话，也必须要先给trojan这台服务器申请一个证书，来开启https的访问

- 这里假设给trojan服务器申请一个域名`t.buliang0.tk` ，同时生成一个私钥321，并使用这个私钥生成一个123的公钥

- 这是我们就可以使用这个123的公钥，向CA机构申请一个证书。正常CA机构会验证这个域名是否属于你，如果验证通过，则会给你颁发一个网站证书

- 我们将这个证书放在服务器上，有了这个证书和私钥之后，我们就可以启动这个trojan服务。

- trojan启动之后的一些配置文件内容

  > IP地址：0.0.0.0
  >
  > 端口：443
  >
  > 密码：111     # 这里trojan的密码并不对数据进行加密，而是用来进行身份认证的。类似于qq的账号密码，如果客户端的密码不正确，就会跳转到一个指                          >                         定的IP:Port，这里我们如下指定为192.83.167.78:80
  >
  > 失败跳转：192.83.167.78:80

- 客户端信息解读

  > IP地址：6.6.6.6
  >
  > 端口：443                        # 要访问代理服务器的IP和端口
  >
  > 密码：111                        # 必须和服务端用作身份认证的密码匹配
  >
  > sni：t.buliang0.tk          # 必须是证书上的域名
  >
  > 跳过证书验证：false       





### Trojan 通信过程

#### 🔹 **1. 客户端向 Trojan 客户端发送原始请求**

- 用户浏览器（或系统代理）发送请求（例如访问 Google）到 **Trojan 客户端（本地代理）**。
- Trojan 客户端会将这个请求打包为 Trojan 协议格式，并准备通过 TLS 发送给服务器。



#### 🔹 **2. Trojan 客户端与 Trojan 服务端建立 TLS 连接**

- Trojan **直接使用标准 TLS 1.2/1.3 握手**（与 HTTPS 一样）。
- **公钥交换**（ECDHE）和 **证书验证** 是标准 TLS 流程，由服务器提供合法证书（如 Let's Encrypt）。
- **这里不会把 Trojan 协议数据用“服务器公钥”单独加密**，而是通过 TLS 会话密钥进行对称加密通信（这和普通 HTTPS 一样）。



#### 🔹 **3. 发送 Trojan 协议头（包含认证信息）**

- TLS 握手成功后，Trojan 客户端在 **TLS 加密信道** 内发送 **Trojan 协议头**：
  - **认证密码（Password）**：用于服务器识别合法客户端。
  - **目标地址信息**：告诉服务器需要代理访问的真实目标（如 `google.com:443`）。
- 由于这些信息在 TLS 内部，**GFW 无法看到，也无法伪造有效认证信息**。



#### 🔹 **4. Trojan 服务端验证并转发流量**

- 服务器在 TLS 连接内验证密码。
- 如果密码正确 → 解码 Trojan 协议头 → 解析目标地址（Google）→ **作为代理转发请求**。
- 如果密码错误 → 服务器直接返回一个正常 HTTPS 网站的页面（伪装），迷惑探测方。



#### 🔹 **5. Google 响应 → Trojan 服务端 → TLS 通道 → Trojan 客户端 → 用户浏览器**

- Google 的响应返回给 Trojan 服务端。
- 服务端通过 TLS 通道发送给 Trojan 客户端。
- 客户端再将解密后的响应转交给浏览器。
- **在整个过程中，GFW 看到的始终是一个合法的 TLS 加密连接**（与访问任何 HTTPS 网站无异）。





### trojan搭建部署

```http
https://p4gefau1t.github.io/trojan-go/
```



```bash
root@vultr:~/trojan# mkdir trojan
root@vultr:~/trojan# cd trojan
root@vultr:~/trojan# wget https://github.com/p4gefau1t/trojan-go/releases/download/v0.10.6/trojan-go-linux-amd64.zip
root@vultr:~/trojan# unzip trojan-go-linux-amd64.zip

# 查看
root@vultr:~/trojan# ls
example  geoip.dat  geoip-only-cn-private.dat  geosite.dat  trojan-go  trojan-go-linux-amd64.zip

# 修改配置文件
root@vultr:~/trojan# vim config.json
{
    "run_type": "server",
    "local_addr": "0.0.0.0",
    "local_port": 443,
    "remote_addr": "101.35.250.82",
    "remote_port": 80,
    "password": [
        "111"
    ],
    "ssl": {
        "cert": "/root/proxy.mysticalrecluse.com_nginx/proxy.mysticalrecluse.com_bundle.crt",
        "key": "/root/proxy.mysticalrecluse.com_nginx/proxy.mysticalrecluse.com.key"
    }
}

# 启动
root@vultr:~/trojan# ./trojan/trojan-go -config trojan/config.json

# 查看端口，443端口开发，说明服务成功
root@vultr:~# ss -nlt
State            Recv-Q           Send-Q                     Local Address:Port                     Peer Address:Port          Process          
LISTEN           0                128                              0.0.0.0:22                            0.0.0.0:*               
LISTEN           0                4096                       127.0.0.53%lo:53                            0.0.0.0:*               
LISTEN           0                128                                 [::]:22                               [::]:*               
LISTEN           0                4096                                   *:443                                 *:*   
```



### 配置客户端

![image-20250801164940213](D:\git_repository\cyber_security_learning\markdown_img\image-20250801164940213.png)





### 访问 youtube 高清视频测试

![image-20250801165150063](D:\git_repository\cyber_security_learning\markdown_img\image-20250801165150063.png)

```bat
实测最高可到100000 kbps，高速足够，日本服务器，成本49/month
```





## Vmess 协议服务部署







## Vless 协议服务介绍









# 补充知识点

## 补充1：ChaCha20-ietf-Poly1305 和 AES-128-GCM 加密方式对比

**翻墙场景下哪个更好？**

| 指标              | ChaCha20-Poly1305               | AES-128-GCM                   |
| ----------------- | ------------------------------- | ----------------------------- |
| **安全性**        | 高                              | 高                            |
| **低端设备性能**  | **优秀（强烈推荐）**            | 较差                          |
| **现代 CPU 性能** | 略低于 AES（有 AES-NI 时）      | **优秀（有硬件加速）**        |
| **抗检测性**      | **较好（流量模式更均匀）**      | 好，但某些 TLS 指纹可能被检测 |
| **协议支持**      | Shadowsocks/V2Ray/Trojan 全支持 | 同样支持                      |



🔥 **结论**

- **如果你运行代理在路由器、安卓设备、树莓派等无 AES-NI 硬件上** → **ChaCha20-ietf-Poly1305** 更合适。
- **如果你使用的是现代 Intel/AMD 服务器（有 AES-NI）** → **AES-128-GCM** 在性能上略优，但抗检测性与 ChaCha20 接近。
- **从抗检测角度**：ChaCha20 因流量特征较随机，**在 GFW 流量行为分析下表现更好**，因此许多翻墙工具默认推荐 ChaCha20-Poly1305。



在 GFW 面前，仅仅换算法并不能完全隐藏代理流量，还需要 **混淆（Obfs）**、**TLS 伪装**（如 Trojan/V2Ray + TLS/XTLS）等组合使用。





## 补充2：什么是AEAD

**AEAD (Authenticated Encryption with Associated Data)** 是一种现代加密模式，全称为 **带关联数据的认证加密**。它不仅能**保证数据的机密性（Confidentiality）**，还能**同时验证数据的完整性和真实性（Integrity & Authenticity）**。



### **传统加密 vs AEAD**

- 传统的对称加密（如 AES-CBC）**只负责加密**，无法检测数据是否被篡改，因此还需要额外的消息认证码（MAC）。
- AEAD 把 **加密（Encryption）** 和 **认证（Authentication）** **整合在一起**，生成一个既加密又能验证的密文。





### **AEAD 的关键特点**

1. **一次操作同时完成加密和完整性校验**
   - 不需要额外 HMAC，效率高。
2. **防止篡改攻击**
   - 解密时会检查认证标签（Tag），一旦数据被篡改就会解密失败。
3. **支持关联数据（Associated Data）**
   - AEAD 允许对某些数据（如协议头）进行认证，但不加密。
   - 例如 TLS 中，握手头部可以作为 AAD 进行认证而保持明文。





### 常见 AEAD 算法

| 算法                  | 说明                                                         |
| --------------------- | ------------------------------------------------------------ |
| **AES-GCM**           | 基于 AES 的 AEAD 模式，GCM (Galois/Counter Mode) 提供加密+认证 |
| **ChaCha20-Poly1305** | 基于 ChaCha20 流密码 + Poly1305 MAC，性能优异，TLS 1.3 广泛使用 |
| **AES-CCM**           | 另一种 AEAD 模式，常用于 IoT（如 WPA3）                      |



### AEAD 在翻墙协议中的作用

- **Shadowsocks AEAD**（如 `AES-128-GCM`、`ChaCha20-ietf-Poly1305`）：不仅加密流量，还防止中间人篡改包内容。
- **Trojan / V2Ray XTLS**：也使用 AEAD 加密，保证数据安全并增加抗检测性。
- **TLS 1.3**：内部采用 AEAD（AES-GCM 或 ChaCha20-Poly1305）作为核心加密算法。



**总结**：AEAD 是 **现代加密协议（TLS 1.3、QUIC、Shadowsocks、WireGuard）** 的标准选择，因为它 **高效、安全，并能抵御篡改攻击**。





## 补充3：什么是重放攻击

**GFW 通过“主动重放攻击（Replay Attack）”来探测代理协议**，这种攻击机制在 GFW 针对 Shadowsocks 之类的加密代理时非常常见。

假设客户端生成一个数据包，向服务端发送，并经过防火墙，防火墙将该数据包也向服务端发送。

![image-20250801134258741](D:\git_repository\cyber_security_learning\markdown_img\image-20250801134258741.png)



通过这种方式，GFW可以探测到，你使用的是什么协议进行数据发送



**GFW 重放攻击的核心原理是：** 通过复制客户端的合法数据包并观察服务器的响应行为，来确认该端口是否运行代理协议。原版 Shadowsocks AEAD 没有全局防重放机制，因此容易被探测。



#### **重放攻击（Replay Attack）原理**

1. **拦截流量**
    GFW 监控到客户端与 ss-server（6.6.6.6:8388）之间的加密通信流量。
2. **复制数据包**
    GFW 复制并伪造客户端的加密数据包（保持原 IP/端口信息），再向 ss-server 发送相同或修改过的数据包。
3. **观察 ss-server 响应**
   - 如果服务器返回正常响应（解密成功且响应合理），说明目标端口运行着可以解密此流量的 Shadowsocks 服务。
   - 如果服务器直接丢弃或返回无效响应，则可能不是代理服务。



#### **为什么 GFW 能通过重放探测协议？**

🔹 **原因 1：Shadowsocks（原版 AEAD）缺乏重放保护**

- AEAD（如 AES-128-GCM）虽然能验证数据完整性，但**原始 Shadowsocks AEAD**只对单个数据包做完整性校验，没有全局重放计数机制。
- 这意味着 **同一个合法加密数据包**如果被重复发送，服务器仍会尝试解密，并返回合法响应。



🔹 **原因 2：GFW 通过服务器行为判断协议**

- GFW 并不需要知道密码，只要它**看到服务器对重放数据包的响应行为**，就能判断目标端口运行的是什么服务。
- **例如**：
  - **普通 HTTPS 服务器**收到无效数据包 → 直接断开连接或返回 TLS 握手失败。
  - **Shadowsocks 服务器**收到重放数据包 → 仍然成功解密并回应代理数据流，暴露其服务存在。



#### 进一步的探测技术

除了简单的重放，GFW 还会：

- **主动伪造客户端**，模拟 Shadowsocks 握手包（随机猜测密码无效，但可以测试响应特征）。
- **发送畸形包**，看服务器如何处理（Shadowsocks 与普通 TCP 服务行为不同）。
- **流量特征分析**，基于加密流量大小、时间间隔等统计特征进行识别。



#### **为什么 Trojan / V2Ray 更难被探测？**

- Trojan 使用标准 TLS，GFW 重放任意数据包不会得到有用响应（TLS 有随机性和握手认证）。
- V2Ray（VLESS+XTLS）通过混淆、随机化以及**完整握手验证**抵抗了重放攻击。