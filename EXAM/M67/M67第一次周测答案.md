1. 提示空间满NO space left on device，但df可以看到空间很多，为什么

```ABAP
节点编号不足，一个文件能被创建需要同时满足两个前提:足够的空间，以及该文件系统下还有剩余的节点编号
```



2. 为什么cp /dev/zero /boot/test.img会把/boot的空间撑满

```bat
- /dev/zero 是一个特殊的设备文件，它可以生成无限的零字节。当你尝试从它读取数据时，它会持续不断地返回零字节。

- cp 命令的作用是复制文件或目录。在这种情况下，它从 /dev/zero 复制数据并尝试写入 /boot/test.img。

- 因为 /dev/zero 提供了无限的零字节，cp 会持续写入数据到 /boot/test.img，直到 /boot 分区没有更多的空间可用。
```



3. 当test.img被访问时，管理员在主服务器删除test.img后，为什么空间依然是满的，如何解决？

```bat
这个问题的根本原因是文件被删除后，进程仍然持有文件的打开句柄。在 Linux 系统中，当一个文件被删除时，只要还有进程打开了这个文件的句柄，文件的数据仍然会被保留在磁盘上，直到所有进程关闭文件句柄为止。
因为当一个文件被使用时，在另一侧删除该文件，该空间并不会被立即释放，只有当这个文件不被使用时，才会释放这个空间
删除前解决方法1. ：

cat /def/null > /boot/test.img; rm -rf /boot/test.img     # 把文件清空后删除即可
echo -n '' > /boot/test.img                               # 结果和上述cat /def/null...相同

删除后解决方法2：
示例：
# 终端1：
# 查看当前空间使用率为15%
[root@mystical ~]# df
文件系统                             1K的块     已用     可用 已用% 挂载点
tmpfs                                396088     1236   394852    1% /run
/dev/mapper/ubuntu--vg-ubuntu--lv 101590008 14676472 81706908   16% /
......

# 创建一个1G的文件
[root@mystical ~]# dd if=/dev/zero of=test.img count=10 bs=100M
输入了 10+0 块记录
输出了 10+0 块记录
1048576000 字节 (1.0 GB, 1000 MiB) 已复制，5.75661 s，182 MB/s

# 查看空间使用率为16%
[root@mystical ~]# df
文件系统                             1K的块     已用     可用 已用% 挂载点
tmpfs                                396088     1236   394852    1% /run
/dev/mapper/ubuntu--vg-ubuntu--lv 101590008 14676472 81706908   16% /
.....

[root@mystical ~]# tail -f test.img
# 挂起

# 终端2
# 删除文件
[root@mystical ~]# rm -rf test.img 

# 查看空间使用率仍为16%
[root@mystical ~]# df
文件系统                             1K的块     已用     可用 已用% 挂载点
tmpfs                                396088     1236   394852    1% /run
/dev/mapper/ubuntu--vg-ubuntu--lv 101590008 14676472 81706908   16% /

# 使用lsof查看打开文件是被删除状态的进程
[root@mystical ~]# lsof |grep deleted
tail      1502                            root    3r      REG              252,1 1048576000     786439 /root/test.img (deleted)

# 杀死这个进程
[root@mystical ~]# kill -9 1502

# 查看空间使用率降为15%
[root@mystical ~]# df
文件系统                             1K的块     已用     可用 已用% 挂载点
tmpfs                                396088     1236   394852    1% /run
/dev/mapper/ubuntu--vg-ubuntu--lv 101590008 13652468 82730912   15% /
tmpfs                               1980428        0  1980428    0% /dev/shm
tmpfs                                  5120        0     5120    0% /run/lock
```



4. 系统中某些配置文件在不同目录下需要被不同程序读取，你需要通过链接来实现文件共享：

- 创建 /etc/myapp/ 目录，并在其中创建一个名为 config 的文件。 
- 在 /usr/local/myapp/ 目录下创建一个指向 /etc/myapp/config 的软链接。
- 在 /opt/myapp/ 目录下创建一个指向 /etc/myapp/config 的硬链接。 
- 使用命令检查软链接和硬链接是否生效，并解释两者的区别。 注意：上述过程中，缺失目录，要求自行创建

```bat
[root@mystical ~]# mkdir /etc/myapp
[root@mystical ~]# touch /etc/myapp/config
[root@mystical ~]# mkdir /usr/local/myapp
[root@mystical ~]# ln -s /etc/myapp/config /usr/local/myapp/config
[root@mystical ~]# ll /usr/local/myapp/config 
lrwxrwxrwx 1 root root 17 Jan 13 02:57 /usr/local/myapp/config -> /etc/myapp/config
[root@mystical ~]# mkdir /opt/myapp
[root@mystical ~]# ln /etc/myapp/config /opt/myapp/config
[root@mystical ~]# ll /opt/myapp/config 
-rw-r--r-- 2 root root 0 Jan 13 02:57 /opt/myapp/config

# 硬链接与软链接的区别
硬链接：
- 概述：本质上是多个文件名共用一个inode
- 命令：`ln a.txt aa.txt`
- 注意：
  - 因为本质是共用一个inode，所以不能跨分区创建硬链接，因为不同分区有独立的inode表
  - 同理，为了防止inode循环利用，所以目录也不能创建硬链接，但是在创建目录及其子目录的时候，系统会自动创建.和..这种目录的硬链接
  - 硬链接数本质上是inode计数器的值

软链接：
- 概述：也叫符号链接，软链接的本质是创建了一个新文件，该文件的内容是源文件的路径，所以访问软连接文件，实质上系统访问指向了源文件
- 命令：`ln -s 目标文件 软链接文件`
  - 注意：根据软链接的本质，软连接文件中的内容实际上是指向目标文件的路径，因此目标文件的路径如果是相对路径，那么一定是相对软链接的路径 
  - 注意2：删除软链接的时候，不要加tab键补全，如果软连接文件后跟/,删除的时候，比如rm -rf /Storage/test/test/ 实际上是把原始目录中的内容一起删除
```



5. 写一个别名，将所有要删除的文件，移动到创建的垃圾箱目录中，垃圾箱中，每天的垃圾文件都会放入"data-当前日期"的目录中

```bat
[root@mystical ~]# alias rm='dir=/Storage/backup/data-`date +%F`;mkdir -p $dir;mv -t $dir'
```



6. 某个生产目录中存在大量的日志文件，你需要清理和归档部分过期文件：

- 创建一个目录 /tmp/archive/ 用于存放归档的日志文件。
- 将 /var/log/ 目录下所有 .log 结尾的文件复制到 archive/ 中。
- 将所有 .log 文件改名为 .log.bak。
- 删除原目录下的所有 .log 文件。

```bat
[root@mystical ~]# mkdir /tmp/archive
[root@mystical ~]# cp /var/log/*.log /tmp/archive/
[root@mystical ~]# apt install -y rename

# Ubuntu
[root@mystical ~]# rename 's/log/log.bak/' /tmp/archive/*
# Rocky
[root@mystical ~]# rename log log.bak /tmp/archive/*
# 通用
[root@mystical ~]# ls /tmp/archive/|xargs -I {} mv /tmp/archive/{} /tmp/archive/{}.bak
[root@mystical ~]# ls /tmp/archive/
alternatives.log.bak  auth.log.bak       cloud-init-output.log.bak  dpkg.log.bak        kern.log.bak
apport.log.bak        bootstrap.log.bak  cloud-init.log.bak         fontconfig.log.bak

[root@mystical ~]# rm -rf /var/log/*.log
```



7. /etc/app目录下，所有的后缀为.conf的配置文件中的DEBUG=true，替换为DEBUG=false

```bat
sed -i 's/DEBUG=true/DEBUG=false/g' /etc/app/*.conf
```



8. 统计access.log中每个不同的IP出现的次数,并按照从大到小排序

```bat
awk '{print $1}' access.log | sort | uniq -c | sort -nr
```



9. 统计access.log中，哪些IP，在什么时间，发生了4XX ，输出格式如下

```bat
[root@mystical ~]# cat access2.log |grep -Po '.*4\d{2} '|awk '{print $1,$4,$5,$NF}'|head
103.149.26.253 [15/Mar/2024:02:11:20 +0800] 403
103.149.26.240 [15/Mar/2024:02:15:26 +0800] 403
103.149.26.240 [15/Mar/2024:02:15:26 +0800] 404
47.236.251.7 [15/Mar/2024:02:45:16 +0800] 400
47.236.251.7 [15/Mar/2024:02:45:23 +0800] 400
47.236.251.7 [15/Mar/2024:02:45:25 +0800] 403
......

[root@mystical ~]# cat access2.log |grep -Po '.*4\d{2} '|awk '{print $1,$4,$5,$NF}'|wc -l
8153
```



10. 使用正则表达式精准匹配IP地址，并使用该正则表达式从下面IP中筛选出正确的IP

```css
112.2.0.11
282.112.3.6
12.01.02.333
10.0.0.888
10.1.0.2
4.4.4.4
172.22.5
```

```bat
[root@mystical ~]# cat ip.txt |grep -E '^((25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9]?[0-9])\.){3}(25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9]?[0-9])$'
112.2.0.11
10.1.0.2
4.4.4.4
```



11. 分析执行  cp /etc/issue /data/dir/ 所需要的最小权限？

```bat
/etc/issue（源文件）需要 rx 权限
/etc 目录需要 x 权限

/data 目录需要 x 权限
/data/dir 目录需要 wx 权限
```



12. 简单题：Linux中的目录和文件的权限区别？分别说明读，写和执行权限的区别

```bat
rwx对于文件的权限意义
- r：读取文件内容
- w：允许修改文件内容（write），包括覆盖、追加、截断
- x：允许内核将该文件作为程序加载执行
	- ELF：直接加载
	- 脚本：交给解释器（shebang）额外需要读权限

rwx对于目录的权限意义（与文件不同）

- r：可以使用ls查看此目录中文件名+inode列表，但无法看到文件的属性meta信息，因为无法访问 inode 指向的文件对象
- w：可以在此目录中创建文件，也可以删除此目录中的文件，而和此被删除的文件的权限无关。
- x：如果，没有该目录的执行权限，用户将无法访问这个目录下的所有文件，所以执行权限是目录访问的基本权限，没有执行就无法进入，是的，连目录进都进不去！
  - 如果只有x,没有r的话，对于目录来说，就是只能访问，但是看不到ls，就是没有访问目录下文件名的权限，但是如果这个文件你知道名称，且这个文件的通用权限有读权限，那么对于普通用户来说，只是无法浏览目录下文件名及文件元信息，但是依然可以cat到文件内的内容
```



13. 简述/etc/fstab里面各字段的含义

```bat
<fs_spec>   <fs_file>   <fs_vfstype>   <fs_mntops>   <fs_freq>   <fs_passno>

1. fs_spec (挂载谁)

常见写法：
/dev/sda1
UUID=xxxx-xxxx，通过blkid查询
LABEL=data

生产推荐：UID > LABEL > 设备名

2. fs_file 挂载点（mount point）

注意事项：
- 必须是 已存在的目录
- 挂载后：
	- 原目录内容被“遮住”
	- 卸载后恢复可见
	
3. fs_vfstype （文件系统类型）

生产建议：
本地磁盘：ext4 / xfs
内存盘：tmpfs
网络：nfs
systemd 时代：auto （表示让内核 / blkid 自动识别（谨慎使用）

4.fs_mntops 挂载选项（事故高发区）

常见基础选项：
- defaults （等价于rw,suid,dev,exec,auto,nouser,async）

产中最常用、最有价值的选项
- noatime / relatime
	- 不更新访问时间
	- 显著减少 IO
	- 数据盘 / 日志盘强烈推荐
- nofail（非常重要）
	- 可选数据盘
	- 移动盘
	- 云环境附加盘
	- 否则可能 直接卡在 emergency mode
- _netdev（网络文件系统必加）
	- 告诉 systemd：这是网络设备，等网络起来再挂	
	- NFS / iSCSI / Ceph 必须加
	
5. fs_freq 【dump 备份标志（几乎废弃）】
- 略

6. fs_passno 【fsck 检查顺序】
- 系统启动时，是否、以及以什么顺序执行 fsck
	- 0：不检查
	- 1：最先检查（通常只有 /）
	- 2：后续并行检查
	
生产标准规则（牢记）
- /    → 1
- 其他 ext4/xfs → 2
```





14.  如果买了个比较新的硬盘，容量大于2T，linux需要什么命令对磁盘分区

```bat
gdisk

考点在于：MBR分区不支持大于2T,必须选择GPT分区
```





15. 怎么在不影响应用运行的情况下，将数据迁移到新盘（使用我们学过的知识） 提示（逻辑卷）

```bat
模拟生产中应用运行过程中的数据迁移过程

1. 在虚拟机添加两块磁盘

2. 扫描磁盘，让其被操作系统识别
[root@mystical ~]# for i in {0..32};do echo "- - -" > /sys/class/scsi_host/host${i}/scan ;done
[root@mystical ~]# lsblk
NAME                      MAJ:MIN RM  SIZE RO TYPE MOUNTPOINTS
sda                         8:0    0  200G  0 disk 
├─sda1                      8:1    0    1M  0 part 
├─sda2                      8:2    0    2G  0 part /boot
└─sda3                      8:3    0  198G  0 part 
  └─ubuntu--vg-ubuntu--lv 252:0    0   99G  0 lvm  /
sdb                         8:16   0   20G  0 disk 
sdc                         8:32   0   20G  0 disk 
sr0                        11:0    1  2.6G  0 rom

3. 将sdb配置为逻辑卷，并创建文件系统挂载在/目录下
# 创建物理卷
[root@mystical ~]# pvcreate /dev/sdb 
  Physical volume "/dev/sdb" successfully created.
  
# 创建卷组
[root@mystical ~]# vgcreate mytest /dev/sdb
  Volume group "mytest" successfully created
  
# 创建逻辑卷
[root@mystical ~]# lvcreate -l 100%free -n mylvs mytest
  Logical volume "mylvs" created.
  
# 查看创建的逻辑卷
[root@mystical ~]# lvs
  LV        VG        Attr       LSize   Pool Origin Data%  Meta%  Move Log Cpy%Sync Convert
  mylvs     mytest    -wi-a----- <20.00g                                                    
  ubuntu-lv ubuntu-vg -wi-ao---- <99.00g
  
# 创建文件系统
[root@mystical ~]# mkfs.ext4 /dev/mytest/mylvs 
mke2fs 1.47.0 (5-Feb-2023)
Creating filesystem with 5241856 4k blocks and 1310720 inodes
Filesystem UUID: e2168968-33d3-40c1-808d-cdbbe82575da
Superblock backups stored on blocks: 
        32768, 98304, 163840, 229376, 294912, 819200, 884736, 1605632, 2654208, 
        4096000

Allocating group tables: done                            
Writing inode tables: done                            
Creating journal (32768 blocks): done
Writing superblocks and filesystem accounting information: done  

# 在根目录下创建一个目录，并挂载
[root@mystical ~]# mkdir /data
[root@mystical ~]# mount /dev/mytest/mylvs /data

# 查看
[root@mystical ~]# df
Filesystem                        1K-blocks     Used Available Use% Mounted on
tmpfs                                396088     1224    394864   1% /run
/dev/mapper/ubuntu--vg-ubuntu--lv 101590008 14580328  81803052  16% /
tmpfs                               1980436        0   1980436   0% /dev/shm
tmpfs                                  5120        0      5120   0% /run/lock
/dev/sda2                           1992552   103752   1767560   6% /boot
tmpfs                                396084       16    396068   1% /run/user/0
/dev/mapper/mytest-mylvs           20462160       24  19397384   1% /data

# 在/data目录下复制一个文件，并使用tail持续占用该文件
[root@mystical ~]# cp /etc/passwd /data/
[root@mystical ~]# tail -f /data/passwd 
systemd-resolve:x:992:992:systemd Resolver:/:/usr/sbin/nologin
pollinate:x:102:1::/var/cache/pollinate:/bin/false
polkitd:x:991:991:User for polkitd:/:/usr/sbin/nologin
usbmux:x:103:46:usbmux daemon,,,:/var/lib/usbmux:/usr/sbin/nologin
sshd:x:104:65534::/run/sshd:/usr/sbin/nologin
mystical:x:1000:1000:mystical:/home/mystical:/bin/bash
vimuser:x:1001:1001::/home/vimuser:/bin/bash
syslog:x:105:104::/nonexistent:/usr/sbin/nologin
uuidd:x:106:105::/run/uuidd:/usr/sbin/nologin
tcpdump:x:107:107::/nonexistent:/usr/sbin/nologin
# 挂起...

# 将 sdc 创建为物理卷并加入卷组
[root@mystical ~]# pvcreate /dev/sdc 
  Physical volume "/dev/sdc" successfully created.
[root@mystical ~]# vgextend mytest /dev/sdc
  Volume group "mytest" successfully extended
  
# 使用 pvmove 将数据迁移至sdc
[root@mystical ~]# pvmove /dev/sdb /dev/sdc
  /dev/sdb: Moved: 0.70%
  /dev/sdb: Moved: 100.00%
  
# df查看
[root@mystical ~]# lsblk
NAME                      MAJ:MIN RM  SIZE RO TYPE MOUNTPOINTS
sda                         8:0    0  200G  0 disk 
├─sda1                      8:1    0    1M  0 part 
├─sda2                      8:2    0    2G  0 part /boot
└─sda3                      8:3    0  198G  0 part 
  └─ubuntu--vg-ubuntu--lv 252:0    0   99G  0 lvm  /
sdb                         8:16   0   20G  0 disk 
sdc                         8:32   0   20G  0 disk 
└─mytest-mylvs            252:1    0   20G  0 lvm  /data     # 从sdb转移到sdc
sr0                        11:0    1  2.6G  0 rom 

#从逻辑卷移除之前的盘
[root@mystical ~]# vgreduce mytest /dev/sdb
  Removed "/dev/sdb" from volume group "mytest"
```

