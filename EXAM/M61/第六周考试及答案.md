1. 叙述Https的工作过程

``````bash
1. 第一步：客户端发起请求
2. 第二步：服务端将证书传给客户端
3. 第三步：客户端使用CA公钥解析验证证书,没问题的话生成一个随机值,使用服务器公钥加密随机值发给服务端
4. 第四步：服务端收到公钥加密的随机值,使用自己的私钥解密,后续客户端和服务端使用这个随机值进行对称加密，机密传输。
``````



2. 实验题：创建自签CA，并为用户tom颁发证书

``````bash
# 创建自签CA

# tom递交申请

# CA为tom颁发证书
``````



3. SCP和Rsync的区别是什么

``````
``````



4. 简述NFS实现原理

``````
``````



5. 写出Web浏览器发起HTTP请求访问网站的过程

``````
- 首先服务器监听打开了443或者80端口
- 浏览器从url中解析出域名
- 根据域名查询DNS，获取域名对应得IP地址
- 浏览器根据ip地址，和服务器三次握手建立TCP链接，https会额外完成TLS/SSL的握手
- 构造HTTP请求，在构造请求的过程中，填充相应的HTTP头部，包括上下文所需要的信息，至头部中
- 通过链接发起HTTP请求
- 服务器接收到HTTP请求后，完成资源的表述，把客户端请求的文件如html页面作为包体返回给浏览器
- 浏览器在渲染引擎中解析响应，根据这个响应中一些其他的超链接资源去构造其他HTTP请求
``````



6. Sessin是什么？Cookie是什么？Session和Cookie有什么关系？

``````
session的定义：
1. Session 是服务器端维护用户状态的一种机制。
2. 每个用户访问服务器时，服务器会为用户创建一个唯一的 Session ID（通常是随机生成的 UUID），用于标识用户会话。

3.Session 是一个数据集合，通常存储在服务器的内存中或某种存储介质（如 Redis 或数据库）中，用于保存用户的临时会话数据，例如：

- 用户登录状态
- 用户偏好设置
- 购物车信息

cookie的定义
1.  Cookie 是存储在客户端（浏览器）上的一小段数据。
2. 在基于 Session 的会话中，Cookie 通常用来存储 Session ID，并在后续请求中将这个 ID 发送回服务器，以便服务器识别用户会话。

cookie和session的关系
- Cookie 是 Session 的载体
	- Cookie 中通常包含一个字段（如 sessionid），用来携带 Session ID。
	- 服务器根据这个 Session ID 检索到与之对应的 Session 数据
``````



7. 实验题：某企业有一台服务器 `ServerA`，该服务器上有一个本地目录 `/mnt/nfsdata`，此目录通过 NFS 挂载了远程服务器 `ServerNFS` 上的目录 `/data/shared`。企业需要对 `ServerA` 上的 `/mnt/nfsdata` 中的数据进行实时备份。为此，企业计划在另一台服务器 `ServerB` 上部署 `sersync2`，以监控和同步 `ServerA` 上的 `/mnt/nfsdata` 数据至 `ServerB` 的 `/backup/data` 目录。

``````
``````



8. 某企业希望在其 IT 基础设施中实现集中式日志管理，以便及时发现和排查问题。公司有两台服务器：

   - **ServerA**：应用服务器，负责运行业务应用，生成日志。
   - **ServerB**：日志服务器，用于接收和存储来自多台应用服务器的日志。

   企业要求通过 **rsyslog** 实现以下功能：

   1. **ServerA** 将其应用日志 `/var/log/app.log` 和系统日志（如 `auth.log`）实时转发到 **ServerB**。

   2. ServerB

       需要对接收到的日志进行分类存储：

      - 系统日志保存到 `/var/log/remote/system_logs.log`。
      - 应用日志保存到 `/var/log/remote/app_logs.log`。

   3. 配置日志压缩与自动清理机制，确保日志存储空间不被耗尽：

      - 每天转储一次
      - 做多保存7个压缩日志

提示：可以使用下面的命令在ServerA上进行验证

``````
logger -t app "This is a test message for app"
logger -t auth "This is a test message for auth"
``````



``````bash
# 服务器准备
ServerA: 10.0.0.211(Rocky)
ServerB: 10.0.0.231(Ubuntu)

# ServerA:
vim /etc/rsyslog.conf

*.* @@10.0.0.231:514

systemctl restart rsyslog

# ServerB:
mkdir -p /var/log/remote
chown syslog:syslog /var/log/remote
chmod 755 /var/log/remote

vim /etc/resyslog.d/remote.conf

:programname, isequal, "app"  /var/log/remote/app_logs.log
:programname, isequal, "auth" /var/log/remote/system_logs.log

vim /etc/rsyslog.conf

# provides UDP syslog reception
module(load="imudp")
input(type="imudp" port="514")

# provides TCP syslog reception
module(load="imtcp")
input(type="imtcp" port="514")

vim /etc/logrotate.d/remote_logs

/var/log/remote/*.log {
    daily
    rotate 7
    compress
    delaycompress
    missingok
    notifempty
    create 0640 root root
    postrotate
        /usr/bin/systemctl restart rsyslog > /dev/null
    endscript
}

systemctl restart rsyslog
systemctl restart logrotate


# ServerA上测试
logger -t app "This is a test message for app"
logger -t auth "This is a test message for auth"
``````

