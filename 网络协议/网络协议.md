## ARP

## Gentuitous ARP 

## STP（最小生成树）

## TCP
### TCP/IP协议发展
![alt text](images\image04.png)
- 最初在1973年，提出了TCPv1版本，此时还没有提出IP协议，IP协议所有的功能都融合在TCP协议中，可以查看(RFC675文档)，该文档描述了TCPv1所有的功能
- 1977年，推出了TCPv2
- 1978年，推出了TCPv3
  - 1978年，国际标准化组织ISO的与会专家提出来当下的TPC协议没有安装OSI进行分层，把网络层和传输层放在同一套协议中，他建议进行分层
- 所以，在1978年开始，历经2年，到1980年，TPC被分层，推出了TCPv4 + IPv4,这就是IPv4是怎么来的，为什么没有ipv1,ipv2..

TCP解决的是任意长度的数据包的可靠传输

### TCP的作用
![alt text](images\image05.png)

通常上图最常见的访问Web页面的场景了解TCP发挥了哪些作用
上图其实有3个网络
- 客户所在的客户端的网络Client Network
- 中间是一个广域网（骨干网），可能是光纤、海底电缆等等
- 企业IDC的内部网络

网络请求过程
- 首先在客户端发起了一个http request的get请求
- http request通过蓝色的线，先由数据链路层将数据包发送到路由器上
- 然后根据网络层也就是IP层，选择最短/最优的路径
- TCP层把不定长度的HTTP请求切分成TCP认为合适的segment(段)，然后将这些切分后的包发送到HTTP Server上，在中间的任意节点中，报文都有可能被丢掉，而且路径也可能发生变化，TCP来保证每一个Segment都能到达http Server
- HTTP Server接收到tcp segment后通常TCP层都是由操作系统内核实现的，操作系统上的kernel按照相同的顺序把http request发给web服务（nginx或者tomcat或者其他）处理，web服务器处理完数据后，将响应数据通过相同的路径将其发送给客户端

在整个过程中
- 如何选择跨越不同的网络是由IP层及其之下的数据链路层实现的
- 如何构造一条消息，如何生成一条响应，是由传输层之上的应用成解决的
- 该消息如何可靠的发送，如何保证顺序，都是有TCP层实现的

### TCP的定义
TCP: 面向连接的、可靠的、基于字节流的传输层通信协议
- 面向连接指的是
  - 面向连接的一定是一对一才能连接，TCP不能像UDP那样一个主机同时向多个主机发送同一条消息
- 可靠的指的是
  - 无论网络链路出现了怎样的链路变化，TCP可以保证报文一定能最终到达接收端
- 基于字节流：
  - 表示消息是没有边界的，无论消息有多大，都可以使用TCP传输
  - 其次，基于字节流，它是一个有序的，当前一个字节，接收端没有收到的时候，即使它先收到了后一个字节，也不能扔给应用层去处理

### TCP功能的实现
TCP众多功能的实现是基于层层嵌套的TCP协议的报文头部实现的

### TCP协议的特点
- 点对点（不能广播，多播），面向连接
- 双向传递 (全双工)
- 字节里：打包成报文段，保证有序接受，重复报文自动丢弃
  - 缺点：不维护应用报文的边界
    - 对比http,使用\r\n，content length来自定义维护报文边界
  - 优点：不强制要求应用必须离散的创建数据块，不限制数据块大小
- 流量缓冲：解决速度不匹配问题
- 可靠的传输服务（保证可达，丢包时通过重发进而增加时延实现可靠性）--- 滑动窗口
- 拥塞控制

### TCP协议的任务
- 主机内的进程寻址
- 创建、管理、终止连接
- 处理并将字节(8bit)流打包成报文段(如IP报文)
- 传输数据
- 保持可靠性与传输质量
  - 保证报文不失序，不乱序，不出错，不丢失
- 流控制与拥塞控制
  - 流控制：解决传输两端传输速度不匹配的问题
  - 拥塞控制：面向整个网络，防止网络中出现恶性拥塞

### TCP三次握手
#### 握手目标
- 同步Sequence序列号
  - 初始序列号ISN(Initial Sequence Number)
- 交换TCP通讯参数
  - 如MSS、窗口比例因子，选择性确认，指定校验和算法

#### 三次握手过程中的状态变迁
三次握手设计到的状态
- CLOSED
- LISTEN
- SYN-SENT
- SYN-RECEIVED
- ESTABLISHED

查看三次握手的状态
```shell
netstat -anp | grep tcp

# netstat用法

interval    # 重新显示选定的统计信息，各个显示间暂停的间隔秒数
-a          # 显示所有连接和侦听端口
-n          # 以数字形式(如IP地址)显示地址和端口号
-r          # 显示路由表
-s          # 显示每个协议的统计信息
-b(Windows)/-p(Linux)    # 显示对应的可执行程序名
```
![alt text](images\image06.png)


#### 补充概念TCB
TCB: Transmission Control Block：
保存连接使用的源端口，目的端口，目的IP，序号，应答序号，对方窗口大小，己方窗口大小，tcp状态，tcp输入/输出队列，应用层输出队列，tcp的重传有关变量等

#### 三次握手过程中的性能优化与安全问题
![alt text](images\image07.png)

- 客户端发送SYN网络分组 ---> 到达服务器（服务器内核中有对TCP层的实现）
- 在内核中，将SYN分组插入SYN队列中（tcp_max_syn_backlog）；同时会发出一个SYN/ACK网络分组；此时使用netstat查看连接状态，会发现SYN_RECEIVED的状态
- 当服务器收到客户端返回的ACK网络分组后，连接状态会进入ESTABLISHED状态
  - 同时在内核中
    - 将之前插入的SYN网络分组从SYN队列中移除
    - 将其塞入ACCEPT队列
    - 服务器上的应用程序，比如Nginx在调用accept()时，会从ACCEPT队列中，将刚刚的连接取出，在web服务器中处理使用

整个过程可以发现`SYN队列`和`ACCEPT队列`的长度和负载都是相关的，如果该服务器是一个面向每秒几十万请求的高负载的机器，那么上述两个队列的长度是一定要延长的

#### 关于内核处理TCP协议栈
在Linux内核中，处理TCP协议栈的模块是网络子系统(Networking Subsystem)，具体负责TCP协议栈的部分位于几个内核模块和代码路径中
1. `net/ipv4/`：主要负责IPv4协议及其相关的TCP协议的处理。TCP协议的核心实现文件是`tcp.c`，该文件包含了TCP协议的主要逻辑，包括连接管理，数据传输，拥塞控制等

2. `net/core/`：负责网络核心层，包括通用的socket接口，协议族的注册和网络设备接口的管理等

3. `include/ipv6/`：与`net/ipv4/`类似，但负责IPv6下的TCP协议处理

4. `kernel/`：虽然不是直接负责TCP，但与内存管理，调度等密切相关的部分也影响TCP协议栈的性能和行为

这些模块协同工作来处理TCP协议的各种功能，包括连接的建立与终止、数据包的收发、拥塞控制、流量控制等。


#### 高并发场景下的资源消耗
1. CPU资源消耗
1.1 任务调度和上下文切换
任务调度：
在高并发场景下，CPU需要频繁调度不同的线程或进程，以确保每个请求都能被处理。
调度开销：随着并发量增加，调度频率提升，导致CPU花费更多时间在任务切换上，而非实际计算。

上下文切换：
当CPU在多个任务之间切换时，必须保存当前任务的状态（如寄存器、程序计数器等），并恢复下一个任务的状态。
上下文切换开销：大量上下文切换会导致CPU时间片被大量消耗在保存和恢复任务状态上，而非处理实际业务逻辑。

1.2 锁竞争
同步与锁机制：
多线程环境下，多个线程可能需要访问共享资源，如内存数据结构、文件等，为避免竞态条件，使用锁来同步线程。

锁竞争：高并发场景下，大量线程同时争夺锁资源，会导致线程频繁进入等待状态，进而影响CPU的利用率。

自旋锁：
自旋锁让线程在获取锁前持续轮询，而不是进入睡眠状态，虽然避免了线程调度开销，但在高并发下可能导致CPU资源被大量消耗在无效的自旋操作上。

2. 内存资源消耗
2.1 堆内存消耗
对象创建与销毁：
在高并发场景下，每个请求可能会触发大量的对象创建，如请求参数解析、响应数据封装等。

垃圾回收：频繁的对象创建和销毁会导致垃圾回收器频繁运行，尤其是当对象生命周期短暂时，可能导致内存碎片化和垃圾回收暂停（GC Pause），影响系统性能。

2.2 内存泄漏
未释放资源：
在处理高并发请求时，如果程序未能及时释放不再使用的资源（如未关闭的文件句柄、数据库连接等），这些资源会继续占用内存，导致内存泄漏。

内存占用：随着时间推移，内存泄漏会逐渐占满系统内存，最终导致系统崩溃或性能严重下降。

2.3 内存缓存与分页
缓存机制：
系统或应用程序可能会使用内存缓存来提高访问速度。在高并发场景下，缓存大小可能增长迅速，占用大量内存。

分页：当内存不足时，操作系统会将部分内存页面交换到磁盘上（分页），频繁的分页操作会导致性能下降（因为磁盘IO比内存访问慢得多）。

3. IO资源消耗
3.1 磁盘IO
读写请求：
高并发请求可能涉及大量磁盘读写操作，如日志记录、文件存取、数据库查询等。

磁盘瓶颈：如果磁盘IO无法跟上请求速度，会导致请求阻塞，形成IO瓶颈。磁盘的机械性质（如磁头寻道时间）决定了它的并发处理能力有限。

磁盘竞争：
当多个线程或进程同时访问磁盘时，会出现磁盘竞争，导致IO操作排队和延迟。

3.2 网络IO
网络带宽消耗：
高并发的网络请求会消耗大量带宽，尤其是在处理大数据量传输时。
网络拥塞：带宽有限时，大量并发请求可能导致网络拥塞，增加数据包的丢失率和重传率，从而进一步降低系统性能。

网络延迟：
高并发下，网络设备（如路由器、交换机）处理大量数据包，可能导致延迟增加，影响响应时间。

4. 连接池资源消耗
4.1 连接池的工作机制
连接池简介：
连接池用于管理数据库连接、HTTP连接等资源，通过复用连接来减少连接建立和销毁的开销。
高并发场景下，连接池有助于降低连接创建和销毁的频率，但同时也带来了管理和资源占用问题。

4.2 连接耗尽与资源争用
连接耗尽：
在高并发场景下，如果请求数量超过了连接池的容量，新的请求将被阻塞，直到有空闲连接可用。这种情况下，可能导致连接耗尽，影响系统的处理能力。

连接超时：
高并发可能导致连接池中的连接频繁超时。连接超时会导致资源释放不及时，甚至可能导致连接池内连接资源的枯竭。

4.3 连接池的管理开销
连接的创建与销毁：
尽管连接池能够复用连接，但在高并发下，仍可能因为连接池达到上限而触发频繁的连接创建和销毁操作，增加了系统开销。

锁机制：
连接池内部通常需要使用锁来管理连接资源，保证并发访问的安全性。高并发下，锁的竞争会导致连接获取的延迟。

5. 总结
在高并发场景下，系统中的每种资源都会面临不同程度的消耗和压力：

CPU资源：主要被任务调度、上下文切换、锁竞争所消耗。优化策略包括减少上下文切换、使用无锁数据结构等。

内存资源：主要消耗在对象创建与垃圾回收、内存泄漏、缓存与分页上。可以通过优化内存管理、合理设置缓存大小来缓解。

IO资源：包括磁盘和网络IO的瓶颈，优化手段包括使用缓存、优化文件存储策略、使用更高效的网络协议等。

连接池资源：通过合理设置连接池大小、超时策略、连接复用等，可以有效缓解连接资源的枯竭问题。

了解和优化这些资源的消耗过程，是设计和开发高性能、高可用系统的关键。在实际应用中，常常需要结合具体的业务场景、系统瓶颈、性能测试结果来采取针对性的优化措施。

#### 高并发场景下解决方案
- 应用层connect超时时间调整
```shell
# connect timeout定义
connect timeout 是指应用程序在尝试与服务器建立连接时，等待连接成功的最大时间。如果在这个时间内连接未成功建立，连接操作就会超时并失败

# 调整connect timout的好处
## 快速失败机制
设置较短的 connect timeout 时间，意味着在连接请求未能快速建立时，应用程序能够更快地放弃该请求，并释放相关资源（如线程、连接池等）。这避免了连接长期占用资源，导致系统资源耗尽。

## 降低负载
连接失败的时间缩短时，服务器可以避免处理过多积压的连接请求，从而减少负载，并让系统更快地恢复到稳定状态。

## 改善用户体验
长时间的连接等待会导致用户感知到的延迟增加，这在用户体验上是不可接受的。通过缩短 connect timeout，可以更快地通知用户当前的网络或服务异常，从而提升用户体验。
```



### 通过实验深入了解TCP连接的建立和关闭
### 前置知识补充
#### tcpdump的使用
```shell
# tcpdump的用法
# 捕获指定接口的流量
tcpdump -i eth0

# 捕获指定数量的数据包
tcpdump -c 10

# 用于显示捕获的数据包的十六进制和ASCII格式内容
tcpdump -X
# 这个选项告诉"tcpdump"，在捕获并显示数据包时，不仅要显示数据包的头部信息，还要显示数据包的负载(payload)部分

# 过滤数据包
# 捕获特定协议数据包
tcpdump icmp     # 只捕获ICMP协议的数据包

# 捕获特定主机的数据包
tcpdump host 192.168.0.2  # 捕获来自或发往IP地址192.168.0.2的数据包

# 捕获特定端口的数据包
tcpdump port 80           # 只捕获TCP或UDP端口为80的数据包(常用于HTTP流量分析)

# 捕获来自指定源或目的数据包
tcpdump src port 22
tcpdump dst port 53

# 高级用法
# 显示更详细的包信息：
tcpdump -vv

# 显示链路层头信息：
tcpdump -e      # 显示数据链路层的头信息，如MAC地址

# 组合使用（组合过滤条件）
tcpdump tcp and port 80 and host 192.168.1.1
```

#### nc的使用
```shell
# -l选项(监听模式/listen mode)
# 这个选项使nc进入监听模式，充当一个服务器，等待传入的连接。通常用于创建一个简单的TCP或UDP服务器，监听指定的端口并接收连接请求
# 示例
nc -l 12345   # 监听当前机器的12345端口,等待其他客户端的连接

# -k选项（保持连接/keep-open）
# 这个选项通常与-l结合使用，告诉nc在当前连接关闭后继续保持监听状态，不退出，从而允许新的连接再次连接到同一个端口
# 在不使用"-k"时，nc在接收一个连接并关闭连接后会退出。如果你希望nc能持续接收多个连接而不退出，就需要使用-k选项
nc -l -k 12345
```

#### TCP连接的建立
- 开启抓包
```shell
# 在10.0.0.122主机上
# 抓取TCP端口为9527的数据包
tcpdump -s0 -X -nn "tcp port 9527" -w tcp.pcap --print

# 在10.0.0.122主机上使用nc监听9527端口
nc -k -l 10.0.0.122 9527

# 查看端口状态
[root@worker1 ~]#netstat -anpo|grep Recv-Q;netstat -anpo | grep 9527
Proto Recv-Q Send-Q Local Address           Foreign Address         State       PID/Program name     Timer
tcp        0      0 10.0.0.122:9527         0.0.0.0:*               LISTEN      152632/nc            关闭 (0.00/0/0)

# 在10.0.0.121上查看服务端和客户端的连接信息
[root@master1 ~]#netstat -anpo|grep Recv-Q;netstat -anpo | grep 9527
Proto Recv-Q Send-Q Local Address           Foreign Address         State       PID/Program name     Timer
tcp        0      0 10.0.0.121:38114        10.0.0.122:9527         ESTABLISHED 117704/nc            关闭 (0.00/0/0)

# 此时在10.0.0.122上用nc监听的上面可以看到3次握手的信息
13:38:34.306735 IP 10.0.0.121.38114 > 10.0.0.122.9527: Flags [S], seq 1420407109, win 64240, options [mss 1460,sackOK,TS val 2998988679 ecr 0,nop,wscale 7], length 0
	0x0000:  4500 003c 4f91 4000 4006 d638 0a00 0079  E..<O.@.@..8...y
	0x0010:  0a00 007a 94e2 2537 54a9 b145 0000 0000  ...z..%7T..E....
	0x0020:  a002 faf0 d5cb 0000 0204 05b4 0402 080a  ................
	0x0030:  b2c0 ef87 0000 0000 0103 0307            ............
13:38:34.306792 IP 10.0.0.122.9527 > 10.0.0.121.38114: Flags [S.], seq 2715825113, ack 1420407110, win 65160, options [mss 1460,sackOK,TS val 2679345721 ecr 2998988679,nop,wscale 7], length 0
	0x0000:  4500 003c 0000 4000 4006 25ca 0a00 007a  E..<..@.@.%....z
	0x0010:  0a00 0079 2537 94e2 a1e0 33d9 54a9 b146  ...y%7....3.T..F
	0x0020:  a012 fe88 1521 0000 0204 05b4 0402 080a  .....!..........
	0x0030:  9fb3 9239 b2c0 ef87 0103 0307            ...9........
13:38:34.307293 IP 10.0.0.121.38114 > 10.0.0.122.9527: Flags [.], ack 1, win 502, options [nop,nop,TS val 2998988680 ecr 2679345721], length 0
	0x0000:  4500 0034 4f92 4000 4006 d63f 0a00 0079  E..4O.@.@..?...y
	0x0010:  0a00 007a 94e2 2537 54a9 b146 a1e0 33da  ...z..%7T..F..3.
	0x0020:  8010 01f6 f5d9 0000 0101 080a b2c0 ef88  ................
	0x0030:  9fb3 9239                                ...9
```

使用wireshark打开tcp.pcap文件
![alt text](images\image01.png)

#### TCP协议头解析
![alt text](images\image02.png)

该报文的TCP协会头共40字节
- TCP头：20字节
- Options(20 bytes): 20字节

这个握手包恰好覆盖了 1、2、3、4、8 这五种常见的 options 字段：
![alt text](images\image03.png)

- Kind: Maximum Segment Size(2)
  - 告知对端自己的MSS值
  - MSS 选项传输的头是 MTU 减去 IP 基本头（v4 20 字节，v6 40 字节）和 TCP 基本头（20字节）的值，不考虑扩展头。从 ifconfig 的输出能看出来 MTU 是 1500，减去 IPv4 的 20 字节和 TCP 的 20 字节恰好是 1460 字节。
```shell
eth0: flags=4163<UP,BROADCAST,RUNNING,MULTICAST>  mtu 1500
      inet 10.0.0.122  netmask 255.255.255.0  broadcast 10.0.0.255
      inet6 fe80::250:56ff:fe21:355c  prefixlen 64  scopeid 0x20<link>
      ether 00:50:56:21:35:5c  txqueuelen 1000  (以太网)
      RX packets 105591  bytes 39257832 (39.2 MB)
      RX errors 0  dropped 0  overruns 0  frame 0
      TX packets 72146  bytes 6799365 (6.7 MB)
      TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0

# MTU知识点补充
# MTU定义
# MTU是网络接口能处理的最大数据包大小，包含数据和协议头部
# 例如：MTU为1500表示这个网络接口能够处理的最大数据包大小为1500字节

# MTU作用：
# 数据包作用：如果一个数据包大于MTU，它会被分段(或分片)成多个较小的数据包进行传输。这种分段在传输过程中可能会增加延迟和降低效率
# 避免数据包分片：通过设置合理的MTU值，可以尽量避免数据包在传输过程中被分片
# 分片的数据包在传输时，如果其中一个片段丢失，整个数据包必须重新传输，这会增加网络负载
```

- Kind: SACK Permitted(4)
  - 该选项在后续“TCP 发送和接收数据”的讲解中在详细叙述
  - Linux 内核参数 net.ipv4.tcp_sack 可以控制这个特性的开关。
  ```shell
  $ sysctl net.ipv4.tcp_sack
  net.ipv4.tcp_sack = 1
  ```

- Kind: Time Stamp Option(8)
  - 时间戳标记
  - 内核使用 TCP 时间戳来更好地估算 TCP 连接中的往返时间 (RTTM, Round Trip Time Measurement)，可以更准确的进行 TCP 窗口和缓冲区的计算。
  - 这个特性的开关可以用内核参数 net.ipv4.tcp_timestamps 控制
  ```shell
  $ sysctl net.ipv4.tcp_timestamps
  net.ipv4.tcp_timestamps = 1 
  # 0 表示TCP 时间戳被禁用，1 表示 TCP 时间戳被启用（默认），2 表示 TCP 时间戳被启用，但没有随机偏移
  ```

- Kind：No-Operation(1)
  - NOP 一般是占位对齐用的。因为 TCP 包头 offset 字段的值是以 4 字节为单位的，所以 TCP 头的大小也只能是 4 的倍数。

- Kind: Window scale(3)
  - 表示 TCP 窗口缩放
  - TCP 协议头的窗口大小由 2 字节表示（最大 65535 字节），但实际上内核默认的 TCP 缓存区大小比这个值大很多：




## TLS
### 